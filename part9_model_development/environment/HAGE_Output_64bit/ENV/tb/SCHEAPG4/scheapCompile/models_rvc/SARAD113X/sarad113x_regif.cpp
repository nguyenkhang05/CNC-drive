// -----------------------------------------------------------------------------
// $Id$
//
// Copyright(c) 2010-2014 Renesas Electronics Corporation
// Copyright(c) 2010-2014 Renesas Design Vietnam Co., Ltd.
// RENESAS ELECTRONICS CONFIDENTIAL AND PROPRIETARY.
// This program must be used solely for the purpose for which
// it was furnished by Renesas Electronics Corporation. No part of this
// program may be reproduced or disclosed to others, in any
// form, without the prior written permission of Renesas Electronics
// Corporation.
// -----------------------------------------------------------------------------
// This file is generated by Register I/F generator
//    gen_regif.py 1.9 2013/12/04 09:51:36 sontran
//    gen_regif_class.py 1.62 2014/11/28 10:17:23 ducduong
//    regif_cpp.skl 1.55 2014/11/28 10:17:23 ducduong
//
// Input file : sarad113x_regif.txt
////////////////////////////////////////////////////////////////////////////////
// # -----------------------------------------------------------------------------
// # $Id$
// #
// # Copyright(c) 2015 Renesas Electronics Corporation
// # Copyright(c) 2015 Renesas Design Vietnam Co., Ltd.
// # RENESAS ELECTRONICS CONFIDENTIAL AND PROPRIETARY.
// # This program must be used solely for the purpose for which
// # it was furnished by Renesas Electronics Corporation. No part of this
// # program may be reproduced or disclosed to others, in any
// # form, without the prior written permission of Renesas Electronics
// # Corporation.
// # -----------------------------------------------------------------------------
// 
// %MODULE sarad113x
//     #              name     offset_size  
//     %%REG_INSTANCE reg_def  11           
// 
// %REG_CHANNEL   reg_def
//     %%TITLE  name        access  init        offset  length  size        factor_start  factor_end  factor_index  factor_step  support  
//     %%REG    VCR         R|W     0x00000000  0x000   32      8|16|32     0             49          -             0x4          TRUE     
//     %%REG    TSNVCR      R|W     0x00000025  0x0F0   32      8|16|32     -             -           -             -            TRUE     
//     %%REG    PWDVCR      R|W     0x00000000  0x0F4   32      8|16|32     -             -           -             -            TRUE     
//     %%REG    DR          R       0x00000000  0x100   32      16|32       0             24          -             0x4          TRUE     
//     %%REG    PWDTSNDR    R       0x00000000  0x178   32      16|32       -             -           -             -            TRUE     
//     %%REG    DIR         R       0x00000000  0x200   32      32          0             49          -             0x4          TRUE     
//     %%REG    TSNDIR      R       0x00250000  0x2F0   32      32          -             -           -             -            TRUE     
//     %%REG    PWDDIR      R       0x00000000  0x2F4   32      32          -             -           -             -            TRUE     
//     %%REG    ADHALTR     R|W     0x00000000  0x300   32      8|16|32     -             -           -             -            TRUE     
//     %%REG    ADCR        R|W     0x00000000  0x304   32      8|16|32     -             -           -             -            TRUE     
//     %%REG    SGSTR       R       0x00000000  0x308   32      16|32       -             -           -             -            TRUE     
//     %%REG    MPXCURR     R       0x00000000  0x30C   32      8|16|32     -             -           -             -            TRUE     
//     %%REG    TSNCR       R|W     0x00000000  0x310   32      8|16|32     -             -           -             -            TRUE     
//     %%REG    THSMPSTCR   R|W     0x00000000  0x314   32      8|16|32     -             -           -             -            TRUE     
//     %%REG    THCR        R|W     0x00000000  0x318   32      8|16|32     -             -           -             -            TRUE     
//     %%REG    THAHLDSTCR  R|W     0x00000000  0x31C   32      8|16|32     -             -           -             -            TRUE     
//     %%REG    THBHLDSTCR  R|W     0x00000000  0x320   32      8|16|32     -             -           -             -            TRUE     
//     %%REG    THACR       R|W     0x00000000  0x324   32      8|16|32     -             -           -             -            TRUE     
//     %%REG    THBCR       R|W     0x00000000  0x328   32      8|16|32     -             -           -             -            TRUE     
//     %%REG    THER        R|W     0x00000000  0x32C   32      8|16|32     -             -           -             -            TRUE     
//     %%REG    THGSR       R|W     0x00000000  0x330   32      8|16|32     -             -           -             -            TRUE     
//     %%REG    SFTCR       R|W     0x00000000  0x334   32      8|16|32     -             -           -             -            TRUE     
//     %%REG    ULLMTBR     R|W     0xFFF00000  0x338   32      8|16|32     0             2           -             0x4          TRUE     
//     %%REG    ECR         R|W     0x00000000  0x344   32      8|16|32     -             -           -             -            TRUE     
//     %%REG    ULER        R       0x00000000  0x348   32      8|16|32     -             -           -             -            TRUE     
//     %%REG    OWER        R       0x00000000  0x34C   32      8|16|32     -             -           -             -            TRUE     
//     %%REG    DGCTL0      R|W     0x00000000  0x350   32      8|16|32     -             -           -             -            TRUE     
//     %%REG    DGCTL1      R|W     0x00000000  0x354   32      8|16|32     -             -           -             -            TRUE     
//     %%REG    PDCTL1      R|W     0x00000000  0x358   32      8|16|32     -             -           -             -            TRUE     
//     %%REG    PDCTL2      R|W     0x00000000  0x35C   32      8|16|32     -             -           -             -            TRUE     
//     %%REG    SMPCR       R|W     0x00000018  0x380   32      8|16|32     -             -           -             -            TRUE     
//     %%REG    TSNSMPCR    R|W     0x000000f0  0x384   32      8|16|32     -             -           -             -            TRUE     
//     %%REG    EMUCR       R|W     0x00000000  0x388   32      8|16|32     -             -           -             -            TRUE     
//     %%REG    SGPRCR      R|W     0x00043210  0x38C   32      8|16|32     -             -           -             -            TRUE     
//     %%REG    TRMCR       R|W     0x00000000  0x3C0   32      32          -             -           -             -            FALSE    
//     %%REG    ADTSTRA     R|W     0x00000000  0x3C4   32      32          -             -           -             -            FALSE    
//     %%REG    ADTSTRB     R|W     0x00000000  0x3C8   32      32          -             -           -             -            FALSE    
//     %%REG    ADTSTRC     R|W     0x00000000  0x3CC   32      32          -             -           -             -            FALSE    
//     %%REG    SGSTCR      R|W     0x00000000  0x440   32      8|16|32     1             3           -             0x40         TRUE     
//     %%REG    TSNSGSTCR   R|W     0x00000000  0x400   32      8|16|32     -             -           -             -            TRUE     
//     %%REG    PWDSGSTCR   R|W     0x00000000  0x500   32      8|16|32     -             -           -             -            TRUE     
//     %%REG    SGCR        R|W     0x00000000  0x448   32      8|16|32     1             3           -             0x40         TRUE     
//     %%REG    TSNSGCR     R|W     0x00000000  0x408   32      8|16|32     -             -           -             -            TRUE     
//     %%REG    PWDSGCR     R|W     0x00000000  0x508   32      8|16|32     -             -           -             -            TRUE     
//     %%REG    SGSEFCR     R|W     0x00000000  0x458   32      8|16|32     1             3           -             0x40         TRUE     
//     %%REG    TSNSGSEFCR  R|W     0x00000000  0x418   32      8|16|32     -             -           -             -            TRUE     
//     %%REG    PWDSGSEFCR  R|W     0x00000000  0x518   32      8|16|32     -             -           -             -            TRUE     
//     %%REG    SGVCSP      R|W     0x00000000  0x44C   32      8|16|32     1             3           -             0x40         TRUE     
//     %%REG    SGVCEP      R|W     0x00000000  0x450   32      8|16|32     1             3           -             0x40         TRUE     
//     %%REG    SGMCYCR     R|W     0x00000000  0x454   32      8|16|32     1             3           -             0x40         TRUE     
//     %%REG    SGTSEL      R|W     0x00000000  0x45C   32      16|32       1             3           -             0x40         TRUE     
// 
// 
// %REG_NAME  VCR         
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    MPXE        15     15     0           W|R     -        -         
//     %%BIT    MPXV        14     12     0           W|R     -        -         
//     %%BIT    CNVCLS      9      9      0           W|R     -        -         
//     %%BIT    ULS         7      6      0           W|R     -        -         
//     %%BIT    ADIE        8      8      0           W|R     -        -         
//     %%BIT    GCTRL       5      0      0           W|R     -        W         
// 
// %REG_NAME  TSNVCR      
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    ULS         7      6      0           W|R     -        W         
//     %%BIT    TSNGCTRL    5      0      0x25        R       -        -         
// 
// %REG_NAME  PWDVCR      
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    MPXE        15     15     0           R       -        -         
//     %%BIT    MPXV        14     12     0           R       -        -         
//     %%BIT    ULS         7      6      0           R       -        -         
//     %%BIT    GCTRL       5      0      0           R       -        -         
// 
// %REG_NAME  DR          
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    DR1         31     16     0           R       -        -         
//     %%BIT    DR0         15     0      0           R       -        R         
// 
// %REG_NAME  PWDTSNDR    
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    PWDDR       31     16     0           R       -        -         
//     %%BIT    TSNDR       15     0      0           R       -        R         
// 
// %REG_NAME  DIR         
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    MPXE        31     31     0           R       -        -         
//     %%BIT    MPXV        30     28     0           R       -        -         
//     %%BIT    WFLG        25     25     0           R       -        -         
//     %%BIT    ID          21     16     0           R       -        -         
//     %%BIT    DR          15     0      0           R       -        R         
// 
// %REG_NAME  TSNDIR      
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    WFLG        25     25     0           R       -        -         
//     %%BIT    ID          21     16     0x25        R       -        -         
//     %%BIT    TSNDR       15     0      0           R       -        R         
// 
// %REG_NAME  PWDDIR      
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    MPXE        31     31     0           R       -        -         
//     %%BIT    MPXV        30     28     0           R       -        -         
//     %%BIT    WFLG        25     25     0           R       -        -         
//     %%BIT    ID          21     16     0           R       -        -         
//     %%BIT    PWDDR       15     0      0           R       -        R         
// 
// %REG_NAME  ADHALTR     
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    HALT        0      0      0           W|R     -        W         
// 
// %REG_NAME  ADCR        
//     %%TITLE  name        upper  lower  init        access  support  callback  value         
//     %%BIT    DGON        7      7      0           W|R     -        -         -             
//     %%BIT    TSNSELFDIAG 6      6      0           W|R     -        -         -             
//     %%BIT    CRAC        5      5      0           W|R     -        -         -             
//     %%BIT    CTYP        4      4      0           W|R     -        -         -             
//     %%BIT    SUSMTD      1      0      0           W|R     -        W         b00,b01,b10   
// 
// %REG_NAME  SGSTR       
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    SHACT       14     14     0           R       -        -         
//     %%BIT    SGACT       13     8      0           R       -        -         
//     %%BIT    SEF         4      0      0           R       -        -         
// 
// %REG_NAME  MPXCURR     
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    MPXCUR      2      0      0           R       -        -         
// 
// %REG_NAME  TSNCR       
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    TSNEN       0      0      0           W|R     -        W         
// 
// %REG_NAME  THSMPSTCR   
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    SMPST       0      0      0           W|R     TRUE     W         
// 
// %REG_NAME  THCR        
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    ASMPMSK     0      0      0           W|R     TRUE     W         
// 
// %REG_NAME  THAHLDSTCR  
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    HLDST       0      0      0           W|R     TRUE     W         
// 
// %REG_NAME  THBHLDSTCR  
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    HLDST       0      0      0           W|R     TRUE     W         
// 
// %REG_NAME  THACR       
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    HLDCTE      5      5      0           W|R     TRUE     -         
//     %%BIT    HLDTE       4      4      0           W|R     TRUE     -         
//     %%BIT    SGS         1      0      0           W|R     TRUE     W         
// 
// %REG_NAME  THBCR       
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    HLDCTE      5      5      0           W|R     TRUE     -         
//     %%BIT    HLDTE       4      4      0           W|R     TRUE     -         
//     %%BIT    SGS         1      0      0           W|R     TRUE     W         
// 
// %REG_NAME  THER        
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    TH5E        5      5      0           W|R     TRUE     -         
//     %%BIT    TH4E        4      4      0           W|R     TRUE     -         
//     %%BIT    TH3E        3      3      0           W|R     TRUE     -         
//     %%BIT    TH2E        2      2      0           W|R     TRUE     -         
//     %%BIT    TH1E        1      1      0           W|R     TRUE     -         
//     %%BIT    TH0E        0      0      0           W|R     TRUE     W         
// 
// %REG_NAME  THGSR       
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    TH5GS       5      5      0           W|R     TRUE     -         
//     %%BIT    TH4GS       4      4      0           W|R     TRUE     -         
//     %%BIT    TH3GS       3      3      0           W|R     TRUE     -         
//     %%BIT    TH2GS       2      2      0           W|R     TRUE     -         
//     %%BIT    TH1GS       1      1      0           W|R     TRUE     -         
//     %%BIT    TH0GS       0      0      0           W|R     TRUE     W         
// 
// %REG_NAME  SFTCR       
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    RDCLRE      4      4      0           W|R     -        -         
//     %%BIT    ULEIE       3      3      0           W|R     -        -         
//     %%BIT    OWEIE       2      2      0           W|R     -        W         
// 
// %REG_NAME  ULLMTBR     
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    ULMTB       31     20     4095        -       -        W         
//     %%BIT    LLMTB       15     4      0           -       -        -         
// 
// %REG_NAME  ECR         
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    ULEC        3      3      0           W|R     -        W         
//     %%BIT    OWEC        2      2      0           W|R     -        -         
// 
// %REG_NAME  ULER        
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    UE          15     15     0           R       -        -         
//     %%BIT    LE          14     14     0           R       -        -         
//     %%BIT    ULSG        13     12     0           R       -        -         
//     %%BIT    MPXE        11     11     0           R       -        -         
//     %%BIT    MPXV        10     8      0           R       -        -         
//     %%BIT    ULE         7      7      0           R       -        -         
//     %%BIT    ULECAP      5      0      0           R       -        -         
// 
// %REG_NAME  OWER        
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    OWE         7      7      0           R       -        -         
//     %%BIT    OWECAP      5      0      0           R       -        -         
// 
// %REG_NAME  DGCTL0      
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    PSEL2       2      2      0           W|R     -        -         
//     %%BIT    PSEL1       1      1      0           W|R     -        -         
//     %%BIT    PSEL0       0      0      0           W|R     -        W         
// 
// %REG_NAME  DGCTL1      
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    CDG15       15     15     0           W|R     -        -         
//     %%BIT    CDG14       14     14     0           W|R     -        -         
//     %%BIT    CDG13       13     13     0           W|R     -        -         
//     %%BIT    CDG12       12     12     0           W|R     -        -         
//     %%BIT    CDG11       11     11     0           W|R     -        -         
//     %%BIT    CDG10       10     10     0           W|R     -        -         
//     %%BIT    CDG09       9      9      0           W|R     -        -         
//     %%BIT    CDG08       8      8      0           W|R     -        -         
//     %%BIT    CDG07       7      7      0           W|R     -        -         
//     %%BIT    CDG06       6      6      0           W|R     -        -         
//     %%BIT    CDG05       5      5      0           W|R     -        -         
//     %%BIT    CDG04       4      4      0           W|R     -        -         
//     %%BIT    CDG03       3      3      0           W|R     -        -         
//     %%BIT    CDG02       2      2      0           W|R     -        -         
//     %%BIT    CDG01       1      1      0           W|R     -        -         
//     %%BIT    CDG00       0      0      0           W|R     -        W         
// 
// %REG_NAME  PDCTL1      
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    PDNA15      15     15     0           W|R     -        -         
//     %%BIT    PDNA14      14     14     0           W|R     -        -         
//     %%BIT    PDNA13      13     13     0           W|R     -        -         
//     %%BIT    PDNA12      12     12     0           W|R     -        -         
//     %%BIT    PDNA11      11     11     0           W|R     -        -         
//     %%BIT    PDNA10      10     10     0           W|R     -        -         
//     %%BIT    PDNA09      9      9      0           W|R     -        -         
//     %%BIT    PDNA08      8      8      0           W|R     -        -         
//     %%BIT    PDNA07      7      7      0           W|R     -        -         
//     %%BIT    PDNA06      6      6      0           W|R     -        -         
//     %%BIT    PDNA05      5      5      0           W|R     -        -         
//     %%BIT    PDNA04      4      4      0           W|R     -        -         
//     %%BIT    PDNA03      3      3      0           W|R     -        -         
//     %%BIT    PDNA02      2      2      0           W|R     -        -         
//     %%BIT    PDNA01      1      1      0           W|R     -        -         
//     %%BIT    PDNA00      0      0      0           W|R     -        W         
// 
// %REG_NAME  PDCTL2      
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    PDNB19      19     19     0           W|R     -        -         
//     %%BIT    PDNB18      18     18     0           W|R     -        -         
//     %%BIT    PDNB17      17     17     0           W|R     -        -         
//     %%BIT    PDNB16      16     16     0           W|R     -        -         
//     %%BIT    PDNB15      15     15     0           W|R     -        -         
//     %%BIT    PDNB14      14     14     0           W|R     -        -         
//     %%BIT    PDNB13      13     13     0           W|R     -        -         
//     %%BIT    PDNB12      12     12     0           W|R     -        -         
//     %%BIT    PDNB11      11     11     0           W|R     -        -         
//     %%BIT    PDNB10      10     10     0           W|R     -        -         
//     %%BIT    PDNB09      9      9      0           W|R     -        -         
//     %%BIT    PDNB08      8      8      0           W|R     -        -         
//     %%BIT    PDNB07      7      7      0           W|R     -        -         
//     %%BIT    PDNB06      6      6      0           W|R     -        -         
//     %%BIT    PDNB05      5      5      0           W|R     -        -         
//     %%BIT    PDNB04      4      4      0           W|R     -        -         
//     %%BIT    PDNB03      3      3      0           W|R     -        -         
//     %%BIT    PDNB02      2      2      0           W|R     -        -         
//     %%BIT    PDNB01      1      1      0           W|R     -        -         
//     %%BIT    PDNB00      0      0      0           W|R     -        W         
// 
// %REG_NAME  SMPCR       
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    SMPT        7      0      0x18        W|R     -        W         
// 
// %REG_NAME  TSNSMPCR    
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    TSNSMPT     7      0      0xF0        W|R     -        W         
// 
// %REG_NAME  EMUCR       
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    SVSDIS      7      7      0           W|R     -        W         
// 
// %REG_NAME  SGPRCR      
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    SGPR4       18     16     4           W|R     -        -         
//     %%BIT    SGPR3       14     12     3           W|R     -        -         
//     %%BIT    SGPR2       10     8      2           W|R     -        -         
//     %%BIT    SGPR1       6      4      1           W|R     -        -         
//     %%BIT    SGPR0       2      0      0           W|R     -        W         
// 
// %REG_NAME  TRMCR
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    TRMS        31     31     0           W|R     FALSE    -         
//     %%BIT    TRMDGSTBY   27     27     0           W|R     FALSE    -         
//     %%BIT    TRMTSNTUNE  15     14     0           W|R     FALSE    -         
//     %%BIT    TRMTTUNE    13     12     0           W|R     FALSE    -         
//     %%BIT    TRMBTUNE    11     10     0           W|R     FALSE    -         
//     %%BIT    TRMATUNE    9      8      0           W|R     FALSE    -         
//     %%BIT    TRMTSN      7      6      0           R       FALSE    -         
//     %%BIT    TRMT        5      4      0           R       FALSE    -         
//     %%BIT    TRMB        3      2      0           R       FALSE    -         
//     %%BIT    TRMA        1      0      0           R       FALSE    -         
// 
// %REG_NAME  ADTSTRA
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    ADTST       7      0      0           W|R     FALSE    -         
// 
// %REG_NAME  ADTSTRB
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    ADVAL       13     0      0           W|R     FALSE    -         
// 
// %REG_NAME  ADTSTRC
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    CKSTP       13     13     0           W|R     FALSE    -         
//     %%BIT    SYNCERR     12     12     0           R       FALSE    -         
//     %%BIT    ADMD8       8      8      0           W|R     FALSE    -         
//     %%BIT    ADMD7       7      7      0           W|R     FALSE    -         
//     %%BIT    ADMD6       6      6      0           W|R     FALSE    -         
//     %%BIT    ADMD5       5      5      0           W|R     FALSE    -         
//     %%BIT    ADMD4       4      4      0           W|R     FALSE    -         
//     %%BIT    ADMD3       3      3      0           R       FALSE    -         
//     %%BIT    ADMD        2      0      0           W|R     FALSE    -         
// 
// %REG_NAME  SGSTCR      
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    SGSTn       0      0      0           W|R     -        W         
// 
// %REG_NAME  TSNSGSTCR   
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    TSNSGST     0      0      0           W|R     -        W         
// 
// %REG_NAME  PWDSGSTCR   
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    PWDSGST     0      0      0           W|R     -        W         
// 
// %REG_NAME  SGCR        
//     %%TITLE  name        upper  lower  init        access  support  callback  value
//     %%BIT    SCANMD      5      5      0           W|R     -        -         -
//     %%BIT    ADIE        4      4      0           W|R     -        W         -
//     %%BIT    SCT         3      2      0           W|R     -        -         b00,b01,b10   
//     %%BIT    TRGMD       0      0      0           W|R     -        -         -
// 
// %REG_NAME  TSNSGCR     
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    TSNTRGMD    0      0      0           W|R     -        W         
// 
// %REG_NAME  PWDSGCR     
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    PWDTRGMD    0      0      0           W|R     -        W         
// 
// %REG_NAME  SGSEFCR     
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    SEFCn       0      0      0           W|R     -        W         
// 
// %REG_NAME  TSNSGSEFCR  
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    TSNSEFC     0      0      0           W|R     -        W         
// 
// %REG_NAME  PWDSGSEFCR  
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    PWDSEFC     0      0      0           W|R     -        W         
// 
// %REG_NAME  SGVCSP      
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    VCSP        5      0      0           W|R     -        W         
// 
// %REG_NAME  SGVCEP      
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    VCEP        5      0      0           W|R     -        W         
// 
// %REG_NAME  SGMCYCR     
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    MCYC        7      0      0           W|R     -        W         
// 
// %REG_NAME  SGTSEL      
//     %%TITLE  name        upper  lower  init        access  support  callback  
//     %%BIT    TxSEL15     15     15     0           W|R     -        -         
//     %%BIT    TxSEL14     14     14     0           W|R     -        -         
//     %%BIT    TxSEL13     13     13     0           W|R     -        -         
//     %%BIT    TxSEL12     12     12     0           W|R     -        -         
//     %%BIT    TxSEL11     11     11     0           W|R     -        -         
//     %%BIT    TxSEL10     10     10     0           W|R     -        -         
//     %%BIT    TxSEL09     9      9      0           W|R     -        -         
//     %%BIT    TxSEL08     8      8      0           W|R     -        -         
//     %%BIT    TxSEL07     7      7      0           W|R     -        -         
//     %%BIT    TxSEL06     6      6      0           W|R     -        -         
//     %%BIT    TxSEL05     5      5      0           W|R     -        -         
//     %%BIT    TxSEL04     4      4      0           W|R     -        -         
//     %%BIT    TxSEL03     3      3      0           W|R     -        -         
//     %%BIT    TxSEL02     2      2      0           W|R     -        -         
//     %%BIT    TxSEL01     1      1      0           W|R     -        -         
//     %%BIT    TxSEL00     0      0      0           W|R     -        W|R         
////////////////////////////////////////////////////////////////////////////////
/// @file sarad113x_regif.cpp
/// @brief Register IF class of model SARAD113x
/// $Id$
/// $Date$
/// $Revison$
/// $Author$
////////////////////////////////////////////////////////////////////////////////
#include "sarad113x_regif.h"
#ifndef re_printf
#define re_printf get_fileline(__FILE__, __LINE__); _re_printf
#endif//re_printf

/// Constructor of Register IF class: define registers and bits
/// @return none
Csarad113x_regif::Csarad113x_regif(std::string name, uint buswidth)
    :vpcl::reg_super()
    #ifdef CWR_SYSTEMC
    , cwmem("register", 0x4E0)
    #endif
{
    uint FactorIndex_SGSTCR_tmp[emNUM_SGSTCR] = {   1,   2,   3};
    uint FactorIndex_SGCR_tmp[emNUM_SGCR] = {   1,   2,   3};
    uint FactorIndex_SGSEFCR_tmp[emNUM_SGSEFCR] = {   1,   2,   3};
    uint FactorIndex_SGVCSP_tmp[emNUM_SGVCSP] = {   1,   2,   3};
    uint FactorIndex_SGVCEP_tmp[emNUM_SGVCEP] = {   1,   2,   3};
    uint FactorIndex_SGMCYCR_tmp[emNUM_SGMCYCR] = {   1,   2,   3};
    uint FactorIndex_SGTSEL_tmp[emNUM_SGTSEL] = {   1,   2,   3};
    for(uint i = 0; i < emNUM_SGSTCR; i++) {
        mFactorIndexSGSTCR[i] = FactorIndex_SGSTCR_tmp[i];
    }
    for(uint i = 0; i < emNUM_SGCR; i++) {
        mFactorIndexSGCR[i] = FactorIndex_SGCR_tmp[i];
    }
    for(uint i = 0; i < emNUM_SGSEFCR; i++) {
        mFactorIndexSGSEFCR[i] = FactorIndex_SGSEFCR_tmp[i];
    }
    for(uint i = 0; i < emNUM_SGVCSP; i++) {
        mFactorIndexSGVCSP[i] = FactorIndex_SGVCSP_tmp[i];
    }
    for(uint i = 0; i < emNUM_SGVCEP; i++) {
        mFactorIndexSGVCEP[i] = FactorIndex_SGVCEP_tmp[i];
    }
    for(uint i = 0; i < emNUM_SGMCYCR; i++) {
        mFactorIndexSGMCYCR[i] = FactorIndex_SGMCYCR_tmp[i];
    }
    for(uint i = 0; i < emNUM_SGTSEL; i++) {
        mFactorIndexSGTSEL[i] = FactorIndex_SGTSEL_tmp[i];
    }

    CommandInit();
    TSNVCR     = new vpcl::re_register(0x00F0, this, "TSNVCR"    , name.c_str());
    PWDVCR     = new vpcl::re_register(0x00F4, this, "PWDVCR"    , name.c_str());
    PWDTSNDR   = new vpcl::re_register(0x0178, this, "PWDTSNDR"  , name.c_str());
    TSNDIR     = new vpcl::re_register(0x02F0, this, "TSNDIR"    , name.c_str());
    PWDDIR     = new vpcl::re_register(0x02F4, this, "PWDDIR"    , name.c_str());
    ADHALTR    = new vpcl::re_register(0x0300, this, "ADHALTR"   , name.c_str());
    ADCR       = new vpcl::re_register(0x0304, this, "ADCR"      , name.c_str());
    SGSTR      = new vpcl::re_register(0x0308, this, "SGSTR"     , name.c_str());
    MPXCURR    = new vpcl::re_register(0x030C, this, "MPXCURR"   , name.c_str());
    TSNCR      = new vpcl::re_register(0x0310, this, "TSNCR"     , name.c_str());
    THSMPSTCR  = new vpcl::re_register(0x0314, this, "THSMPSTCR" , name.c_str());
    THCR       = new vpcl::re_register(0x0318, this, "THCR"      , name.c_str());
    THAHLDSTCR = new vpcl::re_register(0x031C, this, "THAHLDSTCR", name.c_str());
    THBHLDSTCR = new vpcl::re_register(0x0320, this, "THBHLDSTCR", name.c_str());
    THACR      = new vpcl::re_register(0x0324, this, "THACR"     , name.c_str());
    THBCR      = new vpcl::re_register(0x0328, this, "THBCR"     , name.c_str());
    THER       = new vpcl::re_register(0x032C, this, "THER"      , name.c_str());
    THGSR      = new vpcl::re_register(0x0330, this, "THGSR"     , name.c_str());
    SFTCR      = new vpcl::re_register(0x0334, this, "SFTCR"     , name.c_str());
    ECR        = new vpcl::re_register(0x0344, this, "ECR"       , name.c_str());
    ULER       = new vpcl::re_register(0x0348, this, "ULER"      , name.c_str());
    OWER       = new vpcl::re_register(0x034C, this, "OWER"      , name.c_str());
    DGCTL0     = new vpcl::re_register(0x0350, this, "DGCTL0"    , name.c_str());
    DGCTL1     = new vpcl::re_register(0x0354, this, "DGCTL1"    , name.c_str());
    PDCTL1     = new vpcl::re_register(0x0358, this, "PDCTL1"    , name.c_str());
    PDCTL2     = new vpcl::re_register(0x035C, this, "PDCTL2"    , name.c_str());
    SMPCR      = new vpcl::re_register(0x0380, this, "SMPCR"     , name.c_str());
    TSNSMPCR   = new vpcl::re_register(0x0384, this, "TSNSMPCR"  , name.c_str());
    EMUCR      = new vpcl::re_register(0x0388, this, "EMUCR"     , name.c_str());
    SGPRCR     = new vpcl::re_register(0x038C, this, "SGPRCR"    , name.c_str());
    TRMCR      = new vpcl::re_register(0x03C0, this, "TRMCR"     , name.c_str());
    ADTSTRA    = new vpcl::re_register(0x03C4, this, "ADTSTRA"   , name.c_str());
    ADTSTRB    = new vpcl::re_register(0x03C8, this, "ADTSTRB"   , name.c_str());
    ADTSTRC    = new vpcl::re_register(0x03CC, this, "ADTSTRC"   , name.c_str());
    TSNSGSTCR  = new vpcl::re_register(0x0400, this, "TSNSGSTCR" , name.c_str());
    PWDSGSTCR  = new vpcl::re_register(0x0500, this, "PWDSGSTCR" , name.c_str());
    TSNSGCR    = new vpcl::re_register(0x0408, this, "TSNSGCR"   , name.c_str());
    PWDSGCR    = new vpcl::re_register(0x0508, this, "PWDSGCR"   , name.c_str());
    TSNSGSEFCR = new vpcl::re_register(0x0418, this, "TSNSGSEFCR", name.c_str());
    PWDSGSEFCR = new vpcl::re_register(0x0518, this, "PWDSGSEFCR", name.c_str());
    std::ostringstream str_tmp;
    for(uint i = 0; i < emNUM_VCR; i++) {
        str_tmp.str("");
        // Modified by SonTran: Update register name follow HWM
        if (i < 10) { 
            str_tmp<<"VCR0"<< i;
        }else{
            str_tmp<<"VCR"<< i;
        }
        VCR       [i] = new vpcl::re_register((0x0000) + 4*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_DR; i++) {
        str_tmp.str("");
        // Modified by SonTran: Update register name follow HWM
        if (i*2 < 10) { 
            str_tmp<<"DR0"<< i*2;
        }else{
            str_tmp<<"DR"<< i*2;
        }
        DR        [i] = new vpcl::re_register((0x0100) + 4*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_DIR; i++) {
        str_tmp.str("");
        // Modified by SonTran: Update register name follow HWM
        if (i < 10) { 
            str_tmp<<"DIR0"<< i;
        }else{
            str_tmp<<"DIR"<< i;
        }
        DIR       [i] = new vpcl::re_register((0x0200) + 4*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_ULLMTBR; i++) {
        str_tmp.str("");
        str_tmp<<"ULLMTBR"<< i;
        ULLMTBR   [i] = new vpcl::re_register((0x0338) + 4*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_SGSTCR; i++) {
        str_tmp.str("");
        str_tmp<<"SGSTCR"<< mFactorIndexSGSTCR[i];
        SGSTCR    [mFactorIndexSGSTCR[i]] = new vpcl::re_register((0x0440) + 64*(mFactorIndexSGSTCR[i]-1), this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_SGCR; i++) {
        str_tmp.str("");
        str_tmp<<"SGCR"<< mFactorIndexSGCR[i];
        SGCR      [mFactorIndexSGCR[i]] = new vpcl::re_register((0x0448) + 64*(mFactorIndexSGCR[i]-1), this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_SGSEFCR; i++) {
        str_tmp.str("");
        str_tmp<<"SGSEFCR"<< mFactorIndexSGSEFCR[i];
        SGSEFCR   [mFactorIndexSGSEFCR[i]] = new vpcl::re_register((0x0458) + 64*(mFactorIndexSGSEFCR[i]-1), this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_SGVCSP; i++) {
        str_tmp.str("");
        str_tmp<<"SGVCSP"<< mFactorIndexSGVCSP[i];
        SGVCSP    [mFactorIndexSGVCSP[i]] = new vpcl::re_register((0x044C) + 64*(mFactorIndexSGVCSP[i]-1), this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_SGVCEP; i++) {
        str_tmp.str("");
        str_tmp<<"SGVCEP"<< mFactorIndexSGVCEP[i];
        SGVCEP    [mFactorIndexSGVCEP[i]] = new vpcl::re_register((0x0450) + 64*(mFactorIndexSGVCEP[i]-1), this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_SGMCYCR; i++) {
        str_tmp.str("");
        str_tmp<<"SGMCYCR"<< mFactorIndexSGMCYCR[i];
        SGMCYCR   [mFactorIndexSGMCYCR[i]] = new vpcl::re_register((0x0454) + 64*(mFactorIndexSGMCYCR[i]-1), this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_SGTSEL; i++) {
        str_tmp.str("");
        str_tmp<<"SGTSEL"<< mFactorIndexSGTSEL[i];
        SGTSEL    [mFactorIndexSGTSEL[i]] = new vpcl::re_register((0x045C) + 64*(mFactorIndexSGTSEL[i]-1), this, str_tmp.str(), name.c_str());
    }

    // Construct the register pointer list
    mCurReg = NULL;

    uint index = 0;
    mRegMap = new uint [1<<11];
    for (uint i = 0; i < (1<<11); i++) {
        mRegMap[i] = (1<<11);
    }

    for(uint i = 0; i < emNUM_VCR;       i++) {
        mRegMap[(0x0000)     + i*4 ] = index;
        mRegMap[(0x0000 + 1) + i*4 ] = index;
        mRegMap[(0x0000 + 2) + i*4 ] = index;
        mRegMap[(0x0000 + 3) + i*4 ] = index++;
    }
    mRegMap[0x00F0]     = index;
    mRegMap[0x00F0 + 1] = index;
    mRegMap[0x00F0 + 2] = index;
    mRegMap[0x00F0 + 3] = index++;
    mRegMap[0x00F4]     = index;
    mRegMap[0x00F4 + 1] = index;
    mRegMap[0x00F4 + 2] = index;
    mRegMap[0x00F4 + 3] = index++;
    for(uint i = 0; i < emNUM_DR;        i++) {
        mRegMap[(0x0100)     + i*4 ] = index;
        mRegMap[(0x0100 + 1) + i*4 ] = index;
        mRegMap[(0x0100 + 2) + i*4 ] = index;
        mRegMap[(0x0100 + 3) + i*4 ] = index++;
    }
    mRegMap[0x0178]     = index;
    mRegMap[0x0178 + 1] = index;
    mRegMap[0x0178 + 2] = index;
    mRegMap[0x0178 + 3] = index++;
    for(uint i = 0; i < emNUM_DIR;       i++) {
        mRegMap[(0x0200)     + i*4 ] = index;
        mRegMap[(0x0200 + 1) + i*4 ] = index;
        mRegMap[(0x0200 + 2) + i*4 ] = index;
        mRegMap[(0x0200 + 3) + i*4 ] = index++;
    }
    mRegMap[0x02F0]     = index;
    mRegMap[0x02F0 + 1] = index;
    mRegMap[0x02F0 + 2] = index;
    mRegMap[0x02F0 + 3] = index++;
    mRegMap[0x02F4]     = index;
    mRegMap[0x02F4 + 1] = index;
    mRegMap[0x02F4 + 2] = index;
    mRegMap[0x02F4 + 3] = index++;
    mRegMap[0x0300]     = index;
    mRegMap[0x0300 + 1] = index;
    mRegMap[0x0300 + 2] = index;
    mRegMap[0x0300 + 3] = index++;
    mRegMap[0x0304]     = index;
    mRegMap[0x0304 + 1] = index;
    mRegMap[0x0304 + 2] = index;
    mRegMap[0x0304 + 3] = index++;
    mRegMap[0x0308]     = index;
    mRegMap[0x0308 + 1] = index;
    mRegMap[0x0308 + 2] = index;
    mRegMap[0x0308 + 3] = index++;
    mRegMap[0x030C]     = index;
    mRegMap[0x030C + 1] = index;
    mRegMap[0x030C + 2] = index;
    mRegMap[0x030C + 3] = index++;
    mRegMap[0x0310]     = index;
    mRegMap[0x0310 + 1] = index;
    mRegMap[0x0310 + 2] = index;
    mRegMap[0x0310 + 3] = index++;
    mRegMap[0x0314]     = index;
    mRegMap[0x0314 + 1] = index;
    mRegMap[0x0314 + 2] = index;
    mRegMap[0x0314 + 3] = index++;
    mRegMap[0x0318]     = index;
    mRegMap[0x0318 + 1] = index;
    mRegMap[0x0318 + 2] = index;
    mRegMap[0x0318 + 3] = index++;
    mRegMap[0x031C]     = index;
    mRegMap[0x031C + 1] = index;
    mRegMap[0x031C + 2] = index;
    mRegMap[0x031C + 3] = index++;
    mRegMap[0x0320]     = index;
    mRegMap[0x0320 + 1] = index;
    mRegMap[0x0320 + 2] = index;
    mRegMap[0x0320 + 3] = index++;
    mRegMap[0x0324]     = index;
    mRegMap[0x0324 + 1] = index;
    mRegMap[0x0324 + 2] = index;
    mRegMap[0x0324 + 3] = index++;
    mRegMap[0x0328]     = index;
    mRegMap[0x0328 + 1] = index;
    mRegMap[0x0328 + 2] = index;
    mRegMap[0x0328 + 3] = index++;
    mRegMap[0x032C]     = index;
    mRegMap[0x032C + 1] = index;
    mRegMap[0x032C + 2] = index;
    mRegMap[0x032C + 3] = index++;
    mRegMap[0x0330]     = index;
    mRegMap[0x0330 + 1] = index;
    mRegMap[0x0330 + 2] = index;
    mRegMap[0x0330 + 3] = index++;
    mRegMap[0x0334]     = index;
    mRegMap[0x0334 + 1] = index;
    mRegMap[0x0334 + 2] = index;
    mRegMap[0x0334 + 3] = index++;
    for(uint i = 0; i < emNUM_ULLMTBR;   i++) {
        mRegMap[(0x0338)     + i*4 ] = index;
        mRegMap[(0x0338 + 1) + i*4 ] = index;
        mRegMap[(0x0338 + 2) + i*4 ] = index;
        mRegMap[(0x0338 + 3) + i*4 ] = index++;
    }
    mRegMap[0x0344]     = index;
    mRegMap[0x0344 + 1] = index;
    mRegMap[0x0344 + 2] = index;
    mRegMap[0x0344 + 3] = index++;
    mRegMap[0x0348]     = index;
    mRegMap[0x0348 + 1] = index;
    mRegMap[0x0348 + 2] = index;
    mRegMap[0x0348 + 3] = index++;
    mRegMap[0x034C]     = index;
    mRegMap[0x034C + 1] = index;
    mRegMap[0x034C + 2] = index;
    mRegMap[0x034C + 3] = index++;
    mRegMap[0x0350]     = index;
    mRegMap[0x0350 + 1] = index;
    mRegMap[0x0350 + 2] = index;
    mRegMap[0x0350 + 3] = index++;
    mRegMap[0x0354]     = index;
    mRegMap[0x0354 + 1] = index;
    mRegMap[0x0354 + 2] = index;
    mRegMap[0x0354 + 3] = index++;
    mRegMap[0x0358]     = index;
    mRegMap[0x0358 + 1] = index;
    mRegMap[0x0358 + 2] = index;
    mRegMap[0x0358 + 3] = index++;
    mRegMap[0x035C]     = index;
    mRegMap[0x035C + 1] = index;
    mRegMap[0x035C + 2] = index;
    mRegMap[0x035C + 3] = index++;
    mRegMap[0x0380]     = index;
    mRegMap[0x0380 + 1] = index;
    mRegMap[0x0380 + 2] = index;
    mRegMap[0x0380 + 3] = index++;
    mRegMap[0x0384]     = index;
    mRegMap[0x0384 + 1] = index;
    mRegMap[0x0384 + 2] = index;
    mRegMap[0x0384 + 3] = index++;
    mRegMap[0x0388]     = index;
    mRegMap[0x0388 + 1] = index;
    mRegMap[0x0388 + 2] = index;
    mRegMap[0x0388 + 3] = index++;
    mRegMap[0x038C]     = index;
    mRegMap[0x038C + 1] = index;
    mRegMap[0x038C + 2] = index;
    mRegMap[0x038C + 3] = index++;
    mRegMap[0x03C0]     = index;
    mRegMap[0x03C0 + 1] = index;
    mRegMap[0x03C0 + 2] = index;
    mRegMap[0x03C0 + 3] = index++;
    mRegMap[0x03C4]     = index;
    mRegMap[0x03C4 + 1] = index;
    mRegMap[0x03C4 + 2] = index;
    mRegMap[0x03C4 + 3] = index++;
    mRegMap[0x03C8]     = index;
    mRegMap[0x03C8 + 1] = index;
    mRegMap[0x03C8 + 2] = index;
    mRegMap[0x03C8 + 3] = index++;
    mRegMap[0x03CC]     = index;
    mRegMap[0x03CC + 1] = index;
    mRegMap[0x03CC + 2] = index;
    mRegMap[0x03CC + 3] = index++;
    mRegMap[0x0400]     = index;
    mRegMap[0x0400 + 1] = index;
    mRegMap[0x0400 + 2] = index;
    mRegMap[0x0400 + 3] = index++;
    mRegMap[0x0408]     = index;
    mRegMap[0x0408 + 1] = index;
    mRegMap[0x0408 + 2] = index;
    mRegMap[0x0408 + 3] = index++;
    mRegMap[0x0418]     = index;
    mRegMap[0x0418 + 1] = index;
    mRegMap[0x0418 + 2] = index;
    mRegMap[0x0418 + 3] = index++;
    for(uint i = 0; i < emNUM_SGSTCR;    i++) {
        mRegMap[(0x0440)     + (mFactorIndexSGSTCR[i]-1)*64] = index;
        mRegMap[(0x0440 + 1) + (mFactorIndexSGSTCR[i]-1)*64] = index;
        mRegMap[(0x0440 + 2) + (mFactorIndexSGSTCR[i]-1)*64] = index;
        mRegMap[(0x0440 + 3) + (mFactorIndexSGSTCR[i]-1)*64] = index++;
    }
    for(uint i = 0; i < emNUM_SGCR;      i++) {
        mRegMap[(0x0448)     + (mFactorIndexSGCR[i]-1)*64] = index;
        mRegMap[(0x0448 + 1) + (mFactorIndexSGCR[i]-1)*64] = index;
        mRegMap[(0x0448 + 2) + (mFactorIndexSGCR[i]-1)*64] = index;
        mRegMap[(0x0448 + 3) + (mFactorIndexSGCR[i]-1)*64] = index++;
    }
    for(uint i = 0; i < emNUM_SGVCSP;    i++) {
        mRegMap[(0x044C)     + (mFactorIndexSGVCSP[i]-1)*64] = index;
        mRegMap[(0x044C + 1) + (mFactorIndexSGVCSP[i]-1)*64] = index;
        mRegMap[(0x044C + 2) + (mFactorIndexSGVCSP[i]-1)*64] = index;
        mRegMap[(0x044C + 3) + (mFactorIndexSGVCSP[i]-1)*64] = index++;
    }
    for(uint i = 0; i < emNUM_SGVCEP;    i++) {
        mRegMap[(0x0450)     + (mFactorIndexSGVCEP[i]-1)*64] = index;
        mRegMap[(0x0450 + 1) + (mFactorIndexSGVCEP[i]-1)*64] = index;
        mRegMap[(0x0450 + 2) + (mFactorIndexSGVCEP[i]-1)*64] = index;
        mRegMap[(0x0450 + 3) + (mFactorIndexSGVCEP[i]-1)*64] = index++;
    }
    for(uint i = 0; i < emNUM_SGMCYCR;   i++) {
        mRegMap[(0x0454)     + (mFactorIndexSGMCYCR[i]-1)*64] = index;
        mRegMap[(0x0454 + 1) + (mFactorIndexSGMCYCR[i]-1)*64] = index;
        mRegMap[(0x0454 + 2) + (mFactorIndexSGMCYCR[i]-1)*64] = index;
        mRegMap[(0x0454 + 3) + (mFactorIndexSGMCYCR[i]-1)*64] = index++;
    }
    for(uint i = 0; i < emNUM_SGSEFCR;   i++) {
        mRegMap[(0x0458)     + (mFactorIndexSGSEFCR[i]-1)*64] = index;
        mRegMap[(0x0458 + 1) + (mFactorIndexSGSEFCR[i]-1)*64] = index;
        mRegMap[(0x0458 + 2) + (mFactorIndexSGSEFCR[i]-1)*64] = index;
        mRegMap[(0x0458 + 3) + (mFactorIndexSGSEFCR[i]-1)*64] = index++;
    }
    for(uint i = 0; i < emNUM_SGTSEL;    i++) {
        mRegMap[(0x045C)     + (mFactorIndexSGTSEL[i]-1)*64] = index;
        mRegMap[(0x045C + 1) + (mFactorIndexSGTSEL[i]-1)*64] = index;
        mRegMap[(0x045C + 2) + (mFactorIndexSGTSEL[i]-1)*64] = index;
        mRegMap[(0x045C + 3) + (mFactorIndexSGTSEL[i]-1)*64] = index++;
    }
    mRegMap[0x0500]     = index;
    mRegMap[0x0500 + 1] = index;
    mRegMap[0x0500 + 2] = index;
    mRegMap[0x0500 + 3] = index++;
    mRegMap[0x0508]     = index;
    mRegMap[0x0508 + 1] = index;
    mRegMap[0x0508 + 2] = index;
    mRegMap[0x0508 + 3] = index++;
    mRegMap[0x0518]     = index;
    mRegMap[0x0518 + 1] = index;
    mRegMap[0x0518 + 2] = index;
    mRegMap[0x0518 + 3] = index++;
    mTotalRegNum = index;
    mRegArray = new SRegList* [mTotalRegNum];
    index = 0;
#ifdef CWR_SYSTEMC
    for(uint i = 0; i < emNUM_VCR       ; i++) mCurReg = mRegArray[index++] = new SRegList(VCR         [i], mCurReg, i,  4, "8|16|32", "8|16|32", false, &cwmem);
#else
    for(uint i = 0; i < emNUM_VCR       ; i++) mCurReg = mRegArray[index++] = new SRegList(VCR         [i], mCurReg, i,  4, "8|16|32", "8|16|32");
#endif
    mCurReg = mRegArray[index++] = new SRegList(TSNVCR      , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(PWDVCR      , mCurReg, 0,  4, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_DR        ; i++) mCurReg = mRegArray[index++] = new SRegList(DR          [i], mCurReg, i,  4,   "16|32",   "16|32");
    mCurReg = mRegArray[index++] = new SRegList(PWDTSNDR    , mCurReg, 0,  4,   "16|32",   "16|32");
    for(uint i = 0; i < emNUM_DIR       ; i++) mCurReg = mRegArray[index++] = new SRegList(DIR         [i], mCurReg, i,  4,      "32",      "32");
    mCurReg = mRegArray[index++] = new SRegList(TSNDIR      , mCurReg, 0,  4,      "32",      "32");
    mCurReg = mRegArray[index++] = new SRegList(PWDDIR      , mCurReg, 0,  4,      "32",      "32");
    mCurReg = mRegArray[index++] = new SRegList(ADHALTR     , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(ADCR        , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(SGSTR       , mCurReg, 0,  4,   "16|32",   "16|32");
    mCurReg = mRegArray[index++] = new SRegList(MPXCURR     , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TSNCR       , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(THSMPSTCR   , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(THCR        , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(THAHLDSTCR  , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(THBHLDSTCR  , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(THACR       , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(THBCR       , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(THER        , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(THGSR       , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(SFTCR       , mCurReg, 0,  4, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_ULLMTBR   ; i++) mCurReg = mRegArray[index++] = new SRegList(ULLMTBR     [i], mCurReg, i,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(ECR         , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(ULER        , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(OWER        , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(DGCTL0      , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(DGCTL1      , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(PDCTL1      , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(PDCTL2      , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(SMPCR       , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TSNSMPCR    , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(EMUCR       , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(SGPRCR      , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TRMCR       , mCurReg, 0,  4,      "32",      "32");
    mCurReg = mRegArray[index++] = new SRegList(ADTSTRA     , mCurReg, 0,  4,      "32",      "32");
    mCurReg = mRegArray[index++] = new SRegList(ADTSTRB     , mCurReg, 0,  4,      "32",      "32");
    mCurReg = mRegArray[index++] = new SRegList(ADTSTRC     , mCurReg, 0,  4,      "32",      "32");
    mCurReg = mRegArray[index++] = new SRegList(TSNSGSTCR   , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TSNSGCR     , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TSNSGSEFCR  , mCurReg, 0,  4, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_SGSTCR    ; i++) mCurReg = mRegArray[index++] = new SRegList(SGSTCR      [mFactorIndexSGSTCR    [i]], mCurReg, mFactorIndexSGSTCR    [i],  4, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_SGCR      ; i++) mCurReg = mRegArray[index++] = new SRegList(SGCR        [mFactorIndexSGCR      [i]], mCurReg, mFactorIndexSGCR      [i],  4, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_SGVCSP    ; i++) mCurReg = mRegArray[index++] = new SRegList(SGVCSP      [mFactorIndexSGVCSP    [i]], mCurReg, mFactorIndexSGVCSP    [i],  4, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_SGVCEP    ; i++) mCurReg = mRegArray[index++] = new SRegList(SGVCEP      [mFactorIndexSGVCEP    [i]], mCurReg, mFactorIndexSGVCEP    [i],  4, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_SGMCYCR   ; i++) mCurReg = mRegArray[index++] = new SRegList(SGMCYCR     [mFactorIndexSGMCYCR   [i]], mCurReg, mFactorIndexSGMCYCR   [i],  4, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_SGSEFCR   ; i++) mCurReg = mRegArray[index++] = new SRegList(SGSEFCR     [mFactorIndexSGSEFCR   [i]], mCurReg, mFactorIndexSGSEFCR   [i],  4, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_SGTSEL    ; i++) mCurReg = mRegArray[index++] = new SRegList(SGTSEL      [mFactorIndexSGTSEL    [i]], mCurReg, mFactorIndexSGTSEL    [i],  4,   "16|32",   "16|32");
    mCurReg = mRegArray[index++] = new SRegList(PWDSGSTCR   , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(PWDSGCR     , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(PWDSGSEFCR  , mCurReg, 0,  4, "8|16|32", "8|16|32");

    mRegList = mCurReg;

    (*TSNVCR      ) ( 7,  6, "ULS"     , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TSNVCR      ) ( 5,  0, "TSNGCTRL", 0x25      , "R"     , vpcl::SPP_ENABLE);
    (*PWDVCR      ) (15, 15, "MPXE"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*PWDVCR      ) (14, 12, "MPXV"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*PWDVCR      ) ( 7,  6, "ULS"     , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*PWDVCR      ) ( 5,  0, "GCTRL"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*PWDTSNDR    ) (31, 16, "PWDDR"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*PWDTSNDR    ) (15,  0, "TSNDR"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TSNDIR      ) (25, 25, "WFLG"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TSNDIR      ) (21, 16, "ID"      , 0x25      , "R"     , vpcl::SPP_ENABLE);
    (*TSNDIR      ) (15,  0, "TSNDR"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*PWDDIR      ) (31, 31, "MPXE"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*PWDDIR      ) (30, 28, "MPXV"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*PWDDIR      ) (25, 25, "WFLG"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*PWDDIR      ) (21, 16, "ID"      , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*PWDDIR      ) (15,  0, "PWDDR"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*ADHALTR     ) ( 0,  0, "HALT"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*ADCR        ) ( 7,  7, "DGON"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*ADCR        ) ( 6,  6, "TSNSELFDIAG", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*ADCR        ) ( 5,  5, "CRAC"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*ADCR        ) ( 4,  4, "CTYP"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*ADCR        ) ( 1,  0, "SUSMTD"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE, "b00,b01,b10");
    (*SGSTR       ) (14, 14, "SHACT"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*SGSTR       ) (13,  8, "SGACT"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*SGSTR       ) ( 4,  0, "SEF"     , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*MPXCURR     ) ( 2,  0, "MPXCUR"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TSNCR       ) ( 0,  0, "TSNEN"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*THSMPSTCR   ) ( 0,  0, "SMPST"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*THCR        ) ( 0,  0, "ASMPMSK" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*THAHLDSTCR  ) ( 0,  0, "HLDST"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*THBHLDSTCR  ) ( 0,  0, "HLDST"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*THACR       ) ( 5,  5, "HLDCTE"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*THACR       ) ( 4,  4, "HLDTE"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*THACR       ) ( 1,  0, "SGS"     , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*THBCR       ) ( 5,  5, "HLDCTE"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*THBCR       ) ( 4,  4, "HLDTE"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*THBCR       ) ( 1,  0, "SGS"     , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*THER        ) ( 5,  5, "TH5E"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*THER        ) ( 4,  4, "TH4E"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*THER        ) ( 3,  3, "TH3E"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*THER        ) ( 2,  2, "TH2E"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*THER        ) ( 1,  1, "TH1E"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*THER        ) ( 0,  0, "TH0E"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*THGSR       ) ( 5,  5, "TH5GS"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*THGSR       ) ( 4,  4, "TH4GS"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*THGSR       ) ( 3,  3, "TH3GS"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*THGSR       ) ( 2,  2, "TH2GS"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*THGSR       ) ( 1,  1, "TH1GS"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*THGSR       ) ( 0,  0, "TH0GS"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SFTCR       ) ( 4,  4, "RDCLRE"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SFTCR       ) ( 3,  3, "ULEIE"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SFTCR       ) ( 2,  2, "OWEIE"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*ECR         ) ( 3,  3, "ULEC"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*ECR         ) ( 2,  2, "OWEC"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*ULER        ) (15, 15, "UE"      , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*ULER        ) (14, 14, "LE"      , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*ULER        ) (13, 12, "ULSG"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*ULER        ) (11, 11, "MPXE"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*ULER        ) (10,  8, "MPXV"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*ULER        ) ( 7,  7, "ULE"     , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*ULER        ) ( 5,  0, "ULECAP"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*OWER        ) ( 7,  7, "OWE"     , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*OWER        ) ( 5,  0, "OWECAP"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*DGCTL0      ) ( 2,  2, "PSEL2"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*DGCTL0      ) ( 1,  1, "PSEL1"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*DGCTL0      ) ( 0,  0, "PSEL0"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*DGCTL1      ) (15, 15, "CDG15"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*DGCTL1      ) (14, 14, "CDG14"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*DGCTL1      ) (13, 13, "CDG13"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*DGCTL1      ) (12, 12, "CDG12"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*DGCTL1      ) (11, 11, "CDG11"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*DGCTL1      ) (10, 10, "CDG10"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*DGCTL1      ) ( 9,  9, "CDG09"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*DGCTL1      ) ( 8,  8, "CDG08"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*DGCTL1      ) ( 7,  7, "CDG07"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*DGCTL1      ) ( 6,  6, "CDG06"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*DGCTL1      ) ( 5,  5, "CDG05"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*DGCTL1      ) ( 4,  4, "CDG04"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*DGCTL1      ) ( 3,  3, "CDG03"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*DGCTL1      ) ( 2,  2, "CDG02"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*DGCTL1      ) ( 1,  1, "CDG01"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*DGCTL1      ) ( 0,  0, "CDG00"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL1      ) (15, 15, "PDNA15"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL1      ) (14, 14, "PDNA14"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL1      ) (13, 13, "PDNA13"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL1      ) (12, 12, "PDNA12"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL1      ) (11, 11, "PDNA11"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL1      ) (10, 10, "PDNA10"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL1      ) ( 9,  9, "PDNA09"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL1      ) ( 8,  8, "PDNA08"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL1      ) ( 7,  7, "PDNA07"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL1      ) ( 6,  6, "PDNA06"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL1      ) ( 5,  5, "PDNA05"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL1      ) ( 4,  4, "PDNA04"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL1      ) ( 3,  3, "PDNA03"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL1      ) ( 2,  2, "PDNA02"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL1      ) ( 1,  1, "PDNA01"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL1      ) ( 0,  0, "PDNA00"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL2      ) (19, 19, "PDNB19"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL2      ) (18, 18, "PDNB18"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL2      ) (17, 17, "PDNB17"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL2      ) (16, 16, "PDNB16"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL2      ) (15, 15, "PDNB15"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL2      ) (14, 14, "PDNB14"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL2      ) (13, 13, "PDNB13"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL2      ) (12, 12, "PDNB12"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL2      ) (11, 11, "PDNB11"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL2      ) (10, 10, "PDNB10"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL2      ) ( 9,  9, "PDNB09"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL2      ) ( 8,  8, "PDNB08"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL2      ) ( 7,  7, "PDNB07"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL2      ) ( 6,  6, "PDNB06"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL2      ) ( 5,  5, "PDNB05"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL2      ) ( 4,  4, "PDNB04"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL2      ) ( 3,  3, "PDNB03"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL2      ) ( 2,  2, "PDNB02"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL2      ) ( 1,  1, "PDNB01"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PDCTL2      ) ( 0,  0, "PDNB00"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SMPCR       ) ( 7,  0, "SMPT"    , 0x18      , "W|R"   , vpcl::SPP_ENABLE);
    (*TSNSMPCR    ) ( 7,  0, "TSNSMPT" , 0xF0      , "W|R"   , vpcl::SPP_ENABLE);
    (*EMUCR       ) ( 7,  7, "SVSDIS"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGPRCR      ) (18, 16, "SGPR4"   , 0x4       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGPRCR      ) (14, 12, "SGPR3"   , 0x3       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGPRCR      ) (10,  8, "SGPR2"   , 0x2       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGPRCR      ) ( 6,  4, "SGPR1"   , 0x1       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGPRCR      ) ( 2,  0, "SGPR0"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TRMCR       ) (31, 31, "TRMS"    , 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*TRMCR       ) (27, 27, "TRMDGSTBY", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*TRMCR       ) (15, 14, "TRMTSNTUNE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*TRMCR       ) (13, 12, "TRMTTUNE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*TRMCR       ) (11, 10, "TRMBTUNE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*TRMCR       ) ( 9,  8, "TRMATUNE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*TRMCR       ) ( 7,  6, "TRMTSN"  , 0x0       , "R"     , vpcl::SPP_DISABLE);
    (*TRMCR       ) ( 5,  4, "TRMT"    , 0x0       , "R"     , vpcl::SPP_DISABLE);
    (*TRMCR       ) ( 3,  2, "TRMB"    , 0x0       , "R"     , vpcl::SPP_DISABLE);
    (*TRMCR       ) ( 1,  0, "TRMA"    , 0x0       , "R"     , vpcl::SPP_DISABLE);
    (*ADTSTRA     ) ( 7,  0, "ADTST"   , 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*ADTSTRB     ) (13,  0, "ADVAL"   , 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*ADTSTRC     ) (13, 13, "CKSTP"   , 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*ADTSTRC     ) (12, 12, "SYNCERR" , 0x0       , "R"     , vpcl::SPP_DISABLE);
    (*ADTSTRC     ) ( 8,  8, "ADMD8"   , 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*ADTSTRC     ) ( 7,  7, "ADMD7"   , 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*ADTSTRC     ) ( 6,  6, "ADMD6"   , 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*ADTSTRC     ) ( 5,  5, "ADMD5"   , 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*ADTSTRC     ) ( 4,  4, "ADMD4"   , 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*ADTSTRC     ) ( 3,  3, "ADMD3"   , 0x0       , "R"     , vpcl::SPP_DISABLE);
    (*ADTSTRC     ) ( 2,  0, "ADMD"    , 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*TSNSGSTCR   ) ( 0,  0, "TSNSGST" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PWDSGSTCR   ) ( 0,  0, "PWDSGST" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TSNSGCR     ) ( 0,  0, "TSNTRGMD", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PWDSGCR     ) ( 0,  0, "PWDTRGMD", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TSNSGSEFCR  ) ( 0,  0, "TSNSEFC" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PWDSGSEFCR  ) ( 0,  0, "PWDSEFC" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    for(uint i = 0; i < emNUM_SGTSEL; i++) {
        (*SGTSEL      [mFactorIndexSGTSEL[i]]) (15, 15, "TxSEL15" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*SGTSEL      [mFactorIndexSGTSEL[i]]) (14, 14, "TxSEL14" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*SGTSEL      [mFactorIndexSGTSEL[i]]) (13, 13, "TxSEL13" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*SGTSEL      [mFactorIndexSGTSEL[i]]) (12, 12, "TxSEL12" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*SGTSEL      [mFactorIndexSGTSEL[i]]) (11, 11, "TxSEL11" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*SGTSEL      [mFactorIndexSGTSEL[i]]) (10, 10, "TxSEL10" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*SGTSEL      [mFactorIndexSGTSEL[i]]) ( 9,  9, "TxSEL09" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*SGTSEL      [mFactorIndexSGTSEL[i]]) ( 8,  8, "TxSEL08" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*SGTSEL      [mFactorIndexSGTSEL[i]]) ( 7,  7, "TxSEL07" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*SGTSEL      [mFactorIndexSGTSEL[i]]) ( 6,  6, "TxSEL06" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*SGTSEL      [mFactorIndexSGTSEL[i]]) ( 5,  5, "TxSEL05" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*SGTSEL      [mFactorIndexSGTSEL[i]]) ( 4,  4, "TxSEL04" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*SGTSEL      [mFactorIndexSGTSEL[i]]) ( 3,  3, "TxSEL03" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*SGTSEL      [mFactorIndexSGTSEL[i]]) ( 2,  2, "TxSEL02" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*SGTSEL      [mFactorIndexSGTSEL[i]]) ( 1,  1, "TxSEL01" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*SGTSEL      [mFactorIndexSGTSEL[i]]) ( 0,  0, "TxSEL00" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_SGVCSP; i++) {
        (*SGVCSP      [mFactorIndexSGVCSP[i]]) ( 5,  0, "VCSP"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_SGVCEP; i++) {
        (*SGVCEP      [mFactorIndexSGVCEP[i]]) ( 5,  0, "VCEP"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_SGSEFCR; i++) {
        (*SGSEFCR     [mFactorIndexSGSEFCR[i]]) ( 0,  0, "SEFCn"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_VCR; i++) {
        (*VCR         [i]) (15, 15, "MPXE"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*VCR         [i]) (14, 12, "MPXV"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        if ((i >=33)&&(i<=35)){ // Modified by SonTran: VCR.CNVCLS only available on VCR33, VCR34, VCR35
            (*VCR         [i]) ( 9,  9, "CNVCLS"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        }
        (*VCR         [i]) ( 7,  6, "ULS"     , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*VCR         [i]) ( 8,  8, "ADIE"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*VCR         [i]) ( 5,  0, "GCTRL"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_SGMCYCR; i++) {
        (*SGMCYCR     [mFactorIndexSGMCYCR[i]]) ( 7,  0, "MCYC"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_DIR; i++) {
        (*DIR         [i]) (31, 31, "MPXE"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
        (*DIR         [i]) (30, 28, "MPXV"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
        (*DIR         [i]) (25, 25, "WFLG"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
        (*DIR         [i]) (21, 16, "ID"      , 0x0       , "R"     , vpcl::SPP_ENABLE);
        str_tmp.str("");
        // Modified by SonTran: Update register name follow HWM
        if (i < 10) { 
            str_tmp<<"DR0"<< i;
        }else{
            str_tmp<<"DR"<< i;
        }
        (*DIR         [i]) (15,  0, str_tmp.str()      , 0x0       , "R"     , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_ULLMTBR; i++) {
        (*ULLMTBR     [i]) (31, 20, "ULMTB"   , 0xFFF     , "W|R"   , vpcl::SPP_ENABLE);
        (*ULLMTBR     [i]) (15,  4, "LLMTB"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_DR; i++) {
        // Modified by SonTran: Update bit name follow HWM
        str_tmp.str("");
        if (i*2 < 10) { 
            str_tmp<<"DR0"<< i*2+1;
        }else{
            str_tmp<<"DR"<< i*2+1;
        }
        (*DR          [i]) (31, 16, str_tmp.str()     , 0x0       , "R"     , vpcl::SPP_ENABLE);
        str_tmp.str("");
        if (i*2 < 10) { 
            str_tmp<<"DR0"<< i*2;
        }else{
            str_tmp<<"DR"<< i*2;
        }
        (*DR          [i]) (15,  0, str_tmp.str()     , 0x0       , "R"     , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_SGCR; i++) {
        (*SGCR        [mFactorIndexSGCR[i]]) ( 5,  5, "SCANMD"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*SGCR        [mFactorIndexSGCR[i]]) ( 4,  4, "ADIE"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*SGCR        [mFactorIndexSGCR[i]]) ( 3,  2, "SCT"     , 0x0       , "W|R"   , vpcl::SPP_ENABLE, "b00,b01,b10");
        (*SGCR        [mFactorIndexSGCR[i]]) ( 0,  0, "TRGMD"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_SGSTCR; i++) {
        (*SGSTCR      [mFactorIndexSGSTCR[i]]) ( 0,  0, "SGSTn"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    }

    mFileName = "";
    mInstName = name;
    mLineNum = 0;
    mBusWidth = buswidth;
    mBusByteWidth = mBusWidth/8;   // using in BIG ENDIAN
    mIsReset = false;

    // Constructor the callback function of each register
    for (uint i = 0; i < mTotalRegNum; i++) {
        mWrCbAPI[mRegArray[i]->my_p->name()][mRegArray[i]->my_p->name()] = NULL;
        mRdCbAPI[mRegArray[i]->my_p->name()][mRegArray[i]->my_p->name()] = NULL;
    }

    //Constructor the mWrCbAPI, mRdCbAPI variable of each register
    mWrCbAPI["TSNVCR"  ]["ULS"     ] = &Csarad113x_regif::cb_TSNVCR_ULS;
    mWrCbAPI["ADHALTR" ]["HALT"    ] = &Csarad113x_regif::cb_ADHALTR_HALT;
    mWrCbAPI["ADCR"    ]["SUSMTD"  ] = &Csarad113x_regif::cb_ADCR_SUSMTD;
    mWrCbAPI["TSNCR"   ]["TSNEN"   ] = &Csarad113x_regif::cb_TSNCR_TSNEN;
    mWrCbAPI["THSMPSTCR"]["SMPST"   ] = &Csarad113x_regif::cb_THSMPSTCR_SMPST;
    mWrCbAPI["THCR"    ]["ASMPMSK" ] = &Csarad113x_regif::cb_THCR_ASMPMSK;
    mWrCbAPI["THAHLDSTCR"]["HLDST"   ] = &Csarad113x_regif::cb_THAHLDSTCR_HLDST;
    mWrCbAPI["THBHLDSTCR"]["HLDST"   ] = &Csarad113x_regif::cb_THBHLDSTCR_HLDST;
    mWrCbAPI["THACR"   ]["SGS"     ] = &Csarad113x_regif::cb_THACR_SGS;
    mWrCbAPI["THBCR"   ]["SGS"     ] = &Csarad113x_regif::cb_THBCR_SGS;
    mWrCbAPI["THER"    ]["TH0E"    ] = &Csarad113x_regif::cb_THER_TH0E;
    mWrCbAPI["THGSR"   ]["TH0GS"   ] = &Csarad113x_regif::cb_THGSR_TH0GS;
    mWrCbAPI["SFTCR"   ]["OWEIE"   ] = &Csarad113x_regif::cb_SFTCR_OWEIE;
    mWrCbAPI["ECR"     ]["ULEC"    ] = &Csarad113x_regif::cb_ECR_ULEC;
    mWrCbAPI["DGCTL0"  ]["PSEL0"   ] = &Csarad113x_regif::cb_DGCTL0_PSEL0;
    mWrCbAPI["DGCTL1"  ]["CDG00"   ] = &Csarad113x_regif::cb_DGCTL1_CDG00;
    mWrCbAPI["PDCTL1"  ]["PDNA00"  ] = &Csarad113x_regif::cb_PDCTL1_PDNA00;
    mWrCbAPI["PDCTL2"  ]["PDNB00"  ] = &Csarad113x_regif::cb_PDCTL2_PDNB00;
    mWrCbAPI["SMPCR"   ]["SMPT"    ] = &Csarad113x_regif::cb_SMPCR_SMPT;
    mWrCbAPI["TSNSMPCR"]["TSNSMPT" ] = &Csarad113x_regif::cb_TSNSMPCR_TSNSMPT;
    mWrCbAPI["EMUCR"   ]["SVSDIS"  ] = &Csarad113x_regif::cb_EMUCR_SVSDIS;
    mWrCbAPI["SGPRCR"  ]["SGPR0"   ] = &Csarad113x_regif::cb_SGPRCR_SGPR0;
    mWrCbAPI["TSNSGSTCR"]["TSNSGST" ] = &Csarad113x_regif::cb_TSNSGSTCR_TSNSGST;
    mWrCbAPI["PWDSGSTCR"]["PWDSGST" ] = &Csarad113x_regif::cb_PWDSGSTCR_PWDSGST;
    mWrCbAPI["TSNSGCR" ]["TSNTRGMD"] = &Csarad113x_regif::cb_TSNSGCR_TSNTRGMD;
    mWrCbAPI["PWDSGCR" ]["PWDTRGMD"] = &Csarad113x_regif::cb_PWDSGCR_PWDTRGMD;
    mWrCbAPI["TSNSGSEFCR"]["TSNSEFC" ] = &Csarad113x_regif::cb_TSNSGSEFCR_TSNSEFC;
    mWrCbAPI["PWDSGSEFCR"]["PWDSEFC" ] = &Csarad113x_regif::cb_PWDSGSEFCR_PWDSEFC;

    mRdCbAPI["PWDTSNDR"]["TSNDR"   ] = &Csarad113x_regif::cb_PWDTSNDR_TSNDR;
    mRdCbAPI["TSNDIR"  ]["TSNDR"   ] = &Csarad113x_regif::cb_TSNDIR_TSNDR;
    mRdCbAPI["PWDDIR"  ]["PWDDR"   ] = &Csarad113x_regif::cb_PWDDIR_PWDDR;

    for(uint i = 0; i < emNUM_VCR; i++) {
        str_tmp.str("");
        // Modified by SonTran: Update register name follow HWM
        if (i < 10) { 
            str_tmp<<"VCR0"<< i;
        }else{
            str_tmp<<"VCR"<< i;
        }
        mWrCbAPI[str_tmp.str()]["GCTRL"] = &Csarad113x_regif::cb_VCR_GCTRL;
    }
    for(uint i = 0; i < emNUM_DR; i++) {
        str_tmp.str("");
        // Modified by SonTran: Update register name follow HWM
        if (i*2 < 10) { 
            str_tmp<<"DR0"<< i*2;
        }else{
            str_tmp<<"DR"<< i*2;
        }
        mRdCbAPI[str_tmp.str()][str_tmp.str()] = &Csarad113x_regif::cb_DR_DR0;
    }
    for(uint i = 0; i < emNUM_DIR; i++) {
        std::ostringstream bit_name;
        str_tmp.str("");
        bit_name.str("");
        // Modified by SonTran: Update register name follow HWM
        if (i < 10) { 
            str_tmp<<"DIR0"<< i;
            bit_name<<"DR0"<< i;
        }else{
            str_tmp<<"DIR"<< i;
            bit_name<<"DR"<< i;
        }
        mRdCbAPI[str_tmp.str()][bit_name.str()] = &Csarad113x_regif::cb_DIR_DR;
    }
    for(uint i = 0; i < emNUM_ULLMTBR; i++) {
        str_tmp.str("");
        str_tmp<<"ULLMTBR"<< i;
        mWrCbAPI[str_tmp.str()]["ULMTB"] = &Csarad113x_regif::cb_ULLMTBR_ULMTB;
    }
    for(uint i = 0; i < emNUM_SGSTCR; i++) {
        str_tmp.str("");
        str_tmp<<"SGSTCR"<< mFactorIndexSGSTCR[i];
        mWrCbAPI[str_tmp.str()]["SGSTn"] = &Csarad113x_regif::cb_SGSTCR_SGSTn;
    }
    for(uint i = 0; i < emNUM_SGCR; i++) {
        str_tmp.str("");
        str_tmp<<"SGCR"<< mFactorIndexSGCR[i];
        mWrCbAPI[str_tmp.str()]["ADIE"] = &Csarad113x_regif::cb_SGCR_ADIE;
    }
    for(uint i = 0; i < emNUM_SGSEFCR; i++) {
        str_tmp.str("");
        str_tmp<<"SGSEFCR"<< mFactorIndexSGSEFCR[i];
        mWrCbAPI[str_tmp.str()]["SEFCn"] = &Csarad113x_regif::cb_SGSEFCR_SEFCn;
    }
    for(uint i = 0; i < emNUM_SGVCSP; i++) {
        str_tmp.str("");
        str_tmp<<"SGVCSP"<< mFactorIndexSGVCSP[i];
        mWrCbAPI[str_tmp.str()]["VCSP"] = &Csarad113x_regif::cb_SGVCSP_VCSP;
    }
    for(uint i = 0; i < emNUM_SGVCEP; i++) {
        str_tmp.str("");
        str_tmp<<"SGVCEP"<< mFactorIndexSGVCEP[i];
        mWrCbAPI[str_tmp.str()]["VCEP"] = &Csarad113x_regif::cb_SGVCEP_VCEP;
    }
    for(uint i = 0; i < emNUM_SGMCYCR; i++) {
        str_tmp.str("");
        str_tmp<<"SGMCYCR"<< mFactorIndexSGMCYCR[i];
        mWrCbAPI[str_tmp.str()]["MCYC"] = &Csarad113x_regif::cb_SGMCYCR_MCYC;
    }
    for(uint i = 0; i < emNUM_SGTSEL; i++) {
        str_tmp.str("");
        str_tmp<<"SGTSEL"<< mFactorIndexSGTSEL[i];
        mWrCbAPI[str_tmp.str()]["TxSEL00"] = &Csarad113x_regif::cb_SGTSEL_TxSEL00;
        mRdCbAPI[str_tmp.str()]["TxSEL00"] = &Csarad113x_regif::cb_SGTSEL_TxSEL00;
    }
    InitLocalVal();
}

/// Destructor: delete pointers
/// @return none
Csarad113x_regif::~Csarad113x_regif()
{
    // Delete registers' pointer
    for (uint i = 0 ; i < mTotalRegNum ; i++) {
        delete mRegArray[i]->my_p;
        mRegArray[i]->prev = NULL;
        delete mRegArray[i];
    }
    delete [] mRegMap;
    delete [] mRegArray;
}

/// Mask unselected bit
/// @return selected value
Csarad113x_regif::uint Csarad113x_regif::bit_select(cuint val,    ///< [in] Writting address
                                            cuint start,  ///< [in] start bit position
                                            cuint end)    ///< [in] end bit position
{
    uint ret_val = val;
    if (end - start + 1 < 32) {
        ret_val = (val>>start) & (uint)((1<<(end-start+1))-1);
    }
    return ret_val;
}

/// Write the value to requested module register
/// @return true if writing transaction is finished normally
bool Csarad113x_regif::reg_wr(cuint addr,                    ///< [in] Writting address
                          const unsigned char *p_data,   ///< [in] Writing data
                          cuint size)                    ///< [in] Data size (byte)
{
    if (size == 0) {
        re_printf("error", "Invalid access size: 0 byte\n");
        return false;
    }
    #ifdef IS_MODELED_ENDIAN_BIG
    if ((addr % mBusByteWidth) + size > mBusByteWidth) {
        re_printf("error", "Invalid access address 0x%08X with access size %d bytes\n", addr, size);
        return false;
    }
    #endif

    bool ret_val = false;
    assert(p_data != NULL);
    ret_val = reg_wr_process (addr, p_data, size, false);
    return ret_val;
}

/// Read the register value of requested module
/// @return true if reading transaction is finished normally
bool Csarad113x_regif::reg_rd(cuint addr,              ///< [in]  Reading address
                          unsigned char *p_data,   ///< [out] Reading data
                          cuint size)              ///< [in]  Data size (byte)
{
    if (size == 0) {
        re_printf("error", "Invalid access size: 0 byte\n");
        return false;
    }
    #ifdef IS_MODELED_ENDIAN_BIG
    if ((addr % mBusByteWidth) + size > mBusByteWidth) {
        re_printf("error", "Invalid access address 0x%08X with access size %d bytes\n", addr, size);
        return false;
    }
    #endif

    bool ret_val = false;
    assert(p_data != NULL);
    ret_val = reg_rd_process (addr, p_data, size, false);
    return ret_val;
}

/// Write the value to requested module register
/// @return true if writing transaction is finished normally
bool Csarad113x_regif::reg_wr_dbg(cuint addr,                    ///< [in] Writting address
                              const unsigned char *p_data,   ///< [in] Writing data
                              cuint size)                    ///< [in] Data size (byte)
{
    if (size == 0) {
        re_printf("error", "Invalid access size: 0 byte\n");
        return false;
    }
    #ifdef IS_MODELED_ENDIAN_BIG
    if ((addr % mBusByteWidth) + size > mBusByteWidth) {
        re_printf("error", "Invalid access address 0x%08X with access size %d bytes\n", addr, size);
        return false;
    }
    #endif

    bool ret_val = false;
    assert(p_data != NULL);
    ret_val = reg_wr_process (addr, p_data, size, true);
    return ret_val;
}

/// Read the register value of requested module
/// @return true if reading transaction is finished normally
bool Csarad113x_regif::reg_rd_dbg(cuint addr,              ///< [in]  Reading address
                              unsigned char *p_data,   ///< [out] Reading data
                              cuint size)              ///< [in]  Data size (byte)
{
    if (size == 0) {
        re_printf("error", "Invalid access size: 0 byte\n");
        return false;
    }
    #ifdef IS_MODELED_ENDIAN_BIG
    if ((addr % mBusByteWidth) + size > mBusByteWidth) {
        re_printf("error", "Invalid access address 0x%08X with access size %d bytes\n", addr, size);
        return false;
    }
    #endif

    bool ret_val = false;
    assert(p_data != NULL);
    ret_val = reg_rd_process (addr, p_data, size, true);
    return ret_val;
}

/// Write the value to requested module register
/// @return true if writing transaction is finished normally
bool Csarad113x_regif::reg_wr_process(cuint addr,                   ///< [in] Writting address
                                  const unsigned char *p_data,  ///< [in] Writing data
                                  cuint size,                   ///< [in] Data size (byte)
                                  bool IsDbgFunc)               ///< [in] Flag indicate reg_rd or reg_rd_dbg
{
    if (mIsReset) {
        re_printf("warning", "Cannot write during reset period\n");
        return true;
    }
    uint tmp_addr = addr;
    #ifdef IS_MODELED_ENDIAN_BIG
    if (size < mBusByteWidth) {
        tmp_addr = addr ^ (mBusByteWidth - size);
    }
    #endif
    bool ret_val = false;
    bool valid_addr = false;
    assert(p_data != NULL);
    std::list<uint> list_index;
    uint masked_addr = bit_select(tmp_addr, 0, 11-1);
    uint access_addr = masked_addr;
    while (masked_addr + size > access_addr) {
        int reg_index = get_reg_index(access_addr);
        if (reg_index != -1) {
            vpcl::re_register *reg_p = mRegArray[reg_index]->my_p; 
            if (IsDbgFunc || valid_addr || ChkSize(mRegArray[reg_index]->wacc_size, size, tmp_addr, true)) {
                valid_addr = true;
                list_index.push_back(reg_index);
            } else {
                re_printf("error", "Writing access size to %s at address 0x%08X is wrong: %d byte(s).\n", reg_p->name().c_str(), tmp_addr, size);
                return false;
            }
            access_addr = reg_p->addr() + mRegArray[reg_index]->length;
        } else {
            if (IsDbgFunc || valid_addr) {
                access_addr += 1;
            } else {
                access_addr += size; // To break out while loop
            }
        }
    }
    if (valid_addr) {
        std::list<uint>::iterator it;
        for (it=list_index.begin() ; it!=list_index.end() ; it++) {
            access_addr = masked_addr;
            uint d_size = size;
            uint index = 0;
            if (masked_addr < mRegArray[(*it)]->my_p->addr()) { // adjust access address & index
                access_addr = mRegArray[(*it)]->my_p->addr();
                index = mRegArray[(*it)]->my_p->addr() - masked_addr;
            }
            if ((masked_addr + size) < (mRegArray[(*it)]->my_p->addr() + mRegArray[(*it)]->length)) { // adjust access size
                d_size = masked_addr + size - access_addr;
            } else { // adjust access size
                d_size = (mRegArray[(*it)]->my_p->addr() + mRegArray[(*it)]->length) - access_addr;
            }
            if (size > mRegArray[(*it)]->length) { // adjust index for big endianess
                #ifdef IS_MODELED_ENDIAN_BIG
                index = index ^ (size - mRegArray[(*it)]->length);
                #endif
            }
            ret_val = reg_wr_func(tmp_addr - masked_addr + access_addr, &(p_data[index]), d_size, (*it), IsDbgFunc);
        }
    } else {
        if (!IsDbgFunc) {
            re_printf("error", "Invalid access address 0x%08X\n", tmp_addr);
        } else {
            ret_val = true;
        }
    }
    return ret_val;
}

/// Read the register value of requested module
/// @return true if reading transaction is finished normally
bool Csarad113x_regif::reg_rd_process(cuint addr,              ///< [in]  Reading address
                                  unsigned char *p_data,   ///< [out] Reading data
                                  cuint size,              ///< [in]  Data size (byte)
                                  bool IsDbgFunc)          ///< [in]  Flag indicate reg_rd or reg_rd_dbg
{
    uint tmp_addr = addr;
    #ifdef IS_MODELED_ENDIAN_BIG
    if (size < mBusByteWidth) {
        tmp_addr = addr ^ (mBusByteWidth - size);
    }
    #endif
    bool ret_val = false;
    bool valid_addr = false;
    assert(p_data != NULL);
    std::list<uint> list_index;
    uint masked_addr = bit_select(tmp_addr, 0, 11-1);
    uint access_addr = masked_addr;
    while (masked_addr + size > access_addr) {
        int reg_index = get_reg_index(access_addr);
        if (reg_index != -1) {
            vpcl::re_register *reg_p = mRegArray[reg_index]->my_p; 
            if (IsDbgFunc || valid_addr || ChkSize(mRegArray[reg_index]->racc_size, size, tmp_addr, false)) {
                valid_addr = true;
                list_index.push_back(reg_index);
            } else {
                re_printf("error", "Reading access size to %s at address 0x%08X is wrong: %d byte(s).\n", reg_p->name().c_str(), tmp_addr, size);
                return false;
            }
            access_addr = reg_p->addr() + mRegArray[reg_index]->length;
        } else {
            if (mAPBAccessMode || IsDbgFunc || valid_addr) {
                access_addr += 1;
            } else {
                access_addr += size;  // To break out while loop
            }
        }
    }
    if (valid_addr) {
        std::list<uint>::iterator it;
        for (it=list_index.begin() ; it!=list_index.end() ; it++) {
            access_addr = masked_addr;
            uint d_size = size;
            uint index = 0;
            if (masked_addr < mRegArray[(*it)]->my_p->addr()) { // adjust access address & index
                access_addr = mRegArray[(*it)]->my_p->addr();
                index = mRegArray[(*it)]->my_p->addr() - masked_addr;
            }
            if ((masked_addr + size) < (mRegArray[(*it)]->my_p->addr() + mRegArray[(*it)]->length)) { // adjust access size
                d_size = masked_addr + size - access_addr;
            } else { // adjust access size
                d_size = (mRegArray[(*it)]->my_p->addr() + mRegArray[(*it)]->length) - access_addr;
            }
            if (size > mRegArray[(*it)]->length) { // adjust index for big endianess
                #ifdef IS_MODELED_ENDIAN_BIG
                index = index ^ (size - mRegArray[(*it)]->length);
                #endif
            }
            ret_val = reg_rd_func(tmp_addr - masked_addr + access_addr, &(p_data[index]), d_size, (*it), IsDbgFunc);
        }
    } else {
        if (!(IsDbgFunc || mAPBAccessMode)) {
            memset(p_data, 0, size);
            re_printf("error", "Invalid access address 0x%08X\n", tmp_addr);
        } else {
            memset(p_data, 0, size);
            ret_val = true;
        }
    }
    return ret_val;
}

/// Process reading function
/// @return true if reading successfully
bool Csarad113x_regif::reg_rd_func(cuint addr,                     ///< [in]  Reading address
                               unsigned char *p_data,          ///< [out] Reading data
                               cuint size,                     ///< [in]  Data size (byte)
                               cuint reg_index,                ///< [in]  Register index
                               bool IsDbgFunc)                 ///< [in]  Flag indicate reg_rd or reg_rd_dbg
{
    vpcl::re_register* Register = mRegArray[reg_index]->my_p;
    assert(Register != NULL);
    uint pre_data = 0;
    uint pst_data = 0;
    uint reg_length = mRegArray[reg_index]->length;
    uint start_pos = 0;
    uint mask_size = (1 << (reg_length/2)) - 1;
    if (size < reg_length) {
        #ifdef IS_MODELED_ENDIAN_BIG
        start_pos =  (reg_length - size)*8 - (addr & mask_size)*8; // Start bit position
        #else
        start_pos =  (addr & mask_size)*8;  // Start bit position
        #endif
    }
    if (!IsDbgFunc) {
        if (mIsReset) {
            re_printf("warning", "Cannot launch call-back function during reset period\n");
        }else {
            if (size < reg_length) {
                re_printf("warning","Should read all bit in a register\n");
            }
            pre_data = (uint)(*Register);
            pst_data = Register->read();
            for (vpcl::bit_info *it=Register->mBitInfo ; it!=NULL ; it=it->next) {
                if (((mRdCbAPI[Register->name()][it->name()]) != NULL)
                && (((start_pos < it->mStartAddr) && (it->mEndAddr < start_pos + size * 8))
                 || ((it->mStartAddr <= start_pos) && (start_pos <= it->mEndAddr))
                 || ((it->mStartAddr <= start_pos + size * 8) && (start_pos + size * 8 <= it->mEndAddr)) )) {
                    (this->*(mRdCbAPI[Register->name()][it->name()]))(RegCBstr(mRegArray[reg_index]->channel, false, size, pre_data, pst_data));
                }
            }
        }
    }
    pst_data = (uint)(*Register);
    if (size < reg_length) {
        uint read_data = 0;
        if (((reg_length%2 == 0) && (reg_length%size == 0) && ((addr&mask_size)%size == 0)) 
         || (!IsDbgFunc)) {
            for (uint i = start_pos; i < (8*size + start_pos); i++) {
                read_data |= (pst_data & (1 << i)) >> start_pos;
            }
            pst_data = read_data;
        }
    }

    assert(p_data != NULL);
    memcpy(p_data, &pst_data, size);
    DumpRegMsg("R", Register->name(), "", size, addr, 0, 0, pst_data, mRegArray[reg_index]->length*8);
    for (vpcl::bit_info *it=Register->mBitInfo ; it!=NULL ; it=it->next) {
        uint val = (uint)(*Register);
        val = bit_select(val, it->mStartAddr, it->mEndAddr);
        if (mDumpBitInfo) {
            DumpRegMsg("R", Register->name(), it->name(), size, addr, 0, 0, val, it->mEndAddr - it->mStartAddr + 1);
        }
    }
    return true;
}

/// Process writing function
/// @return true if writing successfully
bool Csarad113x_regif::reg_wr_func(cuint addr,                       ///< [in] Writting address
                               const unsigned char *p_data,      ///< [in] Writing data
                               cuint size,                       ///< [in] Data size (byte)
                               cuint reg_index,                  ///< [in] Register index
                               bool IsDbgFunc)                   ///< [in] Flag indicate reg_wr or reg_wr_dbg
{
    vpcl::re_register* Register = mRegArray[reg_index]->my_p;
    uint pre_data = 0;
    uint data = 0;
    uint reg_length = mRegArray[reg_index]->length;
    uint start_pos = 0;
    assert ((p_data != NULL) && (Register != NULL));
    memcpy(&data, p_data, size);
    uint wr_data = data;
    if (size < reg_length) {
        uint mask_size = (1 << (reg_length/2)) - 1;
        if (((reg_length%2 == 0) && (reg_length%size == 0) && ((addr&mask_size)%size == 0)) 
         || (!IsDbgFunc)) {
            uint new_data = (uint)(*Register);  // For writing to register
            uint written_data = 0;         // For transferring to callback function
            #ifdef IS_MODELED_ENDIAN_BIG
            start_pos =  (reg_length - size)*8 - (addr & mask_size)*8; // Start bit position
            #else
            start_pos =  (addr & mask_size)*8;  // Start bit position
            #endif
            for (uint i = start_pos; i < (8*size + start_pos); i++) {
                new_data = (new_data & (~(1 << i))) | ((data << start_pos) & (1 << i));
                written_data = (written_data & (~(1 << i))) | ((data << start_pos) & (1 << i));
            }
            data = new_data;
        }
    }

    if (!mRegArray[reg_index]->block || IsDbgFunc){
        pre_data = (uint)(*Register);
        if (IsDbgFunc) {
            bool backup_warning = Register->mMessageLevel["warning"];
            bool backup_error = Register->mMessageLevel["error"];
            Register->mMessageLevel["warning"] = false;
            Register->mMessageLevel["error"]   = false;

            Register->write(data);

            Register->mMessageLevel["warning"] = backup_warning;
            Register->mMessageLevel["error"]   = backup_error;
        } else {
            Register->write(data);
        }
        UpdateLocalVal(Register->addr());
        DumpRegMsg("W", Register->name(), "", size, addr, wr_data, pre_data, (uint)(*Register), mRegArray[reg_index]->length*8);
        for (vpcl::bit_info *it=Register->mBitInfo ; it!=NULL ; it=it->next) {
            uint val = (uint)(*Register);
            val = bit_select(val, it->mStartAddr, it->mEndAddr);
            uint pre_val = pre_data;
            pre_val = bit_select(pre_val, it->mStartAddr, it->mEndAddr);
            if (mDumpBitInfo) {
                DumpRegMsg("W", Register->name(), it->name(), size, addr, (unsigned int)*it, pre_val, val, it->mEndAddr - it->mStartAddr + 1);
            }
            if ((mWrCbAPI[Register->name()][it->name()]) != NULL) {
                (this->*(mWrCbAPI[Register->name()][it->name()]))(RegCBstr(mRegArray[reg_index]->channel, true, size, pre_data, data));
            }
        }
    } else {
        re_printf("warning","%s is blocked writing from Bus I/F.\n", Register->name().c_str());
    }
    return true;
}

/// Check access size
/// @@return true if detect_size equal expect_size
bool Csarad113x_regif::ChkSize(std::string expect_size, cuint detect_size, cuint addr, bool is_wr)
{
    std::vector<std::string> arg_vec = Str2Vec(expect_size, '|');
    std::vector<std::string>::iterator it;
    char *err_p = NULL;
    uint size = 0;
    if (detect_size > mBusByteWidth) {
        re_printf("error", "Invalid access size: %d bytes\n", detect_size);
        return false;
    }
    if (addr%detect_size != 0) {
        re_printf("error", "Invalid access address 0x%08X with access size %d bytes\n", addr, detect_size);
        return false;
    }
    if (is_wr || !(mAPBAccessMode)) {
        for (it = arg_vec.begin(); it != arg_vec.end(); it++) {
            errno = 0; size = (uint) strtoul((*it).c_str(), &err_p, 0);
            assert(err_p != NULL);
            if (errno != ERANGE && *err_p == '\0') {
                if ((size/8) == detect_size) {
                    return true;
                }
            }
        }
    } else {
        return true;
    }
    return false;
}

/// Initialize reg_handle_command variables
/// @return none
void Csarad113x_regif::CommandInit()
{
    mDumpRegisterRW = false;
    mAPBAccessMode  = false;
    mDumpBitInfo    = true;
    mMessageLevel["fatal"]   = true;
    mMessageLevel["error"]   = true;
    mMessageLevel["warning"] = false;
    mMessageLevel["info"]    = false;
}

/// Process reg_handle_command command
/// @return string
std::string Csarad113x_regif::reg_handle_command(const std::vector<std::string>& args)
{
    std::string ret = "";
    std::string err_msg = "Error ("   + mInstName + ") ";   // error message
    if (args[0] == "reg") {
        if (args[1] == "help") {
            ret += "    --- reg ---\n";
            ret += "    reg MessageLevel <fatal|error|warning|info> Select debug message level (Default: fatal|error)\n";
            ret += "    reg DumpRegisterRW <true/false>             Select dump register access information  (Default: false)\n";
            ret += "    reg APBAccessMode <true/false>              Select for APB access mode when reading (Default: false)\n";
            ret += "    reg DumpBitInfo <true/false>                Select for dump bit information (Default: true)\n";
            ret += "    reg <register_name> MessageLevel <fatal|error|warning|info> Select debug message level for register (Default: fatal|error)\n";
            ret += "    reg <register_name> force <value>           Force register with setting value\n";
            ret += "    reg <register_name> release                 Release register from force value\n";
            ret += "    reg <register_name> <value>                 Write a value into register\n";
            ret += "    reg <register_name>                         Read value of register\n";
            ret += "    reg help                                    Show a direction\n";
        } else if (args[1] == "DumpRegisterRW") {
            if (args.size() == 2) {
                ret = (mDumpRegisterRW)? "true" : "false";
            } else if (args.size() == 3) {
                if (args[2] == "true") {
                    mDumpRegisterRW = true;
                } else if (args[2] == "false") {
                    mDumpRegisterRW = false;
                } else {
                    ret = err_msg + "DumpRegisterRW command needs an argument [true/false]\n";
                }
            } else {
                ret = err_msg + "DumpRegisterRW has too much arguments\n";
            }
        } else if (args[1] == "APBAccessMode") {
            if (args.size() == 2) {
                ret = (mAPBAccessMode)? "true" : "false";
            } else if (args.size() == 3) {
                if (args[2] == "true") {
                    mAPBAccessMode = true;
                } else if (args[2] == "false") {
                    mAPBAccessMode = false;
                } else {
                    ret = err_msg + "APBAccessMode command needs an argument [true/false]\n";
                }
            } else {
                ret = err_msg + "APBAccessMode has too much arguments\n";
            }
        } else if (args[1] == "DumpBitInfo") {
            if (args.size() == 2) {
                ret = (mDumpBitInfo)? "true" : "false";
            } else if (args.size() == 3) {
                if (args[2] == "true") {
                    mDumpBitInfo = true;
                } else if (args[2] == "false") {
                    mDumpBitInfo = false;
                } else {
                    ret = err_msg + "DumpBitInfo command needs an argument [true/false]\n";
                }
            } else {
                ret = err_msg + "DumpBitInfo has too much arguments\n";
            }
        } else if (args[1] == "MessageLevel") {
            // read mode
            if (args.size() == 2) {
                std::map<std::string, bool>::iterator it;
                for (it = mMessageLevel.begin(); it != mMessageLevel.end(); it++) {
                    if ( it->second ) {
                        ret += " " + it->first;
                    }
                }
            // write mode
            } else if (args.size() == 3) {
                std::vector<std::string> arg_vec = Str2Vec(args[2], '|');
                std::map<std::string, bool>::iterator msgit;
                for (msgit =mMessageLevel.begin(); msgit != mMessageLevel.end(); msgit++) {
                    msgit->second = false;
                }
                std::vector<std::string>::iterator it;
                for (it = arg_vec.begin(); it != arg_vec.end(); it++) {
                    mMessageLevel[*it] = true;
                }
            } else {
                ret = err_msg + "MessageLevel has too much arguments\n";
            }
        } else {
            bool matched = false;
            for (uint i = 0; i < mTotalRegNum; i++) {
                if (args[1] == mRegArray[i]->my_p->name()) {
                    ret = AccessRegCommand(args, mRegArray[i]->my_p, mRegArray[i]->block);
                    matched = true;
                    break;
                }
            }
            if (!matched) {
                ret = err_msg + "Register name " + (std::string)args[1] + " is invalid\n";
            }
        }
    }
    return ret;
}

/// process reg_handle_command of "reg" parameter
/// @return string
std::string Csarad113x_regif::AccessRegCommand(const std::vector<std::string>& args, vpcl::re_register *Register, bool &BlockReg)
{
    std::string ret = "";
    char *err_p = NULL;
    std::string err_msg = "Error ("   + mInstName + ") ";   // error message
    uint data = 0;
    std::ostringstream str_tmp;
    assert(Register != NULL);
    if (args.size() == 2) {
        data = (uint)(*Register);
        str_tmp<<std::setw(14)<<std::left<<(Register->name());
        str_tmp<<"0x"<<std::setw(8)<<std::hex<<std::uppercase<<std::left<<data<<"\n";
        ret = str_tmp.str();
    } else if ((args.size() == 3) && (args[2] == "release")) {
        BlockReg = false;
    } else if ((args.size() == 4) && (args[2] == "force")) {
        errno = 0; data = (uint) strtoul(args[3].c_str(), &err_p, 0);
        assert(err_p != NULL);
        if (errno != ERANGE && *err_p == '\0') {
            *Register = data;
            BlockReg = true;
            UpdateLocalVal(Register->addr());
        } else {
            ret = err_msg + "[" + Register->name() + "] Invalid force value\n";
        }
    } else if ((args.size() >= 3) && (args[2] == "MessageLevel")) {
        if (args.size() == 3) {
            ret = Register->name() + " ";
            ret += Register->GetMessageLevel();
        } else if (args.size() == 4) {
            std::map<std::string, bool> MessageLevel;
            std::vector<std::string> arg_vec = Str2Vec(args[3], '|');
            std::vector<std::string>::iterator it;
            for (it = arg_vec.begin(); it != arg_vec.end(); it++) {
                MessageLevel[*it] = true;
            }
            Register->SetMessageLevel(MessageLevel);
        } else {
            ret = err_msg + "[" + Register->name() + "] MessageLevel has too much arguments\n";
        }
    } else if ((args.size() == 3) && (args[2] != "release")) {
        errno = 0; data = (uint) strtoul(args[2].c_str(), &err_p, 0);
        if (errno != ERANGE && *err_p == '\0') {
            *Register = data;
            UpdateLocalVal(Register->addr());
        } else {
            ret = err_msg + "[" + Register->name() + "] Invalid write value\n";
        }
    } else {
        ret = err_msg + "Wrong command : ";
        for (uint index = 0; index < args.size(); index ++) {
            ret += args[index] + " ";
        }
    }
    return ret;
}

/// Initialize local variables
/// @return none
void Csarad113x_regif::InitLocalVal()
{
    // Initialize local variables
    for(uint i = 0; i < emNUM_VCR;       i++) {
        VCR_MPXE  [i] = 0x0;
        VCR_MPXV  [i] = 0x0;
        if ((i >=33)&&(i<=35)){ // Modified by SonTran: VCR.CNVCLS only available on VCR33, VCR34, VCR35
            VCR_CNVCLS[i] = 0x0;
        }
        VCR_ULS   [i] = 0x0;
        VCR_ADIE  [i] = 0x0;
        VCR_GCTRL [i] = 0x0;
    }
    TSNVCR_ULS = 0x0;
    TSNVCR_TSNGCTRL = 0x25;
    PWDVCR_MPXE = 0x0;
    PWDVCR_MPXV = 0x0;
    PWDVCR_ULS = 0x0;
    PWDVCR_GCTRL = 0x0;
    for(uint i = 0; i < emNUM_DR;        i++) {
        DR_DR1    [i] = 0x0;
        DR_DR0    [i] = 0x0;
    }
    PWDTSNDR_PWDDR = 0x0;
    PWDTSNDR_TSNDR = 0x0;
    for(uint i = 0; i < emNUM_DIR;       i++) {
        DIR_MPXE  [i] = 0x0;
        DIR_MPXV  [i] = 0x0;
        DIR_WFLG  [i] = 0x0;
        DIR_ID    [i] = 0x0;
        DIR_DR    [i] = 0x0;
    }
    TSNDIR_WFLG = 0x0;
    TSNDIR_ID  = 0x25;
    TSNDIR_TSNDR = 0x0;
    PWDDIR_MPXE = 0x0;
    PWDDIR_MPXV = 0x0;
    PWDDIR_WFLG = 0x0;
    PWDDIR_ID  = 0x0;
    PWDDIR_PWDDR = 0x0;
    ADHALTR_HALT = 0x0;
    ADCR_DGON  = 0x0;
    ADCR_TSNSELFDIAG = 0x0;
    ADCR_CRAC  = 0x0;
    ADCR_CTYP  = 0x0;
    ADCR_SUSMTD = 0x0;
    SGSTR_SHACT = 0x0;
    SGSTR_SGACT = 0x0;
    SGSTR_SEF  = 0x0;
    MPXCURR_MPXCUR = 0x0;
    TSNCR_TSNEN = 0x0;
    THSMPSTCR_SMPST = 0x0;
    THCR_ASMPMSK = 0x0;
    THAHLDSTCR_HLDST = 0x0;
    THBHLDSTCR_HLDST = 0x0;
    THACR_HLDCTE = 0x0;
    THACR_HLDTE = 0x0;
    THACR_SGS  = 0x0;
    THBCR_HLDCTE = 0x0;
    THBCR_HLDTE = 0x0;
    THBCR_SGS  = 0x0;
    THER_TH5E  = 0x0;
    THER_TH4E  = 0x0;
    THER_TH3E  = 0x0;
    THER_TH2E  = 0x0;
    THER_TH1E  = 0x0;
    THER_TH0E  = 0x0;
    THGSR_TH5GS = 0x0;
    THGSR_TH4GS = 0x0;
    THGSR_TH3GS = 0x0;
    THGSR_TH2GS = 0x0;
    THGSR_TH1GS = 0x0;
    THGSR_TH0GS = 0x0;
    SFTCR_RDCLRE = 0x0;
    SFTCR_ULEIE = 0x0;
    SFTCR_OWEIE = 0x0;
    for(uint i = 0; i < emNUM_ULLMTBR;   i++) {
        ULLMTBR_ULMTB[i] = 0xFFF;
        ULLMTBR_LLMTB[i] = 0x0;
    }
    ECR_ULEC   = 0x0;
    ECR_OWEC   = 0x0;
    ULER_UE    = 0x0;
    ULER_LE    = 0x0;
    ULER_ULSG  = 0x0;
    ULER_MPXE  = 0x0;
    ULER_MPXV  = 0x0;
    ULER_ULE   = 0x0;
    ULER_ULECAP = 0x0;
    OWER_OWE   = 0x0;
    OWER_OWECAP = 0x0;
    DGCTL0_PSEL2 = 0x0;
    DGCTL0_PSEL1 = 0x0;
    DGCTL0_PSEL0 = 0x0;
    DGCTL1_CDG15 = 0x0;
    DGCTL1_CDG14 = 0x0;
    DGCTL1_CDG13 = 0x0;
    DGCTL1_CDG12 = 0x0;
    DGCTL1_CDG11 = 0x0;
    DGCTL1_CDG10 = 0x0;
    DGCTL1_CDG09 = 0x0;
    DGCTL1_CDG08 = 0x0;
    DGCTL1_CDG07 = 0x0;
    DGCTL1_CDG06 = 0x0;
    DGCTL1_CDG05 = 0x0;
    DGCTL1_CDG04 = 0x0;
    DGCTL1_CDG03 = 0x0;
    DGCTL1_CDG02 = 0x0;
    DGCTL1_CDG01 = 0x0;
    DGCTL1_CDG00 = 0x0;
    PDCTL1_PDNA15 = 0x0;
    PDCTL1_PDNA14 = 0x0;
    PDCTL1_PDNA13 = 0x0;
    PDCTL1_PDNA12 = 0x0;
    PDCTL1_PDNA11 = 0x0;
    PDCTL1_PDNA10 = 0x0;
    PDCTL1_PDNA09 = 0x0;
    PDCTL1_PDNA08 = 0x0;
    PDCTL1_PDNA07 = 0x0;
    PDCTL1_PDNA06 = 0x0;
    PDCTL1_PDNA05 = 0x0;
    PDCTL1_PDNA04 = 0x0;
    PDCTL1_PDNA03 = 0x0;
    PDCTL1_PDNA02 = 0x0;
    PDCTL1_PDNA01 = 0x0;
    PDCTL1_PDNA00 = 0x0;
    PDCTL2_PDNB19 = 0x0;
    PDCTL2_PDNB18 = 0x0;
    PDCTL2_PDNB17 = 0x0;
    PDCTL2_PDNB16 = 0x0;
    PDCTL2_PDNB15 = 0x0;
    PDCTL2_PDNB14 = 0x0;
    PDCTL2_PDNB13 = 0x0;
    PDCTL2_PDNB12 = 0x0;
    PDCTL2_PDNB11 = 0x0;
    PDCTL2_PDNB10 = 0x0;
    PDCTL2_PDNB09 = 0x0;
    PDCTL2_PDNB08 = 0x0;
    PDCTL2_PDNB07 = 0x0;
    PDCTL2_PDNB06 = 0x0;
    PDCTL2_PDNB05 = 0x0;
    PDCTL2_PDNB04 = 0x0;
    PDCTL2_PDNB03 = 0x0;
    PDCTL2_PDNB02 = 0x0;
    PDCTL2_PDNB01 = 0x0;
    PDCTL2_PDNB00 = 0x0;
    SMPCR_SMPT = 0x18;
    TSNSMPCR_TSNSMPT = 0xF0;
    EMUCR_SVSDIS = 0x0;
    SGPRCR_SGPR4 = 0x4;
    SGPRCR_SGPR3 = 0x3;
    SGPRCR_SGPR2 = 0x2;
    SGPRCR_SGPR1 = 0x1;
    SGPRCR_SGPR0 = 0x0;
    TRMCR_TRMS = 0x0;
    TRMCR_TRMDGSTBY = 0x0;
    TRMCR_TRMTSNTUNE = 0x0;
    TRMCR_TRMTTUNE = 0x0;
    TRMCR_TRMBTUNE = 0x0;
    TRMCR_TRMATUNE = 0x0;
    TRMCR_TRMTSN = 0x0;
    TRMCR_TRMT = 0x0;
    TRMCR_TRMB = 0x0;
    TRMCR_TRMA = 0x0;
    ADTSTRA_ADTST = 0x0;
    ADTSTRB_ADVAL = 0x0;
    ADTSTRC_CKSTP = 0x0;
    ADTSTRC_SYNCERR = 0x0;
    ADTSTRC_ADMD8 = 0x0;
    ADTSTRC_ADMD7 = 0x0;
    ADTSTRC_ADMD6 = 0x0;
    ADTSTRC_ADMD5 = 0x0;
    ADTSTRC_ADMD4 = 0x0;
    ADTSTRC_ADMD3 = 0x0;
    ADTSTRC_ADMD = 0x0;
    for(uint i = 0; i < emNUM_SGSTCR;    i++) {
        SGSTCR_SGSTn[mFactorIndexSGSTCR[i]] = 0x0;
    }
    TSNSGSTCR_TSNSGST = 0x0;
    PWDSGSTCR_PWDSGST = 0x0;
    for(uint i = 0; i < emNUM_SGCR;      i++) {
        SGCR_SCANMD[mFactorIndexSGCR[i]] = 0x0;
        SGCR_ADIE [mFactorIndexSGCR[i]] = 0x0;
        SGCR_SCT  [mFactorIndexSGCR[i]] = 0x0;
        SGCR_TRGMD[mFactorIndexSGCR[i]] = 0x0;
    }
    TSNSGCR_TSNTRGMD = 0x0;
    PWDSGCR_PWDTRGMD = 0x0;
    for(uint i = 0; i < emNUM_SGSEFCR;   i++) {
        SGSEFCR_SEFCn[mFactorIndexSGSEFCR[i]] = 0x0;
    }
    TSNSGSEFCR_TSNSEFC = 0x0;
    PWDSGSEFCR_PWDSEFC = 0x0;
    for(uint i = 0; i < emNUM_SGVCSP;    i++) {
        SGVCSP_VCSP[mFactorIndexSGVCSP[i]] = 0x0;
    }
    for(uint i = 0; i < emNUM_SGVCEP;    i++) {
        SGVCEP_VCEP[mFactorIndexSGVCEP[i]] = 0x0;
    }
    for(uint i = 0; i < emNUM_SGMCYCR;   i++) {
        SGMCYCR_MCYC[mFactorIndexSGMCYCR[i]] = 0x0;
    }
    for(uint i = 0; i < emNUM_SGTSEL;    i++) {
        SGTSEL_TxSEL15[mFactorIndexSGTSEL[i]] = 0x0;
        SGTSEL_TxSEL14[mFactorIndexSGTSEL[i]] = 0x0;
        SGTSEL_TxSEL13[mFactorIndexSGTSEL[i]] = 0x0;
        SGTSEL_TxSEL12[mFactorIndexSGTSEL[i]] = 0x0;
        SGTSEL_TxSEL11[mFactorIndexSGTSEL[i]] = 0x0;
        SGTSEL_TxSEL10[mFactorIndexSGTSEL[i]] = 0x0;
        SGTSEL_TxSEL09[mFactorIndexSGTSEL[i]] = 0x0;
        SGTSEL_TxSEL08[mFactorIndexSGTSEL[i]] = 0x0;
        SGTSEL_TxSEL07[mFactorIndexSGTSEL[i]] = 0x0;
        SGTSEL_TxSEL06[mFactorIndexSGTSEL[i]] = 0x0;
        SGTSEL_TxSEL05[mFactorIndexSGTSEL[i]] = 0x0;
        SGTSEL_TxSEL04[mFactorIndexSGTSEL[i]] = 0x0;
        SGTSEL_TxSEL03[mFactorIndexSGTSEL[i]] = 0x0;
        SGTSEL_TxSEL02[mFactorIndexSGTSEL[i]] = 0x0;
        SGTSEL_TxSEL01[mFactorIndexSGTSEL[i]] = 0x0;
        SGTSEL_TxSEL00[mFactorIndexSGTSEL[i]] = 0x0;
    }
}

/// Update bit value to local value
/// @return None
void Csarad113x_regif::UpdateLocalVal(cuint addr)
{
    if ((0x0000 <= addr) && (addr <= (0x0000)+(4*49)) && ((addr-0x0000)%4 == 0)) {
        uint i = (addr - 0x0000)/4;
        VCR_MPXE                      [i] = (*(VCR       [i]))["MPXE"      ];
        VCR_MPXV                      [i] = (*(VCR       [i]))["MPXV"      ];
        if ((i >=33)&&(i<=35)){ // Modified by SonTran: VCR.CNVCLS only available on VCR33, VCR34, VCR35
            VCR_CNVCLS                    [i] = (*(VCR       [i]))["CNVCLS"    ];
        }
        VCR_ULS                       [i] = (*(VCR       [i]))["ULS"       ];
        VCR_ADIE                      [i] = (*(VCR       [i]))["ADIE"      ];
        VCR_GCTRL                     [i] = (*(VCR       [i]))["GCTRL"     ];
        return;
    }
    if (addr == 0x00F0) {
        TSNVCR_ULS                     = (*TSNVCR    )["ULS"       ];
        TSNVCR_TSNGCTRL                = (*TSNVCR    )["TSNGCTRL"  ];
        return;
    }
    if (addr == 0x00F4) {
        PWDVCR_MPXE                    = (*PWDVCR    )["MPXE"      ];
        PWDVCR_MPXV                    = (*PWDVCR    )["MPXV"      ];
        PWDVCR_ULS                     = (*PWDVCR    )["ULS"       ];
        PWDVCR_GCTRL                   = (*PWDVCR    )["GCTRL"     ];
        return;
    }
    if ((0x0100 <= addr) && (addr <= (0x0100)+(4*24)) && ((addr-0x0100)%4 == 0)) {
        uint i = (addr - 0x0100)/4;
        // Modified by SonTran: Update bit name follow HWM
        DR_DR1                        [i] = (((unsigned int)(*(DR        [i]))) >> 16)&0xFFFF;
        DR_DR0                        [i] = (((unsigned int)(*(DR        [i])))      )&0xFFFF;
        return;
    }
    if (addr == 0x0178) {
        PWDTSNDR_PWDDR                 = (*PWDTSNDR  )["PWDDR"     ];
        PWDTSNDR_TSNDR                 = (*PWDTSNDR  )["TSNDR"     ];
        return;
    }
    if ((0x0200 <= addr) && (addr <= (0x0200)+(4*49)) && ((addr-0x0200)%4 == 0)) {
        uint i = (addr - 0x0200)/4;
        DIR_MPXE                      [i] = (*(DIR       [i]))["MPXE"      ];
        DIR_MPXV                      [i] = (*(DIR       [i]))["MPXV"      ];
        DIR_WFLG                      [i] = (*(DIR       [i]))["WFLG"      ];
        DIR_ID                        [i] = (*(DIR       [i]))["ID"        ];
        std::ostringstream str_tmp;
        str_tmp.str("");
        if (i < 10) { 
            str_tmp<<"DR0"<< i;
        }else{
            str_tmp<<"DR"<< i;
        }
        DIR_DR                        [i] = (*(DIR       [i]))[str_tmp.str().c_str()];
        return;
    }
    if (addr == 0x02F0) {
        TSNDIR_WFLG                    = (*TSNDIR    )["WFLG"      ];
        TSNDIR_ID                      = (*TSNDIR    )["ID"        ];
        TSNDIR_TSNDR                   = (*TSNDIR    )["TSNDR"     ];
        return;
    }
    if (addr == 0x02F4) {
        PWDDIR_MPXE                    = (*PWDDIR    )["MPXE"      ];
        PWDDIR_MPXV                    = (*PWDDIR    )["MPXV"      ];
        PWDDIR_WFLG                    = (*PWDDIR    )["WFLG"      ];
        PWDDIR_ID                      = (*PWDDIR    )["ID"        ];
        PWDDIR_PWDDR                   = (*PWDDIR    )["PWDDR"     ];
        return;
    }
    if (addr == 0x0300) {
        ADHALTR_HALT                   = (*ADHALTR   )["HALT"      ];
        return;
    }
    if (addr == 0x0304) {
        ADCR_DGON                      = (*ADCR      )["DGON"      ];
        ADCR_TSNSELFDIAG               = (*ADCR      )["TSNSELFDIAG"];
        ADCR_CRAC                      = (*ADCR      )["CRAC"      ];
        ADCR_CTYP                      = (*ADCR      )["CTYP"      ];
        ADCR_SUSMTD                    = (*ADCR      )["SUSMTD"    ];
        return;
    }
    if (addr == 0x0308) {
        SGSTR_SHACT                    = (*SGSTR     )["SHACT"     ];
        SGSTR_SGACT                    = (*SGSTR     )["SGACT"     ];
        SGSTR_SEF                      = (*SGSTR     )["SEF"       ];
        return;
    }
    if (addr == 0x030C) {
        MPXCURR_MPXCUR                 = (*MPXCURR   )["MPXCUR"    ];
        return;
    }
    if (addr == 0x0310) {
        TSNCR_TSNEN                    = (*TSNCR     )["TSNEN"     ];
        return;
    }
    if (addr == 0x0314) {
        THSMPSTCR_SMPST                = (*THSMPSTCR )["SMPST"     ];
        return;
    }
    if (addr == 0x0318) {
        THCR_ASMPMSK                   = (*THCR      )["ASMPMSK"   ];
        return;
    }
    if (addr == 0x031C) {
        THAHLDSTCR_HLDST               = (*THAHLDSTCR)["HLDST"     ];
        return;
    }
    if (addr == 0x0320) {
        THBHLDSTCR_HLDST               = (*THBHLDSTCR)["HLDST"     ];
        return;
    }
    if (addr == 0x0324) {
        THACR_HLDCTE                   = (*THACR     )["HLDCTE"    ];
        THACR_HLDTE                    = (*THACR     )["HLDTE"     ];
        THACR_SGS                      = (*THACR     )["SGS"       ];
        return;
    }
    if (addr == 0x0328) {
        THBCR_HLDCTE                   = (*THBCR     )["HLDCTE"    ];
        THBCR_HLDTE                    = (*THBCR     )["HLDTE"     ];
        THBCR_SGS                      = (*THBCR     )["SGS"       ];
        return;
    }
    if (addr == 0x032C) {
        THER_TH5E                      = (*THER      )["TH5E"      ];
        THER_TH4E                      = (*THER      )["TH4E"      ];
        THER_TH3E                      = (*THER      )["TH3E"      ];
        THER_TH2E                      = (*THER      )["TH2E"      ];
        THER_TH1E                      = (*THER      )["TH1E"      ];
        THER_TH0E                      = (*THER      )["TH0E"      ];
        return;
    }
    if (addr == 0x0330) {
        THGSR_TH5GS                    = (*THGSR     )["TH5GS"     ];
        THGSR_TH4GS                    = (*THGSR     )["TH4GS"     ];
        THGSR_TH3GS                    = (*THGSR     )["TH3GS"     ];
        THGSR_TH2GS                    = (*THGSR     )["TH2GS"     ];
        THGSR_TH1GS                    = (*THGSR     )["TH1GS"     ];
        THGSR_TH0GS                    = (*THGSR     )["TH0GS"     ];
        return;
    }
    if (addr == 0x0334) {
        SFTCR_RDCLRE                   = (*SFTCR     )["RDCLRE"    ];
        SFTCR_ULEIE                    = (*SFTCR     )["ULEIE"     ];
        SFTCR_OWEIE                    = (*SFTCR     )["OWEIE"     ];
        return;
    }
    if ((0x0338 <= addr) && (addr <= (0x0338)+(4*2)) && ((addr-0x0338)%4 == 0)) {
        uint i = (addr - 0x0338)/4;
        ULLMTBR_ULMTB                 [i] = (*(ULLMTBR   [i]))["ULMTB"     ];
        ULLMTBR_LLMTB                 [i] = (*(ULLMTBR   [i]))["LLMTB"     ];
        return;
    }
    if (addr == 0x0344) {
        ECR_ULEC                       = (*ECR       )["ULEC"      ];
        ECR_OWEC                       = (*ECR       )["OWEC"      ];
        return;
    }
    if (addr == 0x0348) {
        ULER_UE                        = (*ULER      )["UE"        ];
        ULER_LE                        = (*ULER      )["LE"        ];
        ULER_ULSG                      = (*ULER      )["ULSG"      ];
        ULER_MPXE                      = (*ULER      )["MPXE"      ];
        ULER_MPXV                      = (*ULER      )["MPXV"      ];
        ULER_ULE                       = (*ULER      )["ULE"       ];
        ULER_ULECAP                    = (*ULER      )["ULECAP"    ];
        return;
    }
    if (addr == 0x034C) {
        OWER_OWE                       = (*OWER      )["OWE"       ];
        OWER_OWECAP                    = (*OWER      )["OWECAP"    ];
        return;
    }
    if (addr == 0x0350) {
        DGCTL0_PSEL2                   = (*DGCTL0    )["PSEL2"     ];
        DGCTL0_PSEL1                   = (*DGCTL0    )["PSEL1"     ];
        DGCTL0_PSEL0                   = (*DGCTL0    )["PSEL0"     ];
        return;
    }
    if (addr == 0x0354) {
        DGCTL1_CDG15                   = (*DGCTL1    )["CDG15"     ];
        DGCTL1_CDG14                   = (*DGCTL1    )["CDG14"     ];
        DGCTL1_CDG13                   = (*DGCTL1    )["CDG13"     ];
        DGCTL1_CDG12                   = (*DGCTL1    )["CDG12"     ];
        DGCTL1_CDG11                   = (*DGCTL1    )["CDG11"     ];
        DGCTL1_CDG10                   = (*DGCTL1    )["CDG10"     ];
        DGCTL1_CDG09                   = (*DGCTL1    )["CDG09"     ];
        DGCTL1_CDG08                   = (*DGCTL1    )["CDG08"     ];
        DGCTL1_CDG07                   = (*DGCTL1    )["CDG07"     ];
        DGCTL1_CDG06                   = (*DGCTL1    )["CDG06"     ];
        DGCTL1_CDG05                   = (*DGCTL1    )["CDG05"     ];
        DGCTL1_CDG04                   = (*DGCTL1    )["CDG04"     ];
        DGCTL1_CDG03                   = (*DGCTL1    )["CDG03"     ];
        DGCTL1_CDG02                   = (*DGCTL1    )["CDG02"     ];
        DGCTL1_CDG01                   = (*DGCTL1    )["CDG01"     ];
        DGCTL1_CDG00                   = (*DGCTL1    )["CDG00"     ];
        return;
    }
    if (addr == 0x0358) {
        PDCTL1_PDNA15                  = (*PDCTL1    )["PDNA15"    ];
        PDCTL1_PDNA14                  = (*PDCTL1    )["PDNA14"    ];
        PDCTL1_PDNA13                  = (*PDCTL1    )["PDNA13"    ];
        PDCTL1_PDNA12                  = (*PDCTL1    )["PDNA12"    ];
        PDCTL1_PDNA11                  = (*PDCTL1    )["PDNA11"    ];
        PDCTL1_PDNA10                  = (*PDCTL1    )["PDNA10"    ];
        PDCTL1_PDNA09                  = (*PDCTL1    )["PDNA09"    ];
        PDCTL1_PDNA08                  = (*PDCTL1    )["PDNA08"    ];
        PDCTL1_PDNA07                  = (*PDCTL1    )["PDNA07"    ];
        PDCTL1_PDNA06                  = (*PDCTL1    )["PDNA06"    ];
        PDCTL1_PDNA05                  = (*PDCTL1    )["PDNA05"    ];
        PDCTL1_PDNA04                  = (*PDCTL1    )["PDNA04"    ];
        PDCTL1_PDNA03                  = (*PDCTL1    )["PDNA03"    ];
        PDCTL1_PDNA02                  = (*PDCTL1    )["PDNA02"    ];
        PDCTL1_PDNA01                  = (*PDCTL1    )["PDNA01"    ];
        PDCTL1_PDNA00                  = (*PDCTL1    )["PDNA00"    ];
        return;
    }
    if (addr == 0x035C) {
        PDCTL2_PDNB19                  = (*PDCTL2    )["PDNB19"    ];
        PDCTL2_PDNB18                  = (*PDCTL2    )["PDNB18"    ];
        PDCTL2_PDNB17                  = (*PDCTL2    )["PDNB17"    ];
        PDCTL2_PDNB16                  = (*PDCTL2    )["PDNB16"    ];
        PDCTL2_PDNB15                  = (*PDCTL2    )["PDNB15"    ];
        PDCTL2_PDNB14                  = (*PDCTL2    )["PDNB14"    ];
        PDCTL2_PDNB13                  = (*PDCTL2    )["PDNB13"    ];
        PDCTL2_PDNB12                  = (*PDCTL2    )["PDNB12"    ];
        PDCTL2_PDNB11                  = (*PDCTL2    )["PDNB11"    ];
        PDCTL2_PDNB10                  = (*PDCTL2    )["PDNB10"    ];
        PDCTL2_PDNB09                  = (*PDCTL2    )["PDNB09"    ];
        PDCTL2_PDNB08                  = (*PDCTL2    )["PDNB08"    ];
        PDCTL2_PDNB07                  = (*PDCTL2    )["PDNB07"    ];
        PDCTL2_PDNB06                  = (*PDCTL2    )["PDNB06"    ];
        PDCTL2_PDNB05                  = (*PDCTL2    )["PDNB05"    ];
        PDCTL2_PDNB04                  = (*PDCTL2    )["PDNB04"    ];
        PDCTL2_PDNB03                  = (*PDCTL2    )["PDNB03"    ];
        PDCTL2_PDNB02                  = (*PDCTL2    )["PDNB02"    ];
        PDCTL2_PDNB01                  = (*PDCTL2    )["PDNB01"    ];
        PDCTL2_PDNB00                  = (*PDCTL2    )["PDNB00"    ];
        return;
    }
    if (addr == 0x0380) {
        SMPCR_SMPT                     = (*SMPCR     )["SMPT"      ];
        return;
    }
    if (addr == 0x0384) {
        TSNSMPCR_TSNSMPT               = (*TSNSMPCR  )["TSNSMPT"   ];
        return;
    }
    if (addr == 0x0388) {
        EMUCR_SVSDIS                   = (*EMUCR     )["SVSDIS"    ];
        return;
    }
    if (addr == 0x038C) {
        SGPRCR_SGPR4                   = (*SGPRCR    )["SGPR4"     ];
        SGPRCR_SGPR3                   = (*SGPRCR    )["SGPR3"     ];
        SGPRCR_SGPR2                   = (*SGPRCR    )["SGPR2"     ];
        SGPRCR_SGPR1                   = (*SGPRCR    )["SGPR1"     ];
        SGPRCR_SGPR0                   = (*SGPRCR    )["SGPR0"     ];
        return;
    }
    if (addr == 0x03C0) {
        TRMCR_TRMS                     = (*TRMCR     )["TRMS"      ];
        TRMCR_TRMDGSTBY                = (*TRMCR     )["TRMDGSTBY" ];
        TRMCR_TRMTSNTUNE               = (*TRMCR     )["TRMTSNTUNE"];
        TRMCR_TRMTTUNE                 = (*TRMCR     )["TRMTTUNE"  ];
        TRMCR_TRMBTUNE                 = (*TRMCR     )["TRMBTUNE"  ];
        TRMCR_TRMATUNE                 = (*TRMCR     )["TRMATUNE"  ];
        TRMCR_TRMTSN                   = (*TRMCR     )["TRMTSN"    ];
        TRMCR_TRMT                     = (*TRMCR     )["TRMT"      ];
        TRMCR_TRMB                     = (*TRMCR     )["TRMB"      ];
        TRMCR_TRMA                     = (*TRMCR     )["TRMA"      ];
        return;
    }
    if (addr == 0x03C4) {
        ADTSTRA_ADTST                  = (*ADTSTRA   )["ADTST"     ];
        return;
    }
    if (addr == 0x03C8) {
        ADTSTRB_ADVAL                  = (*ADTSTRB   )["ADVAL"     ];
        return;
    }
    if (addr == 0x03CC) {
        ADTSTRC_CKSTP                  = (*ADTSTRC   )["CKSTP"     ];
        ADTSTRC_SYNCERR                = (*ADTSTRC   )["SYNCERR"   ];
        ADTSTRC_ADMD8                  = (*ADTSTRC   )["ADMD8"     ];
        ADTSTRC_ADMD7                  = (*ADTSTRC   )["ADMD7"     ];
        ADTSTRC_ADMD6                  = (*ADTSTRC   )["ADMD6"     ];
        ADTSTRC_ADMD5                  = (*ADTSTRC   )["ADMD5"     ];
        ADTSTRC_ADMD4                  = (*ADTSTRC   )["ADMD4"     ];
        ADTSTRC_ADMD3                  = (*ADTSTRC   )["ADMD3"     ];
        ADTSTRC_ADMD                   = (*ADTSTRC   )["ADMD"      ];
        return;
    }
    if ((0x0440 <= addr) && (addr <= (0x0440)+(64*2)) && ((addr-0x0440)%64 == 0) && ChkAddrWithFactorIndex((addr-0x0440)/64 + 1, mFactorIndexSGSTCR, 3)) {
        uint i = (addr - 0x0440)/64 + 1;
        SGSTCR_SGSTn                  [i] = (*(SGSTCR    [i]))["SGSTn"     ];
        return;
    }
    if (addr == 0x0400) {
        TSNSGSTCR_TSNSGST              = (*TSNSGSTCR )["TSNSGST"   ];
        return;
    }
    if (addr == 0x0500) {
        PWDSGSTCR_PWDSGST              = (*PWDSGSTCR )["PWDSGST"   ];
        return;
    }
    if ((0x0448 <= addr) && (addr <= (0x0448)+(64*2)) && ((addr-0x0448)%64 == 0) && ChkAddrWithFactorIndex((addr-0x0448)/64 + 1, mFactorIndexSGCR, 3)) {
        uint i = (addr - 0x0448)/64 + 1;
        SGCR_SCANMD                   [i] = (*(SGCR      [i]))["SCANMD"    ];
        SGCR_ADIE                     [i] = (*(SGCR      [i]))["ADIE"      ];
        SGCR_SCT                      [i] = (*(SGCR      [i]))["SCT"       ];
        SGCR_TRGMD                    [i] = (*(SGCR      [i]))["TRGMD"     ];
        return;
    }
    if (addr == 0x0408) {
        TSNSGCR_TSNTRGMD               = (*TSNSGCR   )["TSNTRGMD"  ];
        return;
    }
    if (addr == 0x0508) {
        PWDSGCR_PWDTRGMD               = (*PWDSGCR   )["PWDTRGMD"  ];
        return;
    }
    if ((0x0458 <= addr) && (addr <= (0x0458)+(64*2)) && ((addr-0x0458)%64 == 0) && ChkAddrWithFactorIndex((addr-0x0458)/64 + 1, mFactorIndexSGSEFCR, 3)) {
        uint i = (addr - 0x0458)/64 + 1;
        SGSEFCR_SEFCn                 [i] = (*(SGSEFCR   [i]))["SEFCn"     ];
        return;
    }
    if (addr == 0x0418) {
        TSNSGSEFCR_TSNSEFC             = (*TSNSGSEFCR)["TSNSEFC"   ];
        return;
    }
    if (addr == 0x0518) {
        PWDSGSEFCR_PWDSEFC             = (*PWDSGSEFCR)["PWDSEFC"   ];
        return;
    }
    if ((0x044C <= addr) && (addr <= (0x044C)+(64*2)) && ((addr-0x044C)%64 == 0) && ChkAddrWithFactorIndex((addr-0x044C)/64 + 1, mFactorIndexSGVCSP, 3)) {
        uint i = (addr - 0x044C)/64 + 1;
        SGVCSP_VCSP                   [i] = (*(SGVCSP    [i]))["VCSP"      ];
        return;
    }
    if ((0x0450 <= addr) && (addr <= (0x0450)+(64*2)) && ((addr-0x0450)%64 == 0) && ChkAddrWithFactorIndex((addr-0x0450)/64 + 1, mFactorIndexSGVCEP, 3)) {
        uint i = (addr - 0x0450)/64 + 1;
        SGVCEP_VCEP                   [i] = (*(SGVCEP    [i]))["VCEP"      ];
        return;
    }
    if ((0x0454 <= addr) && (addr <= (0x0454)+(64*2)) && ((addr-0x0454)%64 == 0) && ChkAddrWithFactorIndex((addr-0x0454)/64 + 1, mFactorIndexSGMCYCR, 3)) {
        uint i = (addr - 0x0454)/64 + 1;
        SGMCYCR_MCYC                  [i] = (*(SGMCYCR   [i]))["MCYC"      ];
        return;
    }
    if ((0x045C <= addr) && (addr <= (0x045C)+(64*2)) && ((addr-0x045C)%64 == 0) && ChkAddrWithFactorIndex((addr-0x045C)/64 + 1, mFactorIndexSGTSEL, 3)) {
        uint i = (addr - 0x045C)/64 + 1;
        SGTSEL_TxSEL15                [i] = (*(SGTSEL    [i]))["TxSEL15"   ];
        SGTSEL_TxSEL14                [i] = (*(SGTSEL    [i]))["TxSEL14"   ];
        SGTSEL_TxSEL13                [i] = (*(SGTSEL    [i]))["TxSEL13"   ];
        SGTSEL_TxSEL12                [i] = (*(SGTSEL    [i]))["TxSEL12"   ];
        SGTSEL_TxSEL11                [i] = (*(SGTSEL    [i]))["TxSEL11"   ];
        SGTSEL_TxSEL10                [i] = (*(SGTSEL    [i]))["TxSEL10"   ];
        SGTSEL_TxSEL09                [i] = (*(SGTSEL    [i]))["TxSEL09"   ];
        SGTSEL_TxSEL08                [i] = (*(SGTSEL    [i]))["TxSEL08"   ];
        SGTSEL_TxSEL07                [i] = (*(SGTSEL    [i]))["TxSEL07"   ];
        SGTSEL_TxSEL06                [i] = (*(SGTSEL    [i]))["TxSEL06"   ];
        SGTSEL_TxSEL05                [i] = (*(SGTSEL    [i]))["TxSEL05"   ];
        SGTSEL_TxSEL04                [i] = (*(SGTSEL    [i]))["TxSEL04"   ];
        SGTSEL_TxSEL03                [i] = (*(SGTSEL    [i]))["TxSEL03"   ];
        SGTSEL_TxSEL02                [i] = (*(SGTSEL    [i]))["TxSEL02"   ];
        SGTSEL_TxSEL01                [i] = (*(SGTSEL    [i]))["TxSEL01"   ];
        SGTSEL_TxSEL00                [i] = (*(SGTSEL    [i]))["TxSEL00"   ];
        return;
    }
}

/// Check address for multiple registers
/// @return true/false
bool Csarad113x_regif::ChkAddrWithFactorIndex(cuint num, cuint factor_index[], cuint len)
{
    assert(factor_index != NULL);
    for (uint i = 0; i < len; i++) {
        if (num == factor_index[i]) {
            return true;
        }
    }
    return false;
}

/// Update local value to bit value
/// @return None
void Csarad113x_regif::UpdateRegVal(cuint addr)
{
    if ((0x0000 <= addr) && (addr <= (0x0000)+(4*49)) && ((addr-0x0000)%4 == 0)) {
        uint i = (addr - 0x0000)/4;
        (*(VCR       [i]))["MPXE"      ] = VCR_MPXE[i];
        (*(VCR       [i]))["MPXV"      ] = VCR_MPXV[i];
        if ((i >=33)&&(i<=35)){ // Modified by SonTran: VCR.CNVCLS only available on VCR33, VCR34, VCR35
            (*(VCR       [i]))["CNVCLS"    ] = VCR_CNVCLS[i];
        }
        (*(VCR       [i]))["ULS"       ] = VCR_ULS[i];
        (*(VCR       [i]))["ADIE"      ] = VCR_ADIE[i];
        (*(VCR       [i]))["GCTRL"     ] = VCR_GCTRL[i];
        return;
    }
    if (addr == 0x00F0) {
        (*TSNVCR    )["ULS"       ] = TSNVCR_ULS;
        (*TSNVCR    )["TSNGCTRL"  ] = TSNVCR_TSNGCTRL;
        return;
    }
    if (addr == 0x00F4) {
        (*PWDVCR    )["MPXE"      ] = PWDVCR_MPXE;
        (*PWDVCR    )["MPXV"      ] = PWDVCR_MPXV;
        (*PWDVCR    )["ULS"       ] = PWDVCR_ULS;
        (*PWDVCR    )["GCTRL"     ] = PWDVCR_GCTRL;
        return;
    }
    if ((0x0100 <= addr) && (addr <= (0x0100)+(4*24)) && ((addr-0x0100)%4 == 0)) {
        uint i = (addr - 0x0100)/4;
        // Modified by SonTran: Update bit name follow HWM
        std::ostringstream str_tmp;
        str_tmp.str("");
        if (i*2 < 10) { 
            str_tmp<<"DR0"<< i*2+1;
        }else{
            str_tmp<<"DR"<< i*2+1;
        }
        (*(DR        [i]))[str_tmp.str().c_str()] = DR_DR1[i];
        // Modified by SonTran: Update bit name follow HWM
        str_tmp.str("");
        if (i*2 < 10) { 
            str_tmp<<"DR0"<< i*2;
        }else{
            str_tmp<<"DR"<< i*2;
        }
        (*(DR        [i]))[str_tmp.str().c_str()] = DR_DR0[i];
        return;
    }
    if (addr == 0x0178) {
        (*PWDTSNDR  )["PWDDR"     ] = PWDTSNDR_PWDDR;
        (*PWDTSNDR  )["TSNDR"     ] = PWDTSNDR_TSNDR;
        return;
    }
    if ((0x0200 <= addr) && (addr <= (0x0200)+(4*49)) && ((addr-0x0200)%4 == 0)) {
        uint i = (addr - 0x0200)/4;
        (*(DIR       [i]))["MPXE"      ] = DIR_MPXE[i];
        (*(DIR       [i]))["MPXV"      ] = DIR_MPXV[i];
        (*(DIR       [i]))["WFLG"      ] = DIR_WFLG[i];
        (*(DIR       [i]))["ID"        ] = DIR_ID[i];
        std::ostringstream str_tmp;
        str_tmp.str("");
        if (i < 10) { 
            str_tmp<<"DR0"<< i;
        }else{
            str_tmp<<"DR"<< i;
        }
        (*(DIR       [i]))[str_tmp.str().c_str()] = DIR_DR[i];
        return;
    }
    if (addr == 0x02F0) {
        (*TSNDIR    )["WFLG"      ] = TSNDIR_WFLG;
        (*TSNDIR    )["ID"        ] = TSNDIR_ID;
        (*TSNDIR    )["TSNDR"     ] = TSNDIR_TSNDR;
        return;
    }
    if (addr == 0x02F4) {
        (*PWDDIR    )["MPXE"      ] = PWDDIR_MPXE;
        (*PWDDIR    )["MPXV"      ] = PWDDIR_MPXV;
        (*PWDDIR    )["WFLG"      ] = PWDDIR_WFLG;
        (*PWDDIR    )["ID"        ] = PWDDIR_ID;
        (*PWDDIR    )["PWDDR"     ] = PWDDIR_PWDDR;
        return;
    }
    if (addr == 0x0300) {
        (*ADHALTR   )["HALT"      ] = ADHALTR_HALT;
        return;
    }
    if (addr == 0x0304) {
        (*ADCR      )["DGON"      ] = ADCR_DGON;
        (*ADCR      )["TSNSELFDIAG"] = ADCR_TSNSELFDIAG;
        (*ADCR      )["CRAC"      ] = ADCR_CRAC;
        (*ADCR      )["CTYP"      ] = ADCR_CTYP;
        (*ADCR      )["SUSMTD"    ] = ADCR_SUSMTD;
        return;
    }
    if (addr == 0x0308) {
        (*SGSTR     )["SHACT"     ] = SGSTR_SHACT;
        (*SGSTR     )["SGACT"     ] = SGSTR_SGACT;
        (*SGSTR     )["SEF"       ] = SGSTR_SEF;
        return;
    }
    if (addr == 0x030C) {
        (*MPXCURR   )["MPXCUR"    ] = MPXCURR_MPXCUR;
        return;
    }
    if (addr == 0x0310) {
        (*TSNCR     )["TSNEN"     ] = TSNCR_TSNEN;
        return;
    }
    if (addr == 0x0314) {
        (*THSMPSTCR )["SMPST"     ] = THSMPSTCR_SMPST;
        return;
    }
    if (addr == 0x0318) {
        (*THCR      )["ASMPMSK"   ] = THCR_ASMPMSK;
        return;
    }
    if (addr == 0x031C) {
        (*THAHLDSTCR)["HLDST"     ] = THAHLDSTCR_HLDST;
        return;
    }
    if (addr == 0x0320) {
        (*THBHLDSTCR)["HLDST"     ] = THBHLDSTCR_HLDST;
        return;
    }
    if (addr == 0x0324) {
        (*THACR     )["HLDCTE"    ] = THACR_HLDCTE;
        (*THACR     )["HLDTE"     ] = THACR_HLDTE;
        (*THACR     )["SGS"       ] = THACR_SGS;
        return;
    }
    if (addr == 0x0328) {
        (*THBCR     )["HLDCTE"    ] = THBCR_HLDCTE;
        (*THBCR     )["HLDTE"     ] = THBCR_HLDTE;
        (*THBCR     )["SGS"       ] = THBCR_SGS;
        return;
    }
    if (addr == 0x032C) {
        (*THER      )["TH5E"      ] = THER_TH5E;
        (*THER      )["TH4E"      ] = THER_TH4E;
        (*THER      )["TH3E"      ] = THER_TH3E;
        (*THER      )["TH2E"      ] = THER_TH2E;
        (*THER      )["TH1E"      ] = THER_TH1E;
        (*THER      )["TH0E"      ] = THER_TH0E;
        return;
    }
    if (addr == 0x0330) {
        (*THGSR     )["TH5GS"     ] = THGSR_TH5GS;
        (*THGSR     )["TH4GS"     ] = THGSR_TH4GS;
        (*THGSR     )["TH3GS"     ] = THGSR_TH3GS;
        (*THGSR     )["TH2GS"     ] = THGSR_TH2GS;
        (*THGSR     )["TH1GS"     ] = THGSR_TH1GS;
        (*THGSR     )["TH0GS"     ] = THGSR_TH0GS;
        return;
    }
    if (addr == 0x0334) {
        (*SFTCR     )["RDCLRE"    ] = SFTCR_RDCLRE;
        (*SFTCR     )["ULEIE"     ] = SFTCR_ULEIE;
        (*SFTCR     )["OWEIE"     ] = SFTCR_OWEIE;
        return;
    }
    if ((0x0338 <= addr) && (addr <= (0x0338)+(4*2)) && ((addr-0x0338)%4 == 0)) {
        uint i = (addr - 0x0338)/4;
        (*(ULLMTBR   [i]))["ULMTB"     ] = ULLMTBR_ULMTB[i];
        (*(ULLMTBR   [i]))["LLMTB"     ] = ULLMTBR_LLMTB[i];
        return;
    }
    if (addr == 0x0344) {
        (*ECR       )["ULEC"      ] = ECR_ULEC;
        (*ECR       )["OWEC"      ] = ECR_OWEC;
        return;
    }
    if (addr == 0x0348) {
        (*ULER      )["UE"        ] = ULER_UE;
        (*ULER      )["LE"        ] = ULER_LE;
        (*ULER      )["ULSG"      ] = ULER_ULSG;
        (*ULER      )["MPXE"      ] = ULER_MPXE;
        (*ULER      )["MPXV"      ] = ULER_MPXV;
        (*ULER      )["ULE"       ] = ULER_ULE;
        (*ULER      )["ULECAP"    ] = ULER_ULECAP;
        return;
    }
    if (addr == 0x034C) {
        (*OWER      )["OWE"       ] = OWER_OWE;
        (*OWER      )["OWECAP"    ] = OWER_OWECAP;
        return;
    }
    if (addr == 0x0350) {
        (*DGCTL0    )["PSEL2"     ] = DGCTL0_PSEL2;
        (*DGCTL0    )["PSEL1"     ] = DGCTL0_PSEL1;
        (*DGCTL0    )["PSEL0"     ] = DGCTL0_PSEL0;
        return;
    }
    if (addr == 0x0354) {
        (*DGCTL1    )["CDG15"     ] = DGCTL1_CDG15;
        (*DGCTL1    )["CDG14"     ] = DGCTL1_CDG14;
        (*DGCTL1    )["CDG13"     ] = DGCTL1_CDG13;
        (*DGCTL1    )["CDG12"     ] = DGCTL1_CDG12;
        (*DGCTL1    )["CDG11"     ] = DGCTL1_CDG11;
        (*DGCTL1    )["CDG10"     ] = DGCTL1_CDG10;
        (*DGCTL1    )["CDG09"     ] = DGCTL1_CDG09;
        (*DGCTL1    )["CDG08"     ] = DGCTL1_CDG08;
        (*DGCTL1    )["CDG07"     ] = DGCTL1_CDG07;
        (*DGCTL1    )["CDG06"     ] = DGCTL1_CDG06;
        (*DGCTL1    )["CDG05"     ] = DGCTL1_CDG05;
        (*DGCTL1    )["CDG04"     ] = DGCTL1_CDG04;
        (*DGCTL1    )["CDG03"     ] = DGCTL1_CDG03;
        (*DGCTL1    )["CDG02"     ] = DGCTL1_CDG02;
        (*DGCTL1    )["CDG01"     ] = DGCTL1_CDG01;
        (*DGCTL1    )["CDG00"     ] = DGCTL1_CDG00;
        return;
    }
    if (addr == 0x0358) {
        (*PDCTL1    )["PDNA15"    ] = PDCTL1_PDNA15;
        (*PDCTL1    )["PDNA14"    ] = PDCTL1_PDNA14;
        (*PDCTL1    )["PDNA13"    ] = PDCTL1_PDNA13;
        (*PDCTL1    )["PDNA12"    ] = PDCTL1_PDNA12;
        (*PDCTL1    )["PDNA11"    ] = PDCTL1_PDNA11;
        (*PDCTL1    )["PDNA10"    ] = PDCTL1_PDNA10;
        (*PDCTL1    )["PDNA09"    ] = PDCTL1_PDNA09;
        (*PDCTL1    )["PDNA08"    ] = PDCTL1_PDNA08;
        (*PDCTL1    )["PDNA07"    ] = PDCTL1_PDNA07;
        (*PDCTL1    )["PDNA06"    ] = PDCTL1_PDNA06;
        (*PDCTL1    )["PDNA05"    ] = PDCTL1_PDNA05;
        (*PDCTL1    )["PDNA04"    ] = PDCTL1_PDNA04;
        (*PDCTL1    )["PDNA03"    ] = PDCTL1_PDNA03;
        (*PDCTL1    )["PDNA02"    ] = PDCTL1_PDNA02;
        (*PDCTL1    )["PDNA01"    ] = PDCTL1_PDNA01;
        (*PDCTL1    )["PDNA00"    ] = PDCTL1_PDNA00;
        return;
    }
    if (addr == 0x035C) {
        (*PDCTL2    )["PDNB19"    ] = PDCTL2_PDNB19;
        (*PDCTL2    )["PDNB18"    ] = PDCTL2_PDNB18;
        (*PDCTL2    )["PDNB17"    ] = PDCTL2_PDNB17;
        (*PDCTL2    )["PDNB16"    ] = PDCTL2_PDNB16;
        (*PDCTL2    )["PDNB15"    ] = PDCTL2_PDNB15;
        (*PDCTL2    )["PDNB14"    ] = PDCTL2_PDNB14;
        (*PDCTL2    )["PDNB13"    ] = PDCTL2_PDNB13;
        (*PDCTL2    )["PDNB12"    ] = PDCTL2_PDNB12;
        (*PDCTL2    )["PDNB11"    ] = PDCTL2_PDNB11;
        (*PDCTL2    )["PDNB10"    ] = PDCTL2_PDNB10;
        (*PDCTL2    )["PDNB09"    ] = PDCTL2_PDNB09;
        (*PDCTL2    )["PDNB08"    ] = PDCTL2_PDNB08;
        (*PDCTL2    )["PDNB07"    ] = PDCTL2_PDNB07;
        (*PDCTL2    )["PDNB06"    ] = PDCTL2_PDNB06;
        (*PDCTL2    )["PDNB05"    ] = PDCTL2_PDNB05;
        (*PDCTL2    )["PDNB04"    ] = PDCTL2_PDNB04;
        (*PDCTL2    )["PDNB03"    ] = PDCTL2_PDNB03;
        (*PDCTL2    )["PDNB02"    ] = PDCTL2_PDNB02;
        (*PDCTL2    )["PDNB01"    ] = PDCTL2_PDNB01;
        (*PDCTL2    )["PDNB00"    ] = PDCTL2_PDNB00;
        return;
    }
    if (addr == 0x0380) {
        (*SMPCR     )["SMPT"      ] = SMPCR_SMPT;
        return;
    }
    if (addr == 0x0384) {
        (*TSNSMPCR  )["TSNSMPT"   ] = TSNSMPCR_TSNSMPT;
        return;
    }
    if (addr == 0x0388) {
        (*EMUCR     )["SVSDIS"    ] = EMUCR_SVSDIS;
        return;
    }
    if (addr == 0x038C) {
        (*SGPRCR    )["SGPR4"     ] = SGPRCR_SGPR4;
        (*SGPRCR    )["SGPR3"     ] = SGPRCR_SGPR3;
        (*SGPRCR    )["SGPR2"     ] = SGPRCR_SGPR2;
        (*SGPRCR    )["SGPR1"     ] = SGPRCR_SGPR1;
        (*SGPRCR    )["SGPR0"     ] = SGPRCR_SGPR0;
        return;
    }
    if (addr == 0x03C0) {
        (*TRMCR     )["TRMS"      ] = TRMCR_TRMS;
        (*TRMCR     )["TRMDGSTBY" ] = TRMCR_TRMDGSTBY;
        (*TRMCR     )["TRMTSNTUNE"] = TRMCR_TRMTSNTUNE;
        (*TRMCR     )["TRMTTUNE"  ] = TRMCR_TRMTTUNE;
        (*TRMCR     )["TRMBTUNE"  ] = TRMCR_TRMBTUNE;
        (*TRMCR     )["TRMATUNE"  ] = TRMCR_TRMATUNE;
        (*TRMCR     )["TRMTSN"    ] = TRMCR_TRMTSN;
        (*TRMCR     )["TRMT"      ] = TRMCR_TRMT;
        (*TRMCR     )["TRMB"      ] = TRMCR_TRMB;
        (*TRMCR     )["TRMA"      ] = TRMCR_TRMA;
        return;
    }
    if (addr == 0x03C4) {
        (*ADTSTRA   )["ADTST"     ] = ADTSTRA_ADTST;
        return;
    }
    if (addr == 0x03C8) {
        (*ADTSTRB   )["ADVAL"     ] = ADTSTRB_ADVAL;
        return;
    }
    if (addr == 0x03CC) {
        (*ADTSTRC   )["CKSTP"     ] = ADTSTRC_CKSTP;
        (*ADTSTRC   )["SYNCERR"   ] = ADTSTRC_SYNCERR;
        (*ADTSTRC   )["ADMD8"     ] = ADTSTRC_ADMD8;
        (*ADTSTRC   )["ADMD7"     ] = ADTSTRC_ADMD7;
        (*ADTSTRC   )["ADMD6"     ] = ADTSTRC_ADMD6;
        (*ADTSTRC   )["ADMD5"     ] = ADTSTRC_ADMD5;
        (*ADTSTRC   )["ADMD4"     ] = ADTSTRC_ADMD4;
        (*ADTSTRC   )["ADMD3"     ] = ADTSTRC_ADMD3;
        (*ADTSTRC   )["ADMD"      ] = ADTSTRC_ADMD;
        return;
    }
    if ((0x0440 <= addr) && (addr <= (0x0440)+(64*2)) && ((addr-0x0440)%64 == 0) && ChkAddrWithFactorIndex((addr-0x0440)/64 + 1, mFactorIndexSGSTCR, 3)) {
        uint i = (addr - 0x0440)/64 + 1;
        (*(SGSTCR    [i]))["SGSTn"     ] = SGSTCR_SGSTn[i];
        return;
    }
    if (addr == 0x0400) {
        (*TSNSGSTCR )["TSNSGST"   ] = TSNSGSTCR_TSNSGST;
        return;
    }
    if (addr == 0x0500) {
        (*PWDSGSTCR )["PWDSGST"   ] = PWDSGSTCR_PWDSGST;
        return;
    }
    if ((0x0448 <= addr) && (addr <= (0x0448)+(64*2)) && ((addr-0x0448)%64 == 0) && ChkAddrWithFactorIndex((addr-0x0448)/64 + 1, mFactorIndexSGCR, 3)) {
        uint i = (addr - 0x0448)/64 + 1;
        (*(SGCR      [i]))["SCANMD"    ] = SGCR_SCANMD[i];
        (*(SGCR      [i]))["ADIE"      ] = SGCR_ADIE[i];
        (*(SGCR      [i]))["SCT"       ] = SGCR_SCT[i];
        (*(SGCR      [i]))["TRGMD"     ] = SGCR_TRGMD[i];
        return;
    }
    if (addr == 0x0408) {
        (*TSNSGCR   )["TSNTRGMD"  ] = TSNSGCR_TSNTRGMD;
        return;
    }
    if (addr == 0x0508) {
        (*PWDSGCR   )["PWDTRGMD"  ] = PWDSGCR_PWDTRGMD;
        return;
    }
    if ((0x0458 <= addr) && (addr <= (0x0458)+(64*2)) && ((addr-0x0458)%64 == 0) && ChkAddrWithFactorIndex((addr-0x0458)/64 + 1, mFactorIndexSGSEFCR, 3)) {
        uint i = (addr - 0x0458)/64 + 1;
        (*(SGSEFCR   [i]))["SEFCn"     ] = SGSEFCR_SEFCn[i];
        return;
    }
    if (addr == 0x0418) {
        (*TSNSGSEFCR)["TSNSEFC"   ] = TSNSGSEFCR_TSNSEFC;
        return;
    }
    if (addr == 0x0518) {
        (*PWDSGSEFCR)["PWDSEFC"   ] = PWDSGSEFCR_PWDSEFC;
        return;
    }
    if ((0x044C <= addr) && (addr <= (0x044C)+(64*2)) && ((addr-0x044C)%64 == 0) && ChkAddrWithFactorIndex((addr-0x044C)/64 + 1, mFactorIndexSGVCSP, 3)) {
        uint i = (addr - 0x044C)/64 + 1;
        (*(SGVCSP    [i]))["VCSP"      ] = SGVCSP_VCSP[i];
        return;
    }
    if ((0x0450 <= addr) && (addr <= (0x0450)+(64*2)) && ((addr-0x0450)%64 == 0) && ChkAddrWithFactorIndex((addr-0x0450)/64 + 1, mFactorIndexSGVCEP, 3)) {
        uint i = (addr - 0x0450)/64 + 1;
        (*(SGVCEP    [i]))["VCEP"      ] = SGVCEP_VCEP[i];
        return;
    }
    if ((0x0454 <= addr) && (addr <= (0x0454)+(64*2)) && ((addr-0x0454)%64 == 0) && ChkAddrWithFactorIndex((addr-0x0454)/64 + 1, mFactorIndexSGMCYCR, 3)) {
        uint i = (addr - 0x0454)/64 + 1;
        (*(SGMCYCR   [i]))["MCYC"      ] = SGMCYCR_MCYC[i];
        return;
    }
    if ((0x045C <= addr) && (addr <= (0x045C)+(64*2)) && ((addr-0x045C)%64 == 0) && ChkAddrWithFactorIndex((addr-0x045C)/64 + 1, mFactorIndexSGTSEL, 3)) {
        uint i = (addr - 0x045C)/64 + 1;
        (*(SGTSEL    [i]))["TxSEL15"   ] = SGTSEL_TxSEL15[i];
        (*(SGTSEL    [i]))["TxSEL14"   ] = SGTSEL_TxSEL14[i];
        (*(SGTSEL    [i]))["TxSEL13"   ] = SGTSEL_TxSEL13[i];
        (*(SGTSEL    [i]))["TxSEL12"   ] = SGTSEL_TxSEL12[i];
        (*(SGTSEL    [i]))["TxSEL11"   ] = SGTSEL_TxSEL11[i];
        (*(SGTSEL    [i]))["TxSEL10"   ] = SGTSEL_TxSEL10[i];
        (*(SGTSEL    [i]))["TxSEL09"   ] = SGTSEL_TxSEL09[i];
        (*(SGTSEL    [i]))["TxSEL08"   ] = SGTSEL_TxSEL08[i];
        (*(SGTSEL    [i]))["TxSEL07"   ] = SGTSEL_TxSEL07[i];
        (*(SGTSEL    [i]))["TxSEL06"   ] = SGTSEL_TxSEL06[i];
        (*(SGTSEL    [i]))["TxSEL05"   ] = SGTSEL_TxSEL05[i];
        (*(SGTSEL    [i]))["TxSEL04"   ] = SGTSEL_TxSEL04[i];
        (*(SGTSEL    [i]))["TxSEL03"   ] = SGTSEL_TxSEL03[i];
        (*(SGTSEL    [i]))["TxSEL02"   ] = SGTSEL_TxSEL02[i];
        (*(SGTSEL    [i]))["TxSEL01"   ] = SGTSEL_TxSEL01[i];
        (*(SGTSEL    [i]))["TxSEL00"   ] = SGTSEL_TxSEL00[i];
        return;
    }
}

/// convert string to vector
/// @return vector
std::vector<std::string> Csarad113x_regif::Str2Vec(std::string str, const char sep)
{
    std::vector<std::string> buf;
    std::string::size_type index = 0;
    for (uint i=0 ; i<str.size() ; i++) {
        if (str[i] == sep) {
            buf.push_back(str.substr(index, i-index));
            index = i+1;
        }
    }
    buf.push_back(str.substr(index));
    return buf;
}

/// Align nuber to hexadecimal format
/// @return aligned number
std::string Csarad113x_regif::Num2HexStr(cuint num, cuint num_length, bool space_strip, bool is_wr_data, uint acc_size)
{
    std::ostringstream str_tmp;
    #ifdef MSG_WO_WR_DATA
    str_tmp<<"0x"<<std::hex<<std::uppercase<<std::right<<num;
    str_tmp<<std::setfill(' ')<<std::setw(10-str_tmp.str().length())<<"";
    #else
    uint total_length = 0;
    acc_size = acc_size*8;
    if ((acc_size < num_length) && is_wr_data) {
        total_length = (acc_size + 3)/4; // Calculate number of hexadecimal number
    } else {
        total_length = (num_length + 3)/4; // Calculate number of hexadecimal number
    }
    str_tmp<<"0x"<<std::setfill('0')<<std::setw(total_length)<<std::hex<<std::uppercase<<std::right<<num;
    if (!space_strip) {
        str_tmp<<std::setfill(' ')<<std::setw(10-str_tmp.str().length())<<"";   
    }
    #endif
    return str_tmp.str();
}

/// Dump register access information
/// @return none
void Csarad113x_regif::DumpRegMsg(const std::string operation, const std::string RegName, const std::string BitName, cuint size, cuint addr, cuint wr_data, cuint pre_data, cuint data, cuint reg_length)
{
    if (mDumpRegisterRW) {
        std::string reg_name = RegName;
        std::ostringstream str_tmp;
        if (BitName != "") {
            reg_name += ":" + BitName;
        }
        str_tmp<<"REG ["<<std::setw(15)<<std::left<<reg_name<<"] ";
        str_tmp<<operation;
        str_tmp<<" Size= "<<size;
        str_tmp<<" Addr= "<<Num2HexStr(addr,11, false, false, size);
        if (operation == "R") {
            str_tmp<<" Data= "<<Num2HexStr(data    , reg_length, true, true, size);
        } else {
            #ifdef MSG_WO_WR_DATA
            str_tmp<<" Data= "<<Num2HexStr(pre_data, reg_length, false, false, size);
            #else
            str_tmp<<" Data= "<<Num2HexStr(wr_data , reg_length, false, true, size);
            str_tmp<<" : "    <<Num2HexStr(pre_data, reg_length, false, false, size);
            #endif
            str_tmp<<" => "   <<Num2HexStr(data    , reg_length, true, false, size);
        }
        re_printf("DumpRegMsg", "%s\n", str_tmp.str().c_str());
    }
}

/// find register pointer based on accessed address
/// @return accessed register pointer
int Csarad113x_regif::get_reg_index(cuint access_addr)
{
    if (mRegMap[access_addr] != (1<<11)) {
        return mRegMap[access_addr];
    } else {
        return -1;
    }
}

/// find first register pointer
/// @return first register pointer
vpcl::re_register *Csarad113x_regif::first_reg_object()
{
    mCurReg = mRegList;
    return mCurReg->my_p;
}

/// find next register pointer
/// @return next register pointer
vpcl::re_register *Csarad113x_regif::next_reg_object()
{
    if (mCurReg != NULL) {
        mCurReg = mCurReg->prev;
        if (mCurReg != NULL) {
            return mCurReg->my_p;
        }
    }
    return NULL;
}

/// write callback function of CoWare
/// @return none
void Csarad113x_regif::wr_cb(cuint addr, uint data)
{
    #ifdef CWR_SYSTEMC
    cwmem.put( (addr&0xFFFF), data);
    #else
    array[addr&0xFFFF] = data;
    #endif
}

/// read callback function of CoWare
/// @return read data
Csarad113x_regif::uint Csarad113x_regif::rd_cb(cuint addr)
{
    #ifdef CWR_SYSTEMC
    uint data=0;
    data = cwmem.get((addr&0xFFFF));
    return data;
    #else
    return array[addr&0xFFFF];
    #endif
}

/// print message function
/// @return none
void Csarad113x_regif::_re_printf(std::string group, const char *message, ...)
{
    // message group check
    if (group == "DumpRegMsg") {
        group = "info";
    } else {
        #ifndef REGIF_SC_REPORT
        if (!mMessageLevel[group]) return;
        #endif//REGIF_SC_REPORT
    }

    if (message == NULL) return;

    // print header
    #ifndef REGIF_NOT_USE_SYSTEMC
    std::stringstream t_stream;
    std::string cur_time;

    double tu_value = 0;
    std::string tu_name = "";
    if (sc_get_time_resolution() < sc_time(1, SC_PS)) {
        tu_value = 1000000000000000LL;
        tu_name = " fs";
    } else if (sc_get_time_resolution() < sc_time(1, SC_NS)) {
        tu_value = 1000000000000LL;
        tu_name = " ps";
    } else if (sc_get_time_resolution() < sc_time(1, SC_US)) {
        tu_value = 1000000000;
        tu_name = " ns";
    } else if (sc_get_time_resolution() < sc_time(1, SC_MS)) {
        tu_value = 1000000;
        tu_name = " us";
    } else if (sc_get_time_resolution() < sc_time(1, SC_SEC)) {
        tu_value = 1000;
        tu_name = " ms";
    } else {
        tu_value = 1;
        tu_name = " s";
    }
    t_stream << sc_time_stamp().value() * (uint64) (sc_get_time_resolution().to_seconds() * tu_value) << tu_name;

    cur_time = t_stream.str();
    #else
    std::string cur_time = "";
    #endif

    #ifndef REGIF_SC_REPORT
    #ifdef MSG_COLOR
    // color setting
    //
    // severity color       color Linux       Windows
    // fatal    RED         RED   \033[0;31m  FOREGROUND_RED
    // error    RED         BLUE  \033[0;34m  FOREGROUND_BLUE
    // warning  RED
    // info     BLUE
    #ifdef _WIN32
    HANDLE hStdout;
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    if (group == "fatal" || group == "error" || group == "warning") {
        SetConsoleTextAttribute(hStdout, FOREGROUND_RED);
    } else if (group == "info" ){
        SetConsoleTextAttribute(hStdout, FOREGROUND_BLUE);
    }
    #else
    if (group == "fatal" || group == "error" || group == "warning") {
        printf("\033[0;31m");
    } else if (group == "info" ){
        printf("\033[0;34m");
    }
    #endif
    #endif //MSG_COLOR
    printf("%8s [%20s] (%10s) ", group.c_str(), cur_time.c_str(), mInstName.c_str());
    #endif//REGIF_SC_REPORT

    // print body
    va_list argptr;
    va_start(argptr, message);
    if (argptr == NULL) return;
    #ifdef REGIF_SC_REPORT
    char str[1024];
    sprintf(str, "[%20s] ", cur_time.c_str());
    vsprintf(str+23, message, argptr);
    if (group == "fatal") {
        SC_REPORT_FATAL(mInstName.c_str(), str);
    } else if (group == "error") {
        SC_REPORT_ERROR(mInstName.c_str(), str);
    } else if (group == "warning") {
        SC_REPORT_WARNING(mInstName.c_str(), str);
    } else if (group == "info") {
        SC_REPORT_INFO(mInstName.c_str(), str);
    }
    #else //REGIF_SC_REPORT
    vprintf(message, argptr);
    #endif//REGIF_SC_REPORT

    #ifndef REGIF_SC_REPORT
    #ifdef DumpFileNameLineNum
    // print footer
    if (group == "fatal" || group == "error") {
        printf(" [%s:%d]\n", mFileName.c_str(), mLineNum);
    }
    #endif//DumpFileNameLineNum
    #endif//REGIF_SC_REPORT
    va_end(argptr);

    #ifndef REGIF_SC_REPORT
    #ifdef MSG_COLOR
    #ifdef _WIN32
    SetConsoleTextAttribute(hStdout, csbi.wAttributes);
    #else
    printf("\033[m");
    #endif
    #endif //MSG_COLOR
    #endif//REGIF_SC_REPORT

    fflush(stdout);
    fflush(stderr);

    if (group == "fatal") {
        exit(1);
    }
}

/// Get file name and line number
/// @return none
void Csarad113x_regif::get_fileline(std::string filename, int line_number)
{
    mFileName = filename;
    mLineNum  = line_number;
}

/// API for instance registration
/// @return none
void Csarad113x_regif::set_instance_name(std::string InstName)
{
    mInstName = InstName;
}

/// Method to change value of mIsReset
/// @return none
void Csarad113x_regif::EnableReset(const bool is_active)
{
    // update register IF class's reset status
    mIsReset = is_active;

    // update re_register's reset status
    for (uint i = 0; i < mTotalRegNum; i++) {
        mRegArray[i]->my_p->EnableReset(is_active);
        if (is_active) {
            re_printf("info", "Initialize %s (%08x)\n", mRegArray[i]->my_p->name().c_str(), (uint)(*mRegArray[i]->my_p));
        }
    }

    if (is_active) {
        InitLocalVal(); // Initialize local variable
    }
}

#ifdef CWR_SYSTEMC
uint Csarad113x_regif::cw_rd_cb(tlm::tlm_generic_payload& trans, int tag)
{
    int reg_index = get_reg_index((uint)tag);
    assert(reg_index != (1<<16));
    uint length = mRegArray[reg_index]->length;
    uint tmp_addr = (uint)tag;
    #ifdef IS_MODELED_ENDIAN_BIG
    if (length < mBusByteWidth) {
        tmp_addr = (uint)tag ^ (mBusByteWidth - length);
    }
    #endif
    unsigned char* ptr = (unsigned char*)trans.get_data_ptr();
    memset(ptr,0,sizeof(REG_TYPE));
    reg_rd_dbg(tmp_addr, ptr, length);
    return sizeof(REG_TYPE);
}

uint Csarad113x_regif::cw_wr_cb(tlm::tlm_generic_payload& trans, int tag)
{
    int reg_index = get_reg_index((uint)tag);
    assert(reg_index != (1<<16));
    uint length = mRegArray[reg_index]->length;
    uint tmp_addr = (uint)tag;
    #ifdef IS_MODELED_ENDIAN_BIG
    if (length < mBusByteWidth) {
        tmp_addr = (uint)tag ^ (mBusByteWidth - length);
    }
    #endif
    unsigned char* ptr = (unsigned char*)trans.get_data_ptr();
    reg_wr_dbg(tmp_addr, ptr, length);
    return sizeof(REG_TYPE);
}

void Csarad113x_regif::cw_set_all_callback_reg(void)
{
    for(uint indx=0; indx<mTotalRegNum; indx++){
        cw_set_callback_reg( mRegArray[indx]->my_cw_p, (unsigned int)mRegArray[indx]->my_p->addr());
    }
}
#endif
