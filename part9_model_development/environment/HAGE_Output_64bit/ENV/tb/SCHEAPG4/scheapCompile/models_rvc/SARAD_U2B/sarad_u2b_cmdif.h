// -----------------------------------------------------------------------------
// $Id$
//
// Copyright(c) 2020 Renesas Electronics Corporation
// Copyright(c) 2020 Renesas Design Vietnam Co., Ltd.
// RENESAS ELECTRONICS CONFIDENTIAL AND PROPRIETARY.
// This program must be used solely for the purpose for which
// it was furnished by Renesas Electronics Corporation. No part of this
// program may be reproduced or disclosed to others, in any
// form, without the prior written permission of Renesas Electronics
// Corporation.
// -----------------------------------------------------------------------------
// This file is generated by Command I/F generator (ver4.0)
//      $I
//      $Id$
//      $Id: modelinfo_parser.py,v 1.2 2011/03/17 05:08:51 sontran Exp
//
//
// Input file contents
//
//# -----------------------------------------------------------------------------
//# $Id$
//#
//# Copyright(c) 2020 Renesas Electronics Corporation
//# Copyright(c) 2020 Renesas Design Vietnam Co., Ltd.
//# RENESAS ELECTRONICS CONFIDENTIAL AND PROPRIETARY.
//# This program must be used solely for the purpose for which
//# it was furnished by Renesas Electronics Corporation. No part of this
//# program may be reproduced or disclosed to others, in any
//# form, without the prior written permission of Renesas Electronics
//# Corporation.
//# -----------------------------------------------------------------------------
//
//####################################################
//## For PORTs
//####################################################
//%MODULE sarad_u2b
//%HEADER_FILES sarad_u2b.h
//%IMPLEMENTATION_FILES sarad_u2b.cpp sarad_u2b_regif.cpp adc_u2b.cpp adc_u2b_regif.cpp
//#%PORT  pclk                          64        in        sc_dt::uint64
//#%PORT  ADCLK                         64        in        sc_dt::uint64
//#%PORT  CLKA_ADC                      64        in        sc_dt::uint64
//#%PORT  preset_n                      1         in        bool
//#%PORT  RESETAD_N                     1         in        bool
//#%PORT  preset2_n                     1         in        bool
//#%PORT  RESETAD2_N                    1         in        bool
//#%PORT  AVREFH0                       64        in        double
//#%PORT  AVREFH1                       64        in        double
//#%PORT  AVREFH2                       64        in        double
//#%PORT  AD0SG0TRG                     1         in        bool
//#%PORT  AD0SG1TRG                     1         in        bool
//#%PORT  AD0SG2TRG                     1         in        bool
//#%PORT  AD0SG3TRG                     1         in        bool
//#%PORT  AD0SG4TRG                     1         in        bool
//#%PORT  AD1SG0TRG                     1         in        bool
//#%PORT  AD1SG1TRG                     1         in        bool
//#%PORT  AD1SG2TRG                     1         in        bool
//#%PORT  AD1SG3TRG                     1         in        bool
//#%PORT  AD1SG4TRG                     1         in        bool
//#%PORT  AD2SG0TRG                     1         in        bool
//#%PORT  AD2SG1TRG                     1         in        bool
//#%PORT  AD2SG2TRG                     1         in        bool
//#%PORT  AD2SG3TRG                     1         in        bool
//#%PORT  AD2SG4TRG                     1         in        bool
//#%PORT  AD2TAUD2I7                    1         in        bool
//#%PORT  AD2TAUD2I15                   1         in        bool
//#%PORT  AD2TAUJ2                      1         in        bool
//#%PORT  AD2TAUJ3                      1         in        bool
//#%PORT  AD2LPS                        1         in        bool
//##%PORT  ADSTART_I                     1         in        bool
//##%PORT  ADSTART_O                     1         out       bool
//##%PORT  ADTSTART_I                    1         in        bool
//##%PORT  ADTSTART_O                    1         out       bool
//#%PORT  AN000                         64        in        double
//#%PORT  AN001                         64        in        double
//#%PORT  AN002                         64        in        double
//#%PORT  AN003                         64        in        double
//#%PORT  AN010                         64        in        double
//#%PORT  AN011                         64        in        double
//#%PORT  AN012                         64        in        double
//#%PORT  AN013                         64        in        double
//#%PORT  AN020                         64        in        double
//#%PORT  AN021                         64        in        double
//#%PORT  AN022                         64        in        double
//#%PORT  AN023                         64        in        double
//#%PORT  AN030                         64        in        double
//#%PORT  AN031                         64        in        double
//#%PORT  AN032                         64        in        double
//#%PORT  AN033                         64        in        double
//#%PORT  AN040                         64        in        double
//#%PORT  AN041                         64        in        double
//#%PORT  AN042                         64        in        double
//#%PORT  AN043                         64        in        double
//#%PORT  VMON_VCC                      64        in        double
//#%PORT  VMON_E0VCC                    64        in        double
//#%PORT  VMON_ISOVDD                   64        in        double
//#%PORT  VMON_AWOVDD                   64        in        double
//#%PORT  AN050                         64        in        double
//#%PORT  AN051                         64        in        double
//#%PORT  AN052                         64        in        double
//#%PORT  AN053                         64        in        double
//#%PORT  AN060                         64        in        double
//#%PORT  AN061                         64        in        double
//#%PORT  AN062                         64        in        double
//#%PORT  AN063                         64        in        double
//#%PORT  AN070                         64        in        double
//#%PORT  AN071                         64        in        double
//#%PORT  AN100                         64        in        double
//#%PORT  AN101                         64        in        double
//#%PORT  AN102                         64        in        double
//#%PORT  AN103                         64        in        double
//#%PORT  AN110                         64        in        double
//#%PORT  AN111                         64        in        double
//#%PORT  AN112                         64        in        double
//#%PORT  AN113                         64        in        double
//#%PORT  AN120                         64        in        double
//#%PORT  AN121                         64        in        double
//#%PORT  AN122                         64        in        double
//#%PORT  AN123                         64        in        double
//#%PORT  AN130                         64        in        double
//#%PORT  AN131                         64        in        double
//#%PORT  AN132                         64        in        double
//#%PORT  AN133                         64        in        double
//#%PORT  AN140                         64        in        double
//#%PORT  AN141                         64        in        double
//#%PORT  AN142                         64        in        double
//#%PORT  AN143                         64        in        double
//#%PORT  AN150                         64        in        double
//#%PORT  AN151                         64        in        double
//#%PORT  AN152                         64        in        double
//#%PORT  AN153                         64        in        double
//#%PORT  AN160                         64        in        double
//#%PORT  AN161                         64        in        double
//#%PORT  AN162                         64        in        double
//#%PORT  AN163                         64        in        double
//#%PORT  AN170                         64        in        double
//#%PORT  AN171                         64        in        double
//#%PORT  AN172                         64        in        double
//#%PORT  AN173                         64        in        double
//#%PORT  AN180                         64        in        double
//#%PORT  AN181                         64        in        double
//#%PORT  AN200                         64        in        double
//#%PORT  AN201                         64        in        double
//#%PORT  AN202                         64        in        double
//#%PORT  AN203                         64        in        double
//#%PORT  AN210                         64        in        double
//#%PORT  AN211                         64        in        double
//#%PORT  AN212                         64        in        double
//#%PORT  AN213                         64        in        double
//#%PORT  AN220                         64        in        double
//#%PORT  AN221                         64        in        double
//#%PORT  AN222                         64        in        double
//#%PORT  AN223                         64        in        double
//#%PORT  AN230                         64        in        double
//#%PORT  AN231                         64        in        double
//#%PORT  AN232                         64        in        double
//#%PORT  AN233                         64        in        double
//#%PORT  AN240                         64        in        double
//#%PORT  AN241                         64        in        double
//#%PORT  AN242                         64        in        double
//#%PORT  AN243                         64        in        double
//#%PORT  AN250                         64        in        double
//#%PORT  AN251                         64        in        double
//#%PORT  AN252                         64        in        double
//#%PORT  AN253                         64        in        double
//#%PORT  AN260                         64        in        double
//#%PORT  AN261                         64        in        double
//#%PORT  AN262                         64        in        double
//#%PORT  AN263                         64        in        double
//#%PORT  AN270                         64        in        double
//#%PORT  AN271                         64        in        double
//#%PORT  IFVCH0                        7         in        sc_uint
//#%PORT  IFVCH1                        7         in        sc_uint
//#%PORT  IFVCH2                        7         in        sc_uint
//#%PORT  IFRD0                         1         in        bool
//#%PORT  IFRD1                         1         in        bool
//#%PORT  IFRD2                         1         in        bool
//#%PORT  IFRE0                         1         in        bool
//#%PORT  IFRE1                         1         in        bool
//#%PORT  IFRE2                         1         in        bool
//#%PORT  INT_AD00                      1         out       bool
//#%PORT  INT_AD01                      1         out       bool
//#%PORT  INT_AD02                      1         out       bool
//#%PORT  INT_AD03                      1         out       bool
//#%PORT  INT_AD04                      1         out       bool
//#%PORT  INT_AD10                      1         out       bool
//#%PORT  INT_AD11                      1         out       bool
//#%PORT  INT_AD12                      1         out       bool
//#%PORT  INT_AD13                      1         out       bool
//#%PORT  INT_AD14                      1         out       bool
//#%PORT  INT_AD20                      1         out       bool
//#%PORT  INT_AD21                      1         out       bool
//#%PORT  INT_AD22                      1         out       bool
//#%PORT  INT_AD23                      1         out       bool
//#%PORT  INT_AD24                      1         out       bool
//#%PORT  INT_MPX0                      1         out       bool
//#%PORT  INT_MPX1                      1         out       bool
//#%PORT  INT_MPX2                      1         out       bool
//###%PORT  INT_ADE0                      1         out       bool
//###%PORT  INT_ADE1                      1         out       bool
//#%PORT  ADPE0                         1         out       bool
//#%PORT  ADPE1                         1         out       bool
//#%PORT  ADPE2                         1         out       bool
//#%PORT  ADEND00                       1         out       bool
//#%PORT  ADEND01                       1         out       bool
//#%PORT  ADEND02                       1         out       bool
//#%PORT  ADEND03                       1         out       bool
//#%PORT  ADEND04                       1         out       bool
//#%PORT  ADEND10                       1         out       bool
//#%PORT  ADEND11                       1         out       bool
//#%PORT  ADEND12                       1         out       bool
//#%PORT  ADEND13                       1         out       bool
//#%PORT  ADEND14                       1         out       bool
//#%PORT  ADEND20                       1         out       bool
//#%PORT  ADEND21                       1         out       bool
//#%PORT  ADEND22                       1         out       bool
//#%PORT  ADEND23                       1         out       bool
//#%PORT  ADEND24                       1         out       bool
//#%PORT  ULE_LPS0                      8         out       uint8_t
//#%PORT  ULE_LPS1                      8         out       uint8_t
//#%PORT  ULE_LPS2                      8         out       uint8_t
//#%PORT  INT_ERR0                      1         out       bool
//#%PORT  INT_ERR1                      1         out       bool
//#%PORT  INT_ERR2                      1         out       bool
//##%PORT  INT_UL0                       1         out       bool
//##%PORT  INT_UL1                       1         out       bool
//##%PORT  INT_SD0                       1         out       bool
//##%PORT  INT_SD1                       1         out       bool
//#%PORT  ADC0_IFDATA                   16        out       sc_uint
//#%PORT  ADC1_IFDATA                   16        out       sc_uint
//#%PORT  ADC2_IFDATA                   16        out       sc_uint
//#%PORT  DFREQ0                        1         out       bool
//#%PORT  DFREQ1                        1         out       bool
//#%PORT  DFREQ2                        1         out       bool
//##%PORT  ASREQ0                        1         out       bool
//##%PORT  ASREQ1                        1         out       bool
//#%PORT  DFTAG0                        4         out       sc_uint
//#%PORT  DFTAG1                        4         out       sc_uint
//#%PORT  DFTAG2                        4         out       sc_uint
//#%PORT  DFDATA0                       16        out       sc_uint
//#%PORT  DFDATA1                       16        out       sc_uint
//#%PORT  DFDATA2                       16        out       sc_uint
//#%PORT  PVCR_VALUE0                   32        in        uint32_t
//#%PORT  PVCR_VALUE1                   32        in        uint32_t
//#%PORT  PVCR_VALUE2                   32        in        uint32_t
//#%PORT  PVCR_TRG0                     1         in        bool
//#%PORT  PVCR_TRG1                     1         in        bool
//#%PORT  PVCR_TRG2                     1         in        bool
//#%PORT  PVCR_END0                     1         in        bool
//#%PORT  PVCR_END1                     1         in        bool
//#%PORT  PVCR_END2                     1         in        bool
//#%PORT  PVCR_PWDDR0                   16        in        uint16_t
//#%PORT  PVCR_PWDDR1                   16        in        uint16_t
//#%PORT  PVCR_PWDDR2                   16        in        uint16_t
//#%PORT  *VCEND0[96]                   1         out       bool
//#%PORT  PWM_VCEND0                    1         out       bool
//#%PORT  VCULMO0                       1         out       bool
//#%PORT  VCLLMO0                       1         out       bool
//#%PORT  *VCEND1[96]                   1         out       bool
//#%PORT  PWM_VCEND1                    1         out       bool
//#%PORT  VCULMO1                       1         out       bool
//#%PORT  VCLLMO1                       1         out       bool
//#%PORT  *VCEND2[96]                   1         out       bool
//#%PORT  PWM_VCEND2                    1         out       bool
//#%PORT  VCULMO2                       1         out       bool
//#%PORT  VCLLMO2                       1         out       bool
//#%PORT  MPXCUR0                       3         out       sc_uint
//#%PORT  MPXCUR1                       3         out       sc_uint
//#%PORT  MPXCUR2                       3         out       sc_uint
//#%PORT  SV_MODE                       1         in        bool
//
//####################################################
//## For Registers
//####################################################
//%MODULE sarad_u2b
//    #              name     offset_size  
//    %%REG_INSTANCE reg_def  11           
//
//%REG_CHANNEL   reg_def
//     %%TITLE    name        reg_name     wsize     rsize     length   offset   factor_start   factor_end    factor_index    factor_step  init        access  support  callback
//     %%REG      ADSYNSTCR   ADSYNSTCR    8|16|32   8|16|32   8        0x610    -              -             -               -            0           W|R     TRUE     -
//     %%REG      ADTSYNSTCR  ADTSYNSTCR   8|16|32   8|16|32   8        0x614    -              -             -               -            0           W|R     TRUE     - 
//     %%REG      VMONVDCR1   VMONVDCR1    8|16|32   8|16|32   8        0x740    -              -             -               -            0           W|R     TRUE     -
//     %%REG      VMONVDCR2   VMONVDCR2    8|16|32   8|16|32   8        0x744    -              -             -               -            0           W|R     TRUE     - 
//
//%REG_NAME  ADSYNSTCR 
//   %%TITLE     name       upper   lower     init    access      support     callback    
//   %%BIT       ADSTART    0        0        0       W|R         TRUE        W
//
//%REG_NAME  ADTSYNSTCR
//   %%TITLE     name       upper   lower     init    access      support     callback    
//   %%BIT       ADTSTART   0        0        0       W|R         TRUE        W
//
//%REG_NAME  VMONVDCR1
//   %%TITLE     name       upper   lower     init    access      support     callback  
//   %%BIT       VDE1       0       0         0       W|R         TRUE        W
//
//%REG_NAME  VMONVDCR2
//   %%TITLE     name       upper   lower     init    access      support     callback 
//   %%BIT       VDE2       0       0         0       W|R         TRUE        W
//
//####################################################
//## For command I/F
//####################################################
//%CMD_BASEID  tgt reg
//%CMD_NODUMP_API EnableInsertInput EnableDumpResult DumpProfile ClearProfile AssertReset
//%CMD_RW DumpInterrupt      <enable: bool=false>             @ Display interrupt information when interrupt get set[ns]
//%CMD_RW EnableConvertInfo  <enable: bool=false>             @ Display AD convert activity
//
//%CMD_RW Avrefh0_Val        <Avrefh0: double=3.3>            @ Reference voltage of AVREFH0
//%CMD_RW Avrefh1_Val        <Avrefh1: double=3.3>            @ Reference voltage of AVREFH1
//%CMD_RW Avrefh2_Val        <Avrefh2: double=3.3>            @ Reference voltage of AVREFH2
//%CMD_RW Avrefh3_Val        <Avrefh3: double=3.3>            @ Reference voltage of AVREFH3 
//%CMD_RW AVcc0              <AVcc0: double=3.3>              @ Reference voltage of AVCC0
//%CMD_RW AVcc1              <AVcc1: double=3.3>              @ Reference voltage of AVCC1
//%CMD_RW AVcc2              <AVcc2: double=3.3>              @ Reference voltage of AVCC2
//%CMD_RW AVcc3              <AVcc3: double=3.3>              @ Reference voltage of AVCC3
//#%CMD_RW EVcc0              <EVcc0: double=3.3>              @ Reference voltage of EVCC0
//#%CMD_RW EVcc1              <EVcc1: double=3.3>              @ Reference voltage of EVCC1
//#%CMD_RW EVcc2              <EVcc2: double=3.3>              @ Reference voltage of EVCC2
//
//%CMD_RW tTSPL              <tTSPL: double=27>               @ Number of sampling cycles in T&H circuit (AD clock)
//%CMD_RW tTHSD              <tTHSD: double=5>                @ Delay time from detecting a hold trigger until starting to hold an analog input (AD clock)
//%CMD_RW tTHLD              <tTHLD: double=10>               @ Delay time from starting to hold an analog input until starting AD conversion (AD clock)
//%CMD_RW ExSmpt             <ExSmpt: unsigned int=60>        @ Default number of extended sampling cycles in AD conversion (AD clock)
//%CMD_RW Smpt               <Smpt: unsigned int=18>          @ Default number of sampling cycles in AD conversion (AD clock)
//%CMD_RW tSAR               <tSAR: double=0>                 @ Successive approximation AD convert cycle (AD clock)
//%CMD_RW tD                 <tD: double=0>                   @ Delay time until starting scan group (APB clock)
//%CMD_RW tED                <tED: double=0>                  @ Delay time until complete scan group (APB clock)
//
//%CMD_RW ForcedIdError0     <enable: bool=false>             @ The ID error occurs forcibly into ADCK0 when writting DRn
//%CMD_RW ForcedIdError1     <enable: bool=false>             @ The ID error occurs forcibly into ADCK1 when writting DRn
//%CMD_RW ForcedIdError2     <enable: bool=false>             @ The ID error occurs forcibly into ADCK2 when writting DRn
//%CMD_RW ForcedIdError3     <enable: bool=false>             @ The ID error occurs forcibly into ADCK3 when writting DRn
//%CMD_RW ForcedIdErrorA     <enable: bool=false>             @ The ID error occurs forcibly into ADCKA when writting DRn
//%CMD_RW ForcedParityError0 <enable: bool=false>             @ The parity error occurs forcibly into ADCK0 when reading DRn or DIRn
//%CMD_RW ForcedParityError1 <enable: bool=false>             @ The parity error occurs forcibly into ADCK1 when reading DRn or DIRn
//%CMD_RW ForcedParityError2 <enable: bool=false>             @ The parity error occurs forcibly into ADCK2 when reading DRn or DIRn
//%CMD_RW ForcedParityError3 <enable: bool=false>             @ The parity error occurs forcibly into ADCK3 when reading DRn or DIRn
//%CMD_RW ForcedParityErrorA <enable: bool=false>             @ The parity error occurs forcibly into ADCKA when reading DRn or DIRn
//%CMD_RW ForcedOpenError0   <enable: bool=false>             @ The open circuit error occurs forcibly into ADCK0 when VCRn.PUE or PDE is 1
//%CMD_RW ForcedOpenError1   <enable: bool=false>             @ The open circuit error occurs forcibly into ADCK1 when VCRn.PUE or PDE is 1
//%CMD_RW ForcedOpenError2   <enable: bool=false>             @ The open circuit error occurs forcibly into ADCK2 when VCRn.PUE or PDE is 1
//%CMD_RW ForcedOpenError3   <enable: bool=false>             @ The open circuit error occurs forcibly into ADCK3 when VCRn.PUE or PDE is 1
//%CMD_RW ForcedOpenErrorA   <enable: bool=false>             @ The open circuit error occurs forcibly into ADCKA when VCRn.PUE or PDE is 1
//%CMD_RW ForcedBreak0       <enable: bool=false>             @ The break circuit error occurs forcibly into ADCK0 when ODCR.ODDE = 1
//%CMD_RW ForcedBreak1       <enable: bool=false>             @ The break circuit error occurs forcibly into ADCK1 when ODCR.ODDE = 1
//%CMD_RW ForcedBreak2       <enable: bool=false>             @ The break circuit error occurs forcibly into ADCK2 when ODCR.ODDE = 1
//%CMD_RW ForcedBreak3       <enable: bool=false>             @ The break circuit error occurs forcibly into ADCK3 when ODCR.ODDE = 1
//%CMD_RW ForcedBreakA       <enable: bool=false>             @ The break circuit error occurs forcibly into ADCKA when ODCR.ODDE = 1
//%CMD_RW ForcedDataPathError0       <enable: bool=false>             @ The data path error occurs forcibly into ADCK0
//%CMD_RW ForcedDataPathError1       <enable: bool=false>             @ The data path error occurs forcibly into ADCK1
//%CMD_RW ForcedDataPathError2       <enable: bool=false>             @ The data path error occurs forcibly into ADCK2
//%CMD_RW ForcedDataPathError3       <enable: bool=false>             @ The data path error occurs forcibly into ADCK3
//%CMD_RW ForcedDataPathErrorA       <enable: bool=false>             @ The data path error occurs forcibly into ADCKA
//
//#%CMD_RW StartAddrADCA0     <addr: unsigned int=0x1000>      @ The start address of ADCK0 module
//#%CMD_RW StartAddrADCA1     <addr: unsigned int=0x2000>      @ The start address of ADCK1 module
//#%CMD_RW StartAddrADCA2     <addr: unsigned int=0x3000>      @ The start address of ADCK2 module
//#%CMD_RW StartAddrADCA3     <addr: unsigned int=0x2000>      @ The start address of ADCK3 module
//#%CMD_RW StartAddrADCAA     <addr: unsigned int=0x3000>      @ The start address of ADCKA module
//#%CMD_RW EndAddressADCA0    <addr: unsigned int=0x1FFF>      @ The end address of ADCK0 module
//#%CMD_RW EndAddressADCA1    <addr: unsigned int=0x2FFF>      @ The end address of ADCK1 module
//#%CMD_RW EndAddressADCA2    <addr: unsigned int=0x3FFF>      @ The end address of ADCK2 module
//#%CMD_RW EndAddressADCA1    <addr: unsigned int=0x2FFF>      @ The end address of ADCK1 module
//#%CMD_RW EndAddressADCA2    <addr: unsigned int=0x3FFF>      @ The end address of ADCK2 module
//#%CMD_RW OffsetAddMask      <addr: unsigned int=0x7FFF>      @ The offset address mask
//
//%CMD_RW EnableTimeCalculation   <enable: bool=true>         @ Enable using formula to calculate the delay times
//
//%CMD_RW AVccMax            <AVccMax: double=3.6>            @ The maximum value of AVCCm
//%CMD_RW AVccMin            <AVccMin: double=3>              @ The minimum value of AVCCm
//%CMD_RW EVccMax            <EVccMax: double=3.6>            @ The maximum value of EVCCm
//%CMD_RW EVccMin            <EVccMin: double=3>              @ The minimum value of EVCCm
//%CMD_RW AvrefhMin          <AvrefhMin: double=3>            @ The minimum value of Avrefhm
//
//%CMD_ACTION DumpStatInfo : void @ Dump the statistical information about SAR model activity
//%CMD_ACTION SetCLKfreq <clk_name: std::string> <clk_freq: double>: void @ Setup the new clock frequency
//%CMD_ACTION AssertPReset <start_time: double> <period: double>: void @ Assert preset_n for ADC0, ADC1, ADC2 and ADC3
//%CMD_ACTION AssertADReset <start_time: double> <period: double>: void @ Assert RESETAD_N for ADC0, ADC1, ADC2 and ADC3
//%CMD_ACTION AssertPResetA <start_time: double> <period: double>: void @ Assert preset_n for ADCKA
//%CMD_ACTION AssertADResetA <start_time: double> <period: double>: void @ Assert RESETAD_N for ADCKA
//%CMD_ACTION AssignTHCircuit <adc_index: unsigned int> <th_channel: unsigned int> <group_channel: unsigned int> <physic_channel: unsigned int>: void @ Assign the T&H channel to corresponding analog channel
//

#ifndef SARAD_U2B_CMDIF_H
#define SARAD_U2B_CMDIF_H

public:
std::string handleCommand (const std::vector<std::string>& args)
{
  std::vector<std::string> _args = args;
  std::string ret = "";

  if (args[0] == "command") {
    _args.erase(_args.begin());
    ret = this->own_handle_command(_args);
    if (ret != "") {
      ret += "\n";
    }
#if 1 // CommandCB
    // call call back funcion only when return message does not include error keyword
    if (ret.find("is invalid") == std::string::npos    // defined command
     && ret.find("Error") == std::string::npos) {      // correct argument
      std::string cb_msg = this->CommandCB(args);
      if (cb_msg.find("error") != std::string::npos) { // correct usage
        ret += cb_msg + "\n";
      }
    }
#endif // CommandCB
  }
  else if (_args[0] == "tgt") {
    ret = this->tgt_handle_command(_args);
    if (ret != "") {
      ret += "\n";
    }
  }
  else if (_args[0] == "reg") {
    ret = this->regif_handle_command(_args);
    if (ret != "") {
      ret += "\n";
    }
  }

  // send a command to all targets
  else {
    bool cmd_found = false;
    std::string baseid_message;

    baseid_message = this->own_handle_command(_args);
    if (baseid_message.find("is invalid", 0) == std::string::npos) { // defined command
      cmd_found = true;
      if (baseid_message != "") {
        ret += baseid_message + "\n";
      }
#if 1 // CommandCB
      // call call back funcion only when return message does not include error keyword
    if (ret.find("is invalid") == std::string::npos      // defined command
     && ret.find("Error") == std::string::npos) {        // correct argument
        std::string cb_msg = this->CommandCB(args);
        if (cb_msg.find("error") != std::string::npos) { // correct usage
          ret += cb_msg + "\n";
        }
      }
#endif // CommandCB
    }

    _args.insert(_args.begin(), "tgt");
    baseid_message = this->tgt_handle_command(_args);
    if (baseid_message.find("is invalid", 0) == std::string::npos) {
      cmd_found = true;
      if (baseid_message != "") {
        ret += baseid_message;
      }
    }
    _args.erase(_args.begin());

    _args.insert(_args.begin(), "reg");
    baseid_message = this->regif_handle_command(_args);
    if (baseid_message.find("is invalid", 0) == std::string::npos) {
      cmd_found = true;
      if (baseid_message != "") {
        ret += baseid_message;
      }
    }
    _args.erase(_args.begin());

    if (!cmd_found) {
      ret = "Error (" + mInstName + ") command name \"" + _args[0] + "\" is invalid.\n";
    }
  }
  
  // Insert input command
#if 0 // EnableInsertInput
  if (mEnableInsertInput) {
    std::string header_str = "(" + mInstName + + ":" + mCmdId + ") [ ";
    for (unsigned int i=0 ; i<args.size() ; i++) {
      header_str += (std::string)args[i] + " ";
    }
    header_str += "]";
    ret = header_str + "\n" + ret;
  }
#endif // EnableInsertInput

#if 0 // EnableDumpResult
  if (mEnableDumpResult && mCmdId == "self") {
    printf("%s", ret.c_str());
  }
#endif // EnableDumpResult
  return ret;
}

#if 0 // HWBreak
void setCommandHandler(vpcl::commandHandler * handler) {
  if (handler == NULL) return;
  cmd_handler = handler;
}
void hw_break(std::string break_name) {
  // if specified break point is enable, have commandHandler read a script file
  if (mBreakTable.find(break_name) != mBreakTable.end()) {
    cmd_handler->handleCommand();
  }
}
#endif // HWBreak

private:
std::string own_handle_command(std::vector<std::string>& args)
{
  std::string ret = "";
  std::string err_msg = "Error ("   + mInstName + ") ";   // error message

  std::string specified_cmd = " (";
  std::vector<std::string>::iterator cmd_it;
  for (cmd_it=args.begin() ; cmd_it!=args.end() ; cmd_it++) {
    specified_cmd += " " + *cmd_it;
  }
  specified_cmd += " ) : Type " + mInstName + " help";

  if ((int)args.size() <= 0) {
      ret = err_msg + "command name \"\" is invalid.";
      return ret;
  }

  if (args[0] == "help") {
    ret += "    --- command ---\n";
    ret += "    help                                      Show direction\n";
#if 0 // HWBreak
    ret += "    go                                        (Re)Start the simulation\n";
    ret += "    HWBreak <break-name>                      Enable specified break point (Defailt: none)\n";
#endif // HWBreak
#if 1 // MessageLevel
    ret += "    MessageLevel   <fatal|error|warning|info> Select debug message level (Default: fatal,error)\n";
#endif // MessageLevel
#if 0 // EnableInsertInput
    ret += "    EnableInsertInput <true/false>            Display typed command (Default: false)\n";
#endif // EnableInsertInput
#if 0 // DumpProfile
    ret += "    DumpProfile [file_name] [time_unit]       Dump profile information (Default: file_name=stdout, time_unit=SC_NS)\n";
#endif // DumpProfile
#if 0 // ClearProfile
    ret += "    ClearProfile                              Reset profile internal information\n";
#endif // ClearProfile
#if 0 // AssertReset
    ret += "    AssertReset <start_time> <period>         Assert and deassert reset signal to a target model\n";
#endif // AssertReset
#if 0 // EnableDumpResult
    ret += "    EnableDumpResult <status>                 Dump a command return string into standard output too\n";
#endif // EnableDumpResult
    ret += "    DumpInterrupt <enable>                    Display interrupt information when interrupt get set[ns] ( Default:false  )\n";
    ret += "    EnableConvertInfo <enable>                Display AD convert activity ( Default:false  )\n";
    ret += "    Avrefh0_Val <Avrefh0>                     Reference voltage of AVREFH0 ( Default:3.3  )\n";
    ret += "    Avrefh1_Val <Avrefh1>                     Reference voltage of AVREFH1 ( Default:3.3  )\n";
    ret += "    Avrefh2_Val <Avrefh2>                     Reference voltage of AVREFH2 ( Default:3.3  )\n";
    ret += "    Avrefh3_Val <Avrefh3>                     Reference voltage of AVREFH3 ( Default:3.3  )\n";
    ret += "    AVcc0 <AVcc0>                             Reference voltage of AVCC0 ( Default:3.3  )\n";
    ret += "    AVcc1 <AVcc1>                             Reference voltage of AVCC1 ( Default:3.3  )\n";
    ret += "    AVcc2 <AVcc2>                             Reference voltage of AVCC2 ( Default:3.3  )\n";
    ret += "    AVcc3 <AVcc3>                             Reference voltage of AVCC3 ( Default:3.3  )\n";
    ret += "    tTSPL <tTSPL>                             Number of sampling cycles in T&H circuit (AD clock) ( Default:27  )\n";
    ret += "    tTHSD <tTHSD>                             Delay time from detecting a hold trigger until starting to hold an analog input (AD clock) ( Default:5  )\n";
    ret += "    tTHLD <tTHLD>                             Delay time from starting to hold an analog input until starting AD conversion (AD clock) ( Default:10  )\n";
    ret += "    ExSmpt <ExSmpt>                           Default number of extended sampling cycles in AD conversion (AD clock) ( Default:60  )\n";
    ret += "    Smpt <Smpt>                               Default number of sampling cycles in AD conversion (AD clock) ( Default:18  )\n";
    ret += "    tSAR <tSAR>                               Successive approximation AD convert cycle (AD clock) ( Default:0  )\n";
    ret += "    tD <tD>                                   Delay time until starting scan group (APB clock) ( Default:0  )\n";
    ret += "    tED <tED>                                 Delay time until complete scan group (APB clock) ( Default:0  )\n";
    ret += "    ForcedIdError0 <enable>                   The ID error occurs forcibly into ADCK0 when writting DRn ( Default:false  )\n";
    ret += "    ForcedIdError1 <enable>                   The ID error occurs forcibly into ADCK1 when writting DRn ( Default:false  )\n";
    ret += "    ForcedIdError2 <enable>                   The ID error occurs forcibly into ADCK2 when writting DRn ( Default:false  )\n";
    ret += "    ForcedIdError3 <enable>                   The ID error occurs forcibly into ADCK3 when writting DRn ( Default:false  )\n";
    ret += "    ForcedIdErrorA <enable>                   The ID error occurs forcibly into ADCKA when writting DRn ( Default:false  )\n";
    ret += "    ForcedParityError0 <enable>               The parity error occurs forcibly into ADCK0 when reading DRn or DIRn ( Default:false  )\n";
    ret += "    ForcedParityError1 <enable>               The parity error occurs forcibly into ADCK1 when reading DRn or DIRn ( Default:false  )\n";
    ret += "    ForcedParityError2 <enable>               The parity error occurs forcibly into ADCK2 when reading DRn or DIRn ( Default:false  )\n";
    ret += "    ForcedParityError3 <enable>               The parity error occurs forcibly into ADCK3 when reading DRn or DIRn ( Default:false  )\n";
    ret += "    ForcedParityErrorA <enable>               The parity error occurs forcibly into ADCKA when reading DRn or DIRn ( Default:false  )\n";
    ret += "    ForcedOpenError0 <enable>                 The open circuit error occurs forcibly into ADCK0 when VCRn.PUE or PDE is 1 ( Default:false  )\n";
    ret += "    ForcedOpenError1 <enable>                 The open circuit error occurs forcibly into ADCK1 when VCRn.PUE or PDE is 1 ( Default:false  )\n";
    ret += "    ForcedOpenError2 <enable>                 The open circuit error occurs forcibly into ADCK2 when VCRn.PUE or PDE is 1 ( Default:false  )\n";
    ret += "    ForcedOpenError3 <enable>                 The open circuit error occurs forcibly into ADCK3 when VCRn.PUE or PDE is 1 ( Default:false  )\n";
    ret += "    ForcedOpenErrorA <enable>                 The open circuit error occurs forcibly into ADCKA when VCRn.PUE or PDE is 1 ( Default:false  )\n";
    ret += "    ForcedBreak0 <enable>                     The break circuit error occurs forcibly into ADCK0 when ODCR.ODDE = 1 ( Default:false  )\n";
    ret += "    ForcedBreak1 <enable>                     The break circuit error occurs forcibly into ADCK1 when ODCR.ODDE = 1 ( Default:false  )\n";
    ret += "    ForcedBreak2 <enable>                     The break circuit error occurs forcibly into ADCK2 when ODCR.ODDE = 1 ( Default:false  )\n";
    ret += "    ForcedBreak3 <enable>                     The break circuit error occurs forcibly into ADCK3 when ODCR.ODDE = 1 ( Default:false  )\n";
    ret += "    ForcedBreakA <enable>                     The break circuit error occurs forcibly into ADCKA when ODCR.ODDE = 1 ( Default:false  )\n";
    ret += "    ForcedDataPathError0 <enable>             The data path error occurs forcibly into ADCK0 ( Default:false  )\n";
    ret += "    ForcedDataPathError1 <enable>             The data path error occurs forcibly into ADCK1 ( Default:false  )\n";
    ret += "    ForcedDataPathError2 <enable>             The data path error occurs forcibly into ADCK2 ( Default:false  )\n";
    ret += "    ForcedDataPathError3 <enable>             The data path error occurs forcibly into ADCK3 ( Default:false  )\n";
    ret += "    ForcedDataPathErrorA <enable>             The data path error occurs forcibly into ADCKA ( Default:false  )\n";
    ret += "    EnableTimeCalculation <enable>            Enable using formula to calculate the delay times ( Default:true  )\n";
    ret += "    AVccMax <AVccMax>                         The maximum value of AVCCm ( Default:3.6  )\n";
    ret += "    AVccMin <AVccMin>                         The minimum value of AVCCm ( Default:3  )\n";
    ret += "    EVccMax <EVccMax>                         The maximum value of EVCCm ( Default:3.6  )\n";
    ret += "    EVccMin <EVccMin>                         The minimum value of EVCCm ( Default:3  )\n";
    ret += "    AvrefhMin <AvrefhMin>                     The minimum value of Avrefhm ( Default:3  )\n";
    ret += "    DumpStatInfo                              Dump the statistical information about SAR model activity\n";
    ret += "    SetCLKfreq <clk_name> <clk_freq>          Setup the new clock frequency\n";
    ret += "    AssertPReset <start_time> <period>        Assert preset_n for ADC0, ADC1, ADC2 and ADC3\n";
    ret += "    AssertADReset <start_time> <period>       Assert RESETAD_N for ADC0, ADC1, ADC2 and ADC3\n";
    ret += "    AssertPResetA <start_time> <period>       Assert preset_n for ADCKA\n";
    ret += "    AssertADResetA <start_time> <period>      Assert RESETAD_N for ADCKA\n";
    ret += "    AssignTHCircuit <adc_index> <th_channel> <group_channel> <physic_channel>\n";
    ret += "                                              Assign the T&H channel to corresponding analog channel\n";

  }
#if 1 // MessageLevel
  else if (args[0] == "MessageLevel") {
    // read mode
    if ((int)args.size() == 1) {
      std::map<std::string, bool>::iterator it;
      for (it = mMessageLevel.begin(); it != mMessageLevel.end(); it++) {
        if (it->second) {
          ret += " " + it->first;
        }
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      // update to new setting
      mMessageLevel.clear();

      std::vector<std::string> arg_vec = str2vec(args[1], '|');
      std::vector<std::string>::iterator it;
      for (it = arg_vec.begin(); it != arg_vec.end(); it++) {
        mMessageLevel[*it] = true;
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
#endif // MessageLevel
#if 0 // HWBreak
  else if (args[0] == "go") {
    if ((int)args.size() == 1) {
      cmd_handler->setContinue();
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "HWBreak") {
    // read mode
    if ((int)args.size() == 1) {
      std::map<std::string, bool>::iterator it;
      for (it = mBreakTable.begin(); it != mBreakTable.end(); it++) {
        if (it->second) {
          ret += " " + it->first;
        }
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      // update to new setting
      mBreakTable.clear();
      std::vector<std::string> arg_vec = str2vec(args[1], '|');
      std::vector<std::string>::iterator it;
      for (it = arg_vec.begin(); it != arg_vec.end(); it++) {
        mBreakTable[*it] = true;
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
#endif // HWBreak
#if 0 // EnableInsertInput
  else if (args[0] == "EnableInsertInput") {
    // read mode
    if ((int)args.size() == 1) {
      if (mEnableInsertInput) {
        ret = "true";
      }
      else if (!mEnableInsertInput) {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      if (args[1] == "true") {
        mEnableInsertInput = true;
      }
      else if (args[1] == "false") {
        mEnableInsertInput = false;
      }
      else {
        ret = err_msg + "wrong argument" + specified_cmd;
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
#endif // EnableInsertInput
#if 0 // DumpProfile
  else if (args[0] == "DumpProfile") {
    if ((int)args.size() >= 4) {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
      return ret;
    }
  
    sc_time_unit time_unit = SC_NS;
    if ((int)args.size() >= 3) {
           if (args[2] == "SC_SEC") time_unit = SC_SEC;
      else if (args[2] == "SC_MS" ) time_unit = SC_MS;
      else if (args[2] == "SC_US" ) time_unit = SC_US;
      else if (args[2] == "SC_NS" ) time_unit = SC_NS;
      else if (args[2] == "SC_PS" ) time_unit = SC_PS;
      else if (args[2] == "SC_FS" ) time_unit = SC_FS;
      else {
        ret = err_msg + "wrong argument" + specified_cmd;
        return ret;
      }
    }
  
    FILE *fp = stdout;
    if ((int)args.size() >= 2 && args[1] != "stdout") {
#ifdef __RE_SEQURITY_H
      if (fopen_s( &fp, args[1].c_str(), "a" ) != 0 )
#else
      fp = fopen(args[1].c_str(), "a");
      if (fp == NULL)
#endif
      {
        ret = "Cannot dump profile to " + (std::string)args[1];
        return ret;
      }
    }
  
    DumpProfile(fp, time_unit); // not check return value
    if (fp != stdout && fp != NULL) {
      fclose(fp);
    }
  }
#endif // DumpProfile
#if 0 // ClearProfile
  else if (args[0] == "ClearProfile") {
    if ((int)args.size() == 1) {
      ClearProfile();
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
#endif // ClearProfile
#if 0 // AssertReset
  else if (args[0] == "AssertReset") {
    if ((int)args.size() == 3) {
      double start_time = 0, period = 0;
      bool IsTranslateCorrect = true;
      std::istringstream str_start_time(args[1]);
      std::istringstream str_period    (args[2]);

      str_start_time >> start_time;
      if (((unsigned int)str_start_time.rdstate() & (unsigned int)std::istringstream::failbit) != 0) {
        IsTranslateCorrect = false;
      }
      
      str_period >> period;
      if (((unsigned int)str_period.rdstate() & (unsigned int)std::istringstream::failbit) != 0) {
        IsTranslateCorrect = false;
      }

      if (start_time < 0 || period <= 0) {
        IsTranslateCorrect = false;
      }

      if (IsTranslateCorrect) {
        AssertReset(start_time, period);
      }
      else {
        ret = err_msg + "wrong argument: " + args[1] + " " + args[2]
            + specified_cmd;
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
#endif // AssertReset
#if 0 // EnableDumpResult
  else if (args[0] == "EnableDumpResult") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      if (mEnableDumpResult) {
        ret = "true";
      }
      else {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      if (args[1] == "true") {
        mEnableDumpResult = true;
      }
      else if (args[1] == "false") {
        mEnableDumpResult = false;
      }
      else {
        ret = err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
#endif // EnableDumpResult
  else  {
    ret = user_def_command(args);
  }

  return ret;
}

std::string user_def_command(std::vector<std::string>& args)
{
  std::string ret = "";
  std::string err_msg = "Error ("   + mInstName + ") ";   // error message

  std::string specified_cmd = " (";
  std::vector<std::string>::iterator cmd_it;
  for (cmd_it=args.begin() ; cmd_it!=args.end() ; cmd_it++) {
    specified_cmd += " " + *cmd_it;
  }
  specified_cmd += " ) : Type " + mInstName + " help";

  if (0) {}
  else if (args[0] == "DumpInterrupt") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      if (DumpInterrupt) {
        ret = "true";
      }
      else {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        bool write_val = false;
        if (!str2num(args[1], write_val)) {
          ret += err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
        } else {
          DumpInterrupt = write_val;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "EnableConvertInfo") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      if (EnableConvertInfo) {
        ret = "true";
      }
      else {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        bool write_val = false;
        if (!str2num(args[1], write_val)) {
          ret += err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
        } else {
          EnableConvertInfo = write_val;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "Avrefh0_Val") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      std::ostringstream stream;
      stream << Avrefh0_Val;
      ret = stream.str();
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        std::istringstream is(args[1]);
        double backup = Avrefh0_Val;
        is >> Avrefh0_Val;
        
        if (is.fail() || !is.eof()) {
          Avrefh0_Val = backup;
          ret += err_msg + "wrong argument: " + args[1] + specified_cmd;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "Avrefh1_Val") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      std::ostringstream stream;
      stream << Avrefh1_Val;
      ret = stream.str();
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        std::istringstream is(args[1]);
        double backup = Avrefh1_Val;
        is >> Avrefh1_Val;
        
        if (is.fail() || !is.eof()) {
          Avrefh1_Val = backup;
          ret += err_msg + "wrong argument: " + args[1] + specified_cmd;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "Avrefh2_Val") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      std::ostringstream stream;
      stream << Avrefh2_Val;
      ret = stream.str();
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        std::istringstream is(args[1]);
        double backup = Avrefh2_Val;
        is >> Avrefh2_Val;
        
        if (is.fail() || !is.eof()) {
          Avrefh2_Val = backup;
          ret += err_msg + "wrong argument: " + args[1] + specified_cmd;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "Avrefh3_Val") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      std::ostringstream stream;
      stream << Avrefh3_Val;
      ret = stream.str();
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        std::istringstream is(args[1]);
        double backup = Avrefh3_Val;
        is >> Avrefh3_Val;
        
        if (is.fail() || !is.eof()) {
          Avrefh3_Val = backup;
          ret += err_msg + "wrong argument: " + args[1] + specified_cmd;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "AVcc0") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      std::ostringstream stream;
      stream << AVcc0;
      ret = stream.str();
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        std::istringstream is(args[1]);
        double backup = AVcc0;
        is >> AVcc0;
        
        if (is.fail() || !is.eof()) {
          AVcc0 = backup;
          ret += err_msg + "wrong argument: " + args[1] + specified_cmd;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "AVcc1") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      std::ostringstream stream;
      stream << AVcc1;
      ret = stream.str();
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        std::istringstream is(args[1]);
        double backup = AVcc1;
        is >> AVcc1;
        
        if (is.fail() || !is.eof()) {
          AVcc1 = backup;
          ret += err_msg + "wrong argument: " + args[1] + specified_cmd;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "AVcc2") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      std::ostringstream stream;
      stream << AVcc2;
      ret = stream.str();
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        std::istringstream is(args[1]);
        double backup = AVcc2;
        is >> AVcc2;
        
        if (is.fail() || !is.eof()) {
          AVcc2 = backup;
          ret += err_msg + "wrong argument: " + args[1] + specified_cmd;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "AVcc3") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      std::ostringstream stream;
      stream << AVcc3;
      ret = stream.str();
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        std::istringstream is(args[1]);
        double backup = AVcc3;
        is >> AVcc3;
        
        if (is.fail() || !is.eof()) {
          AVcc3 = backup;
          ret += err_msg + "wrong argument: " + args[1] + specified_cmd;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "tTSPL") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      std::ostringstream stream;
      stream << tTSPL;
      ret = stream.str();
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        std::istringstream is(args[1]);
        double backup = tTSPL;
        is >> tTSPL;
        
        if (is.fail() || !is.eof()) {
          tTSPL = backup;
          ret += err_msg + "wrong argument: " + args[1] + specified_cmd;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "tTHSD") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      std::ostringstream stream;
      stream << tTHSD;
      ret = stream.str();
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        std::istringstream is(args[1]);
        double backup = tTHSD;
        is >> tTHSD;
        
        if (is.fail() || !is.eof()) {
          tTHSD = backup;
          ret += err_msg + "wrong argument: " + args[1] + specified_cmd;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "tTHLD") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      std::ostringstream stream;
      stream << tTHLD;
      ret = stream.str();
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        std::istringstream is(args[1]);
        double backup = tTHLD;
        is >> tTHLD;
        
        if (is.fail() || !is.eof()) {
          tTHLD = backup;
          ret += err_msg + "wrong argument: " + args[1] + specified_cmd;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "ExSmpt") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      std::ostringstream stream;
      stream << ExSmpt;
      ret = stream.str();
    }
    // write mode
    else if ((int)args.size() == 2) {
      if (args[1].substr(0, 1) == "-") {
          ret += err_msg + "wrong value: " + (std::string)args[1] + specified_cmd;
      }
      else {
        unsigned int write_val = 0;
        if (!str2num(args[1], write_val)) {
          ret += err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
        } else {
          ExSmpt = write_val;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "Smpt") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      std::ostringstream stream;
      stream << Smpt;
      ret = stream.str();
    }
    // write mode
    else if ((int)args.size() == 2) {
      if (args[1].substr(0, 1) == "-") {
          ret += err_msg + "wrong value: " + (std::string)args[1] + specified_cmd;
      }
      else {
        unsigned int write_val = 0;
        if (!str2num(args[1], write_val)) {
          ret += err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
        } else {
          Smpt = write_val;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "tSAR") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      std::ostringstream stream;
      stream << tSAR;
      ret = stream.str();
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        std::istringstream is(args[1]);
        double backup = tSAR;
        is >> tSAR;
        
        if (is.fail() || !is.eof()) {
          tSAR = backup;
          ret += err_msg + "wrong argument: " + args[1] + specified_cmd;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "tD") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      std::ostringstream stream;
      stream << tD;
      ret = stream.str();
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        std::istringstream is(args[1]);
        double backup = tD;
        is >> tD;
        
        if (is.fail() || !is.eof()) {
          tD = backup;
          ret += err_msg + "wrong argument: " + args[1] + specified_cmd;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "tED") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      std::ostringstream stream;
      stream << tED;
      ret = stream.str();
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        std::istringstream is(args[1]);
        double backup = tED;
        is >> tED;
        
        if (is.fail() || !is.eof()) {
          tED = backup;
          ret += err_msg + "wrong argument: " + args[1] + specified_cmd;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "ForcedIdError0") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      if (ForcedIdError0) {
        ret = "true";
      }
      else {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        bool write_val = false;
        if (!str2num(args[1], write_val)) {
          ret += err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
        } else {
          ForcedIdError0 = write_val;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "ForcedIdError1") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      if (ForcedIdError1) {
        ret = "true";
      }
      else {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        bool write_val = false;
        if (!str2num(args[1], write_val)) {
          ret += err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
        } else {
          ForcedIdError1 = write_val;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "ForcedIdError2") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      if (ForcedIdError2) {
        ret = "true";
      }
      else {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        bool write_val = false;
        if (!str2num(args[1], write_val)) {
          ret += err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
        } else {
          ForcedIdError2 = write_val;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "ForcedIdError3") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      if (ForcedIdError3) {
        ret = "true";
      }
      else {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        bool write_val = false;
        if (!str2num(args[1], write_val)) {
          ret += err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
        } else {
          ForcedIdError3 = write_val;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "ForcedIdErrorA") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      if (ForcedIdErrorA) {
        ret = "true";
      }
      else {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        bool write_val = false;
        if (!str2num(args[1], write_val)) {
          ret += err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
        } else {
          ForcedIdErrorA = write_val;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "ForcedParityError0") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      if (ForcedParityError0) {
        ret = "true";
      }
      else {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        bool write_val = false;
        if (!str2num(args[1], write_val)) {
          ret += err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
        } else {
          ForcedParityError0 = write_val;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "ForcedParityError1") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      if (ForcedParityError1) {
        ret = "true";
      }
      else {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        bool write_val = false;
        if (!str2num(args[1], write_val)) {
          ret += err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
        } else {
          ForcedParityError1 = write_val;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "ForcedParityError2") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      if (ForcedParityError2) {
        ret = "true";
      }
      else {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        bool write_val = false;
        if (!str2num(args[1], write_val)) {
          ret += err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
        } else {
          ForcedParityError2 = write_val;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "ForcedParityError3") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      if (ForcedParityError3) {
        ret = "true";
      }
      else {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        bool write_val = false;
        if (!str2num(args[1], write_val)) {
          ret += err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
        } else {
          ForcedParityError3 = write_val;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "ForcedParityErrorA") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      if (ForcedParityErrorA) {
        ret = "true";
      }
      else {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        bool write_val = false;
        if (!str2num(args[1], write_val)) {
          ret += err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
        } else {
          ForcedParityErrorA = write_val;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "ForcedOpenError0") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      if (ForcedOpenError0) {
        ret = "true";
      }
      else {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        bool write_val = false;
        if (!str2num(args[1], write_val)) {
          ret += err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
        } else {
          ForcedOpenError0 = write_val;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "ForcedOpenError1") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      if (ForcedOpenError1) {
        ret = "true";
      }
      else {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        bool write_val = false;
        if (!str2num(args[1], write_val)) {
          ret += err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
        } else {
          ForcedOpenError1 = write_val;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "ForcedOpenError2") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      if (ForcedOpenError2) {
        ret = "true";
      }
      else {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        bool write_val = false;
        if (!str2num(args[1], write_val)) {
          ret += err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
        } else {
          ForcedOpenError2 = write_val;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "ForcedOpenError3") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      if (ForcedOpenError3) {
        ret = "true";
      }
      else {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        bool write_val = false;
        if (!str2num(args[1], write_val)) {
          ret += err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
        } else {
          ForcedOpenError3 = write_val;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "ForcedOpenErrorA") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      if (ForcedOpenErrorA) {
        ret = "true";
      }
      else {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        bool write_val = false;
        if (!str2num(args[1], write_val)) {
          ret += err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
        } else {
          ForcedOpenErrorA = write_val;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "ForcedBreak0") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      if (ForcedBreak0) {
        ret = "true";
      }
      else {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        bool write_val = false;
        if (!str2num(args[1], write_val)) {
          ret += err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
        } else {
          ForcedBreak0 = write_val;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "ForcedBreak1") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      if (ForcedBreak1) {
        ret = "true";
      }
      else {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        bool write_val = false;
        if (!str2num(args[1], write_val)) {
          ret += err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
        } else {
          ForcedBreak1 = write_val;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "ForcedBreak2") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      if (ForcedBreak2) {
        ret = "true";
      }
      else {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        bool write_val = false;
        if (!str2num(args[1], write_val)) {
          ret += err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
        } else {
          ForcedBreak2 = write_val;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "ForcedBreak3") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      if (ForcedBreak3) {
        ret = "true";
      }
      else {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        bool write_val = false;
        if (!str2num(args[1], write_val)) {
          ret += err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
        } else {
          ForcedBreak3 = write_val;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "ForcedBreakA") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      if (ForcedBreakA) {
        ret = "true";
      }
      else {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        bool write_val = false;
        if (!str2num(args[1], write_val)) {
          ret += err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
        } else {
          ForcedBreakA = write_val;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "ForcedDataPathError0") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      if (ForcedDataPathError0) {
        ret = "true";
      }
      else {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        bool write_val = false;
        if (!str2num(args[1], write_val)) {
          ret += err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
        } else {
          ForcedDataPathError0 = write_val;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "ForcedDataPathError1") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      if (ForcedDataPathError1) {
        ret = "true";
      }
      else {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        bool write_val = false;
        if (!str2num(args[1], write_val)) {
          ret += err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
        } else {
          ForcedDataPathError1 = write_val;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "ForcedDataPathError2") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      if (ForcedDataPathError2) {
        ret = "true";
      }
      else {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        bool write_val = false;
        if (!str2num(args[1], write_val)) {
          ret += err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
        } else {
          ForcedDataPathError2 = write_val;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "ForcedDataPathError3") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      if (ForcedDataPathError3) {
        ret = "true";
      }
      else {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        bool write_val = false;
        if (!str2num(args[1], write_val)) {
          ret += err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
        } else {
          ForcedDataPathError3 = write_val;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "ForcedDataPathErrorA") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      if (ForcedDataPathErrorA) {
        ret = "true";
      }
      else {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        bool write_val = false;
        if (!str2num(args[1], write_val)) {
          ret += err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
        } else {
          ForcedDataPathErrorA = write_val;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "EnableTimeCalculation") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      if (EnableTimeCalculation) {
        ret = "true";
      }
      else {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        bool write_val = false;
        if (!str2num(args[1], write_val)) {
          ret += err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
        } else {
          EnableTimeCalculation = write_val;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "AVccMax") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      std::ostringstream stream;
      stream << AVccMax;
      ret = stream.str();
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        std::istringstream is(args[1]);
        double backup = AVccMax;
        is >> AVccMax;
        
        if (is.fail() || !is.eof()) {
          AVccMax = backup;
          ret += err_msg + "wrong argument: " + args[1] + specified_cmd;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "AVccMin") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      std::ostringstream stream;
      stream << AVccMin;
      ret = stream.str();
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        std::istringstream is(args[1]);
        double backup = AVccMin;
        is >> AVccMin;
        
        if (is.fail() || !is.eof()) {
          AVccMin = backup;
          ret += err_msg + "wrong argument: " + args[1] + specified_cmd;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "EVccMax") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      std::ostringstream stream;
      stream << EVccMax;
      ret = stream.str();
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        std::istringstream is(args[1]);
        double backup = EVccMax;
        is >> EVccMax;
        
        if (is.fail() || !is.eof()) {
          EVccMax = backup;
          ret += err_msg + "wrong argument: " + args[1] + specified_cmd;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "EVccMin") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      std::ostringstream stream;
      stream << EVccMin;
      ret = stream.str();
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        std::istringstream is(args[1]);
        double backup = EVccMin;
        is >> EVccMin;
        
        if (is.fail() || !is.eof()) {
          EVccMin = backup;
          ret += err_msg + "wrong argument: " + args[1] + specified_cmd;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "AvrefhMin") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      std::ostringstream stream;
      stream << AvrefhMin;
      ret = stream.str();
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        std::istringstream is(args[1]);
        double backup = AvrefhMin;
        is >> AvrefhMin;
        
        if (is.fail() || !is.eof()) {
          AvrefhMin = backup;
          ret += err_msg + "wrong argument: " + args[1] + specified_cmd;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "DumpStatInfo") {
    if ((int)args.size() > 0 && (int)args.size() <= 1) {
      DumpStatInfo();
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "SetCLKfreq") {
    if ((int)args.size() > 2 && (int)args.size() <= 3) {
      std::string clk_name;
      if ((int)args.size() >= 2) {
        clk_name = (std::string)args[1];
      }
      double clk_freq;
      if ((int)args.size() >= 3) {
        if (!str2dbl(args[2], clk_freq)) {
          ret = err_msg + "wrong argument" + specified_cmd;
          return ret;
        }
      }
      SetCLKfreq(clk_name, clk_freq);
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "AssertPReset") {
    if ((int)args.size() > 2 && (int)args.size() <= 3) {
      double start_time;
      if ((int)args.size() >= 2) {
        if (!str2dbl(args[1], start_time)) {
          ret = err_msg + "wrong argument" + specified_cmd;
          return ret;
        }
      }
      double period;
      if ((int)args.size() >= 3) {
        if (!str2dbl(args[2], period)) {
          ret = err_msg + "wrong argument" + specified_cmd;
          return ret;
        }
      }
      AssertPReset(start_time, period);
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "AssertADReset") {
    if ((int)args.size() > 2 && (int)args.size() <= 3) {
      double start_time;
      if ((int)args.size() >= 2) {
        if (!str2dbl(args[1], start_time)) {
          ret = err_msg + "wrong argument" + specified_cmd;
          return ret;
        }
      }
      double period;
      if ((int)args.size() >= 3) {
        if (!str2dbl(args[2], period)) {
          ret = err_msg + "wrong argument" + specified_cmd;
          return ret;
        }
      }
      AssertADReset(start_time, period);
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "AssertPResetA") {
    if ((int)args.size() > 2 && (int)args.size() <= 3) {
      double start_time;
      if ((int)args.size() >= 2) {
        if (!str2dbl(args[1], start_time)) {
          ret = err_msg + "wrong argument" + specified_cmd;
          return ret;
        }
      }
      double period;
      if ((int)args.size() >= 3) {
        if (!str2dbl(args[2], period)) {
          ret = err_msg + "wrong argument" + specified_cmd;
          return ret;
        }
      }
      AssertPResetA(start_time, period);
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "AssertADResetA") {
    if ((int)args.size() > 2 && (int)args.size() <= 3) {
      double start_time;
      if ((int)args.size() >= 2) {
        if (!str2dbl(args[1], start_time)) {
          ret = err_msg + "wrong argument" + specified_cmd;
          return ret;
        }
      }
      double period;
      if ((int)args.size() >= 3) {
        if (!str2dbl(args[2], period)) {
          ret = err_msg + "wrong argument" + specified_cmd;
          return ret;
        }
      }
      AssertADResetA(start_time, period);
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "AssignTHCircuit") {
    if ((int)args.size() > 4 && (int)args.size() <= 5) {
      unsigned int adc_index;
      if ((int)args.size() >= 2) {
        if (args[1][0] == '-') {
          ret = err_msg + "wrong argument" + specified_cmd;
          return ret;
        }
        if (!str2num(args[1], adc_index)) {
          ret = err_msg + "wrong argument" + specified_cmd;
          return ret;
        }
      }
      unsigned int th_channel;
      if ((int)args.size() >= 3) {
        if (args[2][0] == '-') {
          ret = err_msg + "wrong argument" + specified_cmd;
          return ret;
        }
        if (!str2num(args[2], th_channel)) {
          ret = err_msg + "wrong argument" + specified_cmd;
          return ret;
        }
      }
      unsigned int group_channel;
      if ((int)args.size() >= 4) {
        if (args[3][0] == '-') {
          ret = err_msg + "wrong argument" + specified_cmd;
          return ret;
        }
        if (!str2num(args[3], group_channel)) {
          ret = err_msg + "wrong argument" + specified_cmd;
          return ret;
        }
      }
      unsigned int physic_channel;
      if ((int)args.size() >= 5) {
        if (args[4][0] == '-') {
          ret = err_msg + "wrong argument" + specified_cmd;
          return ret;
        }
        if (!str2num(args[4], physic_channel)) {
          ret = err_msg + "wrong argument" + specified_cmd;
          return ret;
        }
      }
      AssignTHCircuit(adc_index, th_channel, group_channel, physic_channel);
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }

  else {
    ret = err_msg + "command name \"command " + (std::string)args[0] + "\" is invalid.";
  }

  return ret;
}

#if 1 // reg
std::string regif_handle_command(std::vector<std::string>& args)
{
  std::string ret = "";
  std::string err_msg = "Error ("   + mInstName + ") ";   // error message

  std::string specified_cmd = " (";
  std::vector<std::string>::iterator cmd_it;
  for (cmd_it=args.begin() ; cmd_it!=args.end() ; cmd_it++) {
    specified_cmd += " " + *cmd_it;
  }
  specified_cmd += " ) : Type " + mInstName + " help";

  // dump register list
  if ((int)args.size() == 1) {
    vpcl::re_register *reg_p = first_reg_object();
    while (reg_p != NULL) {
      printf("%s\n", reg_p->name().c_str());
      reg_p = next_reg_object();
    }
  }
  else {
    bool reg_found = false;
    vpcl::re_register *reg_p = first_reg_object();
    std::vector<std::string> args_updated;
    std::copy( args.begin(), args.end(), back_inserter( args_updated ) );
    while (reg_p != NULL) {
      if (strmatch(args[1].c_str(), reg_p->name().c_str())) {
        reg_found = true;
        args_updated[1] = reg_p->name();
        ret += this->reg_handle_command(args_updated) + "\n";
      }
      reg_p = next_reg_object();
    }
    if (!reg_found) {
      ret = this->reg_handle_command(args_updated);
    }
  }

  return ret;
}
#endif

#if 0 // port
#define PORT_READ_WRITE(port_name, port_val, port_type, print_func, str2_func)  \
        if (port_obj != NULL) {                                                 \
          if ((int)args.size() == 1) {                                          \
            find_success = true;                                                \
            print_func(#port_name, port_val);                                   \
          }                                                                     \
          else if ((int)args.size() == 2) {                                     \
            port_type write_val = 0;                                            \
            if (str2_func(args[1], write_val)) {                                \
              find_success = true;                                              \
              mVal_##port_name = write_val;                                     \
            }                                                                   \
            else {                                                              \
              ret = err_msg + args.at(1) + " is wrong argument" + specified_cmd;\
            }                                                                   \
          }                                                                     \
        }                                                                       \

#define PORT_READ(port_name, port_val, print_func)                              \
        if (port_obj != NULL) {                                                 \
          if ((int)args.size() == 1) {                                          \
            find_success = true;                                                \
            print_func(#port_name, port_val);                                   \
          }                                                                     \
        }

void print_double(std::string port_name, double port_val) {
    printf("%-10s %s = %f\n", mInstName.c_str(), port_name.c_str(), port_val); 
}

template<typename T>
void print_uint(std::string port_name, T port_val) {
    printf("%-10s %s = %d\n", mInstName.c_str(), port_name.c_str(), port_val); 
}

template<typename T>
void print_uint64(std::string port_name, T port_val) {
    printf("%-10s %s = %llu\n", mInstName.c_str(), port_name.c_str(), port_val); 
}

std::string port_handle_command(std::vector<std::string> args)
{
  std::string ret = "";
  std::string err_msg = "Error ("   + mInstName + ") ";   // error message

  std::string specified_cmd = " (";
  std::vector<std::string>::iterator cmd_it;
  for (cmd_it=args.begin() ; cmd_it!=args.end() ; cmd_it++) {
    specified_cmd += " " + *cmd_it;
  }
  specified_cmd += " ) : Type " + mInstName + " help";

  // dump all port information
  if ((int)args.size() == 0) {
    std::vector<sc_object *> child_obj = get_child_objects();
    std::vector<sc_object *>::iterator it;

    for (it=child_obj.begin() ; it!=child_obj.end() ; it++) {
      std::string target = (*it)->name();
      if (target.find(mInstName) != std::string::npos
       && (!strcmp((*it)->kind(), "sc_in") || !strcmp((*it)->kind(), "sc_out"))) {
        printf("%-10s <sc_out> %s\n", mInstName.c_str(), (*it)->basename());
      }
    }
  }

  // Dump help message
  else if (args[0] == "help") {
    ret += "    --- port ---\n";
    ret += "    <port> <value>                     Set value to <port> output port\n";
  }

  // port write / read
  else if ((int)args.size() == 1 || (int)args.size() == 2) {
    std::vector<sc_object *> child_obj = get_child_objects();
    std::vector<sc_object *>::iterator it;
    bool find_success = false;

    for (it=child_obj.begin() ; it!=child_obj.end() ; it++) {
      std::string obj_name = (*it)->name();
      std::string arg_name = mInstName + "." + (std::string)args[0];
      if (strmatch(arg_name.c_str(), obj_name.c_str())) {

      }
    }

    if (!find_success) {
      ret = err_msg + "is invalid command name";
    }
  }
  else {
    ret = err_msg + "The argument number of " + args.at(0) + " is invalid" + specified_cmd;
  }

  return ret;
}

#undef PORT_READ_WRITE
#undef PORT_READ
#endif // port

bool str2num(std::string str, bool &num)
{
  std::istringstream is(str);
  int tmp;

  if (str.substr(0, 2) == "0x") {
    is >> std::hex >> tmp;
  }
  else if (str.substr(0, 1) == "0") {
    is >> std::oct >> tmp;
  } else {
    is >> std::dec >> tmp;
  }

  if (is.fail() || !is.eof()) {
    if (str == "true") {
      num = true;
    } else if (str == "false") {
      num = false;
    } else {
      return false;
    }
  } else {
    if (tmp == 1) {
      num = true;
    } else if (tmp == 0) {
      num = false;
    } else {
      return false;
    }
  }
  return true;
}

bool str2num(std::string str, char &num)
{
  std::istringstream is(str);
  int tmp;

  if (str.substr(0, 2) == "0x") {
    is >> std::hex >> tmp;
  }
  else if (str.substr(0, 1) == "0") {
    is >> std::oct >> tmp;
  }
  else {
    is >> std::dec >> tmp;
  }

  if (is.fail() || !is.eof()) {
    return false;
  }
  else {
    num = (char)tmp;
    return true;
  }
}

bool str2num(std::string str, unsigned char &num)
{
  std::istringstream is(str);
  unsigned int tmp;

  if (str.substr(0, 2) == "0x") {
    is >> std::hex >> tmp;
  }
  else if (str.substr(0, 1) == "0") {
    is >> std::oct >> tmp;
  }
  else {
    is >> std::dec >> tmp;
  }

  if (is.fail() || !is.eof()) {
    return false;
  }
  else {
    num = (unsigned char)tmp;
    return true;
  }
}

template<typename T>
bool str2num(std::string str, T &num)
{
  std::istringstream is(str);
  T tmp;

  if (str.substr(0, 2) == "0x") {
    is >> std::hex >> tmp;
  }
  else if (str.substr(0, 1) == "0") {
    is >> std::oct >> tmp;
  }
  else {
    is >> std::dec >> tmp;
  }

  if (is.fail() || !is.eof()) {
    return false;
  }
  else {
    num = tmp;
    return true;
  }
}

bool str2dbl(std::string str, double &num)
{
  std::istringstream is(str);
  double tmp;

  is >> tmp;

  if (is.fail() || !is.eof()) {
    return false;
  }
  else {
    num = tmp;
    return true;
  }
}

void CommandInit(std::string name = "") {
  // initialize internal variables
  mInstName = name;
  mLineNum = 0;
  mFileName = "";
  mCmdId = "self";

#if 0 // EnableDumpResult
  mEnableDumpResult = false;
#endif // EnableDumpResult

  // initialize pre-defined command
#if 0 // EnableInsertInput
  mEnableInsertInput = false;
#endif // EnableInsertInput
#if 1 // MessageLevel
  mMessageLevel.insert(std::pair<std::string, bool>("fatal",   true ));
  mMessageLevel.insert(std::pair<std::string, bool>("error",   true ));
  mMessageLevel.insert(std::pair<std::string, bool>("warning", false));
  mMessageLevel.insert(std::pair<std::string, bool>("info",    false));
#endif // MessageLevel
#if 0 // HWBreak
  mBreakTable["none"] = true;
  cmd_handler = NULL;
#endif // HWBreak

  // initialize user define command
  DumpInterrupt = false;
  EnableConvertInfo = false;
  Avrefh0_Val = 3.3;
  Avrefh1_Val = 3.3;
  Avrefh2_Val = 3.3;
  Avrefh3_Val = 3.3;
  AVcc0 = 3.3;
  AVcc1 = 3.3;
  AVcc2 = 3.3;
  AVcc3 = 3.3;
  tTSPL = 27;
  tTHSD = 5;
  tTHLD = 10;
  ExSmpt = 60;
  Smpt = 18;
  tSAR = 0;
  tD = 0;
  tED = 0;
  ForcedIdError0 = false;
  ForcedIdError1 = false;
  ForcedIdError2 = false;
  ForcedIdError3 = false;
  ForcedIdErrorA = false;
  ForcedParityError0 = false;
  ForcedParityError1 = false;
  ForcedParityError2 = false;
  ForcedParityError3 = false;
  ForcedParityErrorA = false;
  ForcedOpenError0 = false;
  ForcedOpenError1 = false;
  ForcedOpenError2 = false;
  ForcedOpenError3 = false;
  ForcedOpenErrorA = false;
  ForcedBreak0 = false;
  ForcedBreak1 = false;
  ForcedBreak2 = false;
  ForcedBreak3 = false;
  ForcedBreakA = false;
  ForcedDataPathError0 = false;
  ForcedDataPathError1 = false;
  ForcedDataPathError2 = false;
  ForcedDataPathError3 = false;
  ForcedDataPathErrorA = false;
  EnableTimeCalculation = true;
  AVccMax = 3.6;
  AVccMin = 3;
  EVccMax = 3.6;
  EVccMin = 3;
  AvrefhMin = 3;


}

std::vector<std::string> str2vec(std::string str, const char sep)
{
  std::vector<std::string> buf;
  int index = 0;

  for (int i=0 ; i<(int)str.size() ; i++) {
    if (str[i] == sep) {
      if (i > index) {
        buf.push_back(str.substr((unsigned int)index, (unsigned int)(i-index)));
      }
      index = i+1;
    }
  }
  if (index < (int)str.size()) {
    buf.push_back(str.substr((unsigned int)index));
  }
  return buf;
}

void _re_printf(std::string group, const char *message, ...) {
  // message group check
#ifndef REGIF_SC_REPORT
#if 1 // MessageLevel
  if (!mMessageLevel[group]) return;
#endif // MessageLevel
#endif//REGIF_SC_REPORT

  if (message == NULL) return;

  // print header
  #ifdef SYSTEMC_H
  std::stringstream t_stream;
  std::string cur_time;

  double tu_value = 0;
  std::string tu_name = "";
  if (sc_get_time_resolution() < sc_time(1, SC_PS)) {
    tu_value = 1000000000000000LL;
    tu_name = " fs";
  }
  else if (sc_get_time_resolution() < sc_time(1, SC_NS)) {
    tu_value = 1000000000000LL;
    tu_name = " ps";
  }
  else if (sc_get_time_resolution() < sc_time(1, SC_US)) {
    tu_value = 1000000000;
    tu_name = " ns";
  }
  else if (sc_get_time_resolution() < sc_time(1, SC_MS)) {
    tu_value = 1000000;
    tu_name = " us";
  }
  else if (sc_get_time_resolution() < sc_time(1, SC_SEC)) {
    tu_value = 1000;
    tu_name = " ms";
  }
  else {
    tu_value = 1;
    tu_name = " s";
  }
  t_stream << sc_time_stamp().value() * (uint64) (sc_get_time_resolution().to_seconds() * tu_value) << tu_name;

  cur_time = t_stream.str();
  #else
  std::string cur_time = "";
  #endif

#ifndef REGIF_SC_REPORT
  #ifdef REGIF_MSG_COLOR
  // color setting
  //
  // severity color       color Linux       Windows
  // fatal    RED         RED   \033[0;31m  FOREGROUND_RED
  // error    RED         BLUE  \033[0;34m  FOREGROUND_BLUE
  // warning  RED
  // info     BLUE
  #ifdef _WIN32
  HANDLE hStdout;
  CONSOLE_SCREEN_BUFFER_INFO csbi;
  if (group == "fatal" || group == "error" || group == "warning") {
    SetConsoleTextAttribute(hStdout, FOREGROUND_RED);
  }
  else if (group == "info" ){
    SetConsoleTextAttribute(hStdout, FOREGROUND_BLUE);
  }
  #else
  if (group == "fatal" || group == "error" || group == "warning") {
    printf("\033[0;31m");
  }
  else if (group == "info" ){
    printf("\033[0;34m");
  }
  #endif
  #endif
  printf("%8s [%20s] (%10s) ", group.c_str(), cur_time.c_str(), mInstName.c_str());
#endif//REGIF_SC_REPORT

  // print body
  va_list argptr;
  va_start(argptr, message);
  if (argptr == NULL) return;
#ifdef REGIF_SC_REPORT
  char str[1024];
  sprintf(str, "[%20s] ", cur_time.c_str());
  vsprintf(str+23, message, argptr);
  if (group == "fatal") {
    SC_REPORT_FATAL(mInstName.c_str(), str);
  }
  else if (group == "error") {
    SC_REPORT_ERROR(mInstName.c_str(), str);
  }
  else if (group == "warning") {
    SC_REPORT_WARNING(mInstName.c_str(), str);
  }
  else if (group == "info") {
    SC_REPORT_INFO(mInstName.c_str(), str);
  }
#else //REGIF_SC_REPORT
  vprintf(message, argptr);
#endif//REGIF_SC_REPORT

#ifndef REGIF_SC_REPORT
  #ifdef DumpFileNameLineNum
  // print footer
  if (group == "fatal" || group == "error") {
    printf(" [%s:%d]\n", mFileName.c_str(), mLineNum);
  }
  // legacy code
  //else {
  //  printf("\n");
  //}
  #endif//DumpFileNameLineNum
#endif//REGIF_SC_REPORT
  va_end(argptr);

#ifndef REGIF_SC_REPORT
  #ifdef REGIF_MSG_COLOR
  #ifdef _WIN32
  SetConsoleTextAttribute(hStdout, csbi.wAttributes);
  #else
  printf("\033[m");
  #endif
  #endif
#endif//REGIF_SC_REPORT

  fflush(stdout);
  fflush(stderr);

  if (group == "fatal") {
    exit(1);
  }
}

void get_fileline(std::string filename, int line_number) {
#ifdef _WIN32
  filename = filename.substr(filename.rfind("\\")+1);
#else
  filename = filename.substr(filename.rfind("/")+1);
#endif
  mFileName = filename;
  mLineNum  = line_number;
}

#ifndef re_printf
#define re_printf get_fileline(__FILE__, __LINE__); _re_printf
#endif//re_printf

bool strmatch(const char *ptn, const char *str) {
  bool ret;

  if (ptn == NULL || str == NULL) return false;

  switch( *ptn ) {
  case '\0':
    ret = '\0' == *str;
    break;
  case '*' :
    ret = strmatch( &ptn[1], str ) || (('\0' != *str) && strmatch( ptn, &str[1] ));
    break;
  case '?' :
    ret = ('\0' != *str) && strmatch( &ptn[1], &str[1] );
    break;
  default  :
    ret = ((unsigned char)*ptn == (unsigned char)*str) && strmatch( &ptn[1], &str[1] );
    break;
  }
  return ret;
}


// declare handleCommand relative members
#if 0 // EnableInsertInput
bool mEnableInsertInput;
#endif // EnableInsertInput
#if 1 // MessageLevel
std::map<std::string, bool> mMessageLevel;
#endif // MessageLevel
#if 0 // HWBreak
std::map<std::string, bool> mBreakTable;
vpcl::commandHandler* cmd_handler;
#endif // HWBreak

std::string mInstName;
std::string mFileName;
std::string mCmdId;
int mLineNum;
#if 0 // EnableDumpResult
bool mEnableDumpResult;
#endif // EnableDumpResult

bool DumpInterrupt;
bool EnableConvertInfo;
double Avrefh0_Val;
double Avrefh1_Val;
double Avrefh2_Val;
double Avrefh3_Val;
double AVcc0;
double AVcc1;
double AVcc2;
double AVcc3;
double tTSPL;
double tTHSD;
double tTHLD;
unsigned int ExSmpt;
unsigned int Smpt;
double tSAR;
double tD;
double tED;
bool ForcedIdError0;
bool ForcedIdError1;
bool ForcedIdError2;
bool ForcedIdError3;
bool ForcedIdErrorA;
bool ForcedParityError0;
bool ForcedParityError1;
bool ForcedParityError2;
bool ForcedParityError3;
bool ForcedParityErrorA;
bool ForcedOpenError0;
bool ForcedOpenError1;
bool ForcedOpenError2;
bool ForcedOpenError3;
bool ForcedOpenErrorA;
bool ForcedBreak0;
bool ForcedBreak1;
bool ForcedBreak2;
bool ForcedBreak3;
bool ForcedBreakA;
bool ForcedDataPathError0;
bool ForcedDataPathError1;
bool ForcedDataPathError2;
bool ForcedDataPathError3;
bool ForcedDataPathErrorA;
bool EnableTimeCalculation;
double AVccMax;
double AVccMin;
double EVccMax;
double EVccMin;
double AvrefhMin;

#endif//SARAD_U2B_CMDIF_H
