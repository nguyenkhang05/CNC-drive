// -----------------------------------------------------------------------------
// $Id$
//
// Copyright(c) 2020 Renesas Electronics Corporation
// Copyright(c) 2020 Renesas Design Vietnam Co., Ltd.
// RENESAS ELECTRONICS CONFIDENTIAL AND PROPRIETARY.
// This program must be used solely for the purpose for which
// it was furnished by Renesas Electronics Corporation. No part of this
// program may be reproduced or disclosed to others, in any
// form, without the prior written permission of Renesas Electronics
// Corporation.
// -----------------------------------------------------------------------------
// This file is generated by Register I/F generator
//    gen_regif.py
//    gen_regif_class.py
//    regif_cpp.skl
//
// Input file : adc_u2b_info.txt
////////////////////////////////////////////////////////////////////////////////
// # -----------------------------------------------------------------------------
// # $Id$
// #
// # Copyright(c) 2020 Renesas Electronics Corporation
// # Copyright(c) 2020 Renesas Design Vietnam Co., Ltd.
// # RENESAS ELECTRONICS CONFIDENTIAL AND PROPRIETARY.
// # This program must be used solely for the purpose for which
// # it was furnished by Renesas Electronics Corporation. No part of this
// # program may be reproduced or disclosed to others, in any
// # form, without the prior written permission of Renesas Electronics
// # Corporation.
// # -----------------------------------------------------------------------------
// 
// ####################################################
// ## For Register
// ####################################################
// %MODULE adc_u2b
//     #              name     offset_size  
//     %%REG_INSTANCE reg_def  13           
// 
// %REG_CHANNEL   reg_def
//   %%TITLE name         reg_name     wsize     rsize     length  offset  factor_start  factor_end  factor_index  factor_step  init         access  support  callback
// 
//   %%REG   VCR          VCR          8|16|32   8|16|32   32      0x000      0            95            -            0x4        0           W|R      TRUE      -
//   %%REG   PWDVCR       PWDVCR       8|16|32   8|16|32   32      0x180      -            -             -            -          0           R        TRUE      -
//   %%REG   SGDIAGVCR    SGDIAGVCR    8|16|32   8|16|32   8       0x184      0            2             -            0x4        0           W|R      TRUE      -
//   %%REG   DR           DR           8|16|32   8|16|32   32      0x1A0      0            47            -            0x4        0           R        TRUE      -
//   %%REG   PWDDR        PWDDR        8|16|32   8|16|32   16      0x260      -            -             -            -          0           R        TRUE      -
//   %%REG   SGDIAGDR01   SGDIAGDR01   8|16|32   8|16|32   32      0x264      -            -             -            -          0           R        TRUE      -
//   %%REG   SGDIAGDR2    SGDIAGDR2    8|16|32   8|16|32   16      0x268      -            -             -            -          0           R        TRUE      -
//   %%REG   SGDIAGSRR    SGDIAGSRR    8|16|32   8|16|32   32      0x26C      -            -             -            -          0           R        TRUE      -
//   %%REG   DIR          DIR          8|16|32   8|16|32   32      0x280      0            95            -            0x4        0           R        TRUE      -
//   %%REG   PWDDIR       PWDDIR       8|16|32   8|16|32   32      0x400      -            -             -            -          0           R        TRUE      -
//   %%REG   SGDIAGDIR    SGDIAGDIR    8|16|32   8|16|32   32      0x404      0            2             -            0x4        0           R        TRUE      -
//   %%REG   SGSTCR       SGSTCR       8|16|32   8|16|32   8       0x440      0            4             -            0x40       0           W|R      TRUE      -
//   %%REG   SGSTPCR      SGSTPCR      8|16|32   8|16|32   8       0x444      0            4             -            0x40       0           D        TRUE      -
//   %%REG   SGCR         SGCR         8|16|32   8|16|32   8       0x450      0            4             -            0x40       0           W|R      TRUE      -
//   %%REG   SGVCPR       SGVCPR         16|32   8|16|32   16      0x454      0            4             -            0x40       0           D        TRUE      -
//   %%REG   SGMCYCR      SGMCYCR      8|16|32   8|16|32   8       0x458      0            4             -            0x40       0           W|R      TRUE      -
//   %%REG   SGSR         SGSR         8|16|32   8|16|32   8       0x460      0            4             -            0x40       0           R        TRUE      -
//   %%REG   ULLMSR       ULLMSR       8|16|32   8|16|32   8       0x470      0            4             -            0x40       0           D        FALSE      -
//   %%REG   SGVCSP       SGVCSP       8|16|32   8|16|32   8       0x474      0            4             -            0x40       0           D        FALSE      -
//   %%REG   SGVCEP       SGVCEP       8|16|32   8|16|32   8       0x478      0            4             -            0x40       0           D        FALSE      -
//   %%REG   ADTSTCR      ADTSTCR      8|16|32   8|16|32   8       0x508      3            4             -            0x40       0           W|R      TRUE      -
//   %%REG   ADTENDCR     ADTENDCR     8|16|32   8|16|32   8       0x50C      3            4             -            0x40       0           W|R      TRUE      -
//   %%REG   ADTIPR       ADTIPR       8|16|32   8|16|32   32      0x524      3            4             -            0x40       0           W|R      TRUE      -
//   %%REG   ADTPRR       ADTPRR       8|16|32   8|16|32   32      0x528      3            4             -            0x40       0x001FFFFF  W|R      TRUE      -
//   %%REG   PWDCR        PWDCR        8|16|32   8|16|32   8       0x580      -            -             -            -          0           W|R      TRUE      -
//   %%REG   PWDSGCR      PWDSGCR      8|16|32   8|16|32   8       0x584      -            -             -            -          0           W|R      TRUE      -    
//   %%REG   PWDSGSTCR    PWDSGSTCR    8|16|32   8|16|32   8       0x588      -            -             -            -          0           R:0|W    FALSE      -    
//   %%REG   PWDSGSR      PWDSGSR      8|16|32   8|16|32   8       0x58C      -            -             -            -          0           W|R      FALSE      -    
//   %%REG   SGDIAGSTCR   SGDIAGSTCR   8|16|32   8|16|32   8       0x5C0      -            -             -            -          0           R:0|W    TRUE      -
//   %%REG   SGDIAGSTPCR  SGDIAGSTPCR  8|16|32   8|16|32   8       0x5C4      -            -             -            -          0           R:0|W    TRUE      -    
//   %%REG   SGDIAGCR     SGDIAGCR     8|16|32   8|16|32   32      0x5D0      -            -             -            -          0           R:0|W    TRUE      -  
//   %%REG   SGDIAGPCCR0  SGDIAGPCCR0  8|16|32   8|16|32   32      0x5E0      -            -             -            -          0           W|R      TRUE      -    
//   %%REG   SGDIAGPCCR1  SGDIAGPCCR1  8|16|32   8|16|32   32      0x5E4      -            -             -            -          0           W|R      TRUE      -    
//   %%REG   SGDIAGSR     SGDIAGSR     8|16|32   8|16|32   16      0x5F0      -            -             -            -          0           R        TRUE      -    
//   %%REG   SGSTR        SGSTR        8|16|32   8|16|32   16      0x600      -            -             -            -          0           R        TRUE      -   
//   %%REG   ADHALTR      ADHALTR      8|16|32   8|16|32   8       0x640      -            -             -            -          0           W|R      TRUE      -
//   %%REG   ADCR1        ADCR1        8|16|32   8|16|32   8       0x644      -            -             -            -          0           D        TRUE      -
//   %%REG   ADCR2        ADCR2        8|16|32   8|16|32   8       0x648      -            -             -            -          0           D        TRUE      -
//   %%REG   SMPCR        SMPCR        8|16|32   8|16|32   32      0x64C      -            -             -            -          0           D        TRUE      - 
//   %%REG   MPXCURCR     MPXCURCR     8|16      8|16      8       0x650      -            -             -            -          0           W|R      TRUE      -
//   %%REG   MPXINTER     MPXINTER     8|16      8|16      8       0x654      -            -             -            -          0           D        TRUE      -
//   %%REG   MPXCURR1     MPXCURR1     8|16|32   8|16|32   32      0x658      -            -             -            -          0           R        TRUE      -
//   %%REG   MPXCURR2     MPXCURR2     8|16|32   8|16|32   8       0x65C      -            -             -            -          0           R        TRUE      -
//   %%REG   MPXCMDR      MPXCMDR      8|16|32   8|16|32   8       0x660      -            -             -            -          0           W|R      TRUE      -
//   %%REG   MPXOWR       MPXOWR       8|16|32   8|16|32   8       0x664      -            -             -            -          0           W|R      FALSE      -
//   %%REG   DFASENTSGER  DFASENTSGER  8|16|32   8|16|32   16      0x670      -            -             -            -          0           D        TRUE      -
//   %%REG   ADENDP       ADENDP       8|16|32   8|16|32   8       0x674      0            4             -            0x4        0           D        TRUE      -
//   %%REG   THSMPSTCR    THSMPSTCR    8|16|32   8|16|32   8       0x690      -            -             -            -          0           D        TRUE      -
//   %%REG   THSTPCR      THSTPCR      8|16|32   8|16|32   8       0x694      -            -             -            -          0           D        TRUE      -
//   %%REG   THCR         THCR         8|16|32   8|16|32   8       0x698      -            -             -            -          0           D        TRUE      -
//   %%REG   THAHLDSTCR   THAHLDSTCR   8|16|32   8|16|32   8       0x6A0      -            -             -            -          0           D        TRUE      -
//   %%REG   THBHLDSTCR   THBHLDSTCR   8|16|32   8|16|32   8       0x6A4      -            -             -            -          0           D        TRUE      -
//   %%REG   THGSR        THGSR        8|16|32   8|16|32   16      0x6B0      -            -             -            -          0           D        TRUE      -
//   %%REG   THER         THER         8|16|32   8|16|32   8       0x6B4      -            -             -            -          0           D        TRUE      -
//   %%REG   THACR        THACR        8|16|32   8|16|32   8       0x6C0      -            -             -            -          0           D        TRUE      -
//   %%REG   THBCR        THBCR        8|16|32   8|16|32   8       0x6C4      -            -             -            -          0           D        TRUE      -
//   %%REG   WAITTR       WAITTR       8|16      8|16      16      0x700      0            7             -            0x4        0           D        TRUE      -
//   %%REG   EMUCR        EMUCR        8|16|32   8|16|32   8       0x750      -            -             -            -          0           D        FALSE      -
//   %%REG   ADTSTRP1     ADTSTRP1     8|16|32   8|16|32   8       0x754      -            -             -            -          0           D        FALSE      -
//   %%REG   TDCR         TDCR         8|16|32   8|16|32   8       0x760      -            -             -            -          0           D        TRUE      -
//   %%REG   ODCR         ODCR         8|16|32   8|16|32   16      0x764      -            -             -            -          0           D        TRUE      -
//   %%REG   IEDCR        IEDCR        8|16|32   8|16|32   8       0x768      -            -             -            -          0           D        FALSE      -
//   %%REG   SFTCR        SFTCR        8|16|32   8|16|32   8       0x770      -            -             -            -          0           D        TRUE      -
//   %%REG   TOCCR        TOCCR        8|16|32   8|16|32   8       0x774      -            -             -            -          0           W|R      TRUE      -
//   %%REG   ULLMTBR      ULLMTBR      8|16|32   8|16|32   32      0x780      0            2             -            0x4        0x7FFE0000  D        FALSE      -
//   %%REG   TOCER        TOCER        8|16|32   8|16|32   8       0x790      -            -             -            -          0           R        TRUE      -
//   %%REG   SYNCER       SYNCER       8|16|32   8|16|32   8       0x794      -            -             -            -          0           R        FALSE      -
//   %%REG   ULER         ULER         8|16|32   8|16|32   8       0x798      -            -             -            -          0           D        FALSE      -
//   %%REG   OWER         OWER         8|16|32   8|16|32   8       0x79C      -            -             -            -          0           R        TRUE      -
//   %%REG   PER          PER          8|16|32   8|16|32   8       0x7A0      -            -             -            -          0           R        TRUE      -
//   %%REG   IDER         IDER         8|16|32   8|16|32   8       0x7A4      -            -             -            -          0           R        TRUE      -
//   %%REG   ECR          ECR          8|16|32   8|16|32   16      0x7A8      -            -             -            -          0           W|R      TRUE      -
//   %%REG   STPDCR       STPDCR       8|16|32   8|16|32   8       0x7B0      0            5             -            0x4        0           W|R      TRUE      -
//   %%REG   VCULLMTBR    VCULLMTBR         32   8|16|32   32      0x800      0            7             -            0x4        0           D        TRUE      -
//   %%REG   VCLMINTER1   VCLMINTER1   8|16|32   8|16|32   32      0x840      -            -             -            -          0           W|R      TRUE      -
//   %%REG   VCLMINTER2   VCLMINTER2   8|16|32   8|16|32   32      0x844      -            -             -            -          0           W|R      TRUE      -
//   %%REG   VCLMINTER3   VCLMINTER3   8|16|32   8|16|32   32      0x848      -            -             -            -          0           W|R      FALSE      -
//   %%REG   PWVCLMINTER  PWVCLMINTER  8|16|32   8|16|32   8       0x84C      -            -             -            -          0           W|R      TRUE      -
//   %%REG   SDVCLMINTER  SDVCLMINTER  8|16|32   8|16|32   8       0x850      -            -             -            -          0           W|R      TRUE      -
//   %%REG   VCLMSR1      VCLMSR1      8|16|32   8|16|32   32      0x860      -            -             -            -          0           R        TRUE      -
//   %%REG   VCLMSR2      VCLMSR2      8|16|32   8|16|32   32      0x864      -            -             -            -          0           R        TRUE      -
//   %%REG   VCLMSR3      VCLMSR3      8|16|32   8|16|32   32      0x868      -            -             -            -          0           D        FALSE      -
//   %%REG   PWVCLMSR     PWVCLMSR     8|16|32   8|16|32   32      0x86C      -            -             -            -          0           R        TRUE      -
//   %%REG   SDVCLMSR     SDVCLMSR     8|16|32   8|16|32   32      0x870      -            -             -            -          0           R        TRUE     -
//   %%REG   SGULCR       SGULCR       8|16|32   8|16|32   16      0x880      0            4             -            0x4        0           R        TRUE      -
//   %%REG   SGDIAGULCR   SGDIAGULCR   8|16|32   8|16|32   16      0x894      -            -             -            -          0           R        TRUE     -
//   %%REG   VCLMSCR1     VCLMSCR1     8|16|32   8|16|32   32      0x8A0      -            -             -            -          0           D        TRUE      -
//   %%REG   VCLMSCR2     VCLMSCR2     8|16|32   8|16|32   32      0x8A4      -            -             -            -          0           D        TRUE      -
//   %%REG   VCLMSCR3     VCLMSCR3     8|16|32   8|16|32   32      0x8A8      -            -             -            -          0           D        FALSE      -
//   %%REG   PWVCLMSCR    PWVCLMSCR    8|16|32   8|16|32   8       0x8AC      -            -             -            -          0           R:0|W    TRUE      -
//   %%REG   SDVCLMSCR    SDVCLMSCR    8|16|32   8|16|32   8       0x8B0      -            -             -            -          0           R:0|W    TRUE     -
//   %%REG   SGULCCR      SGULCCR      8|16|32   8|16|32   8       0x8B4      -            -             -            -          0           R:0|W    TRUE      -
//   %%REG   VCLMASCR     VCLMASCR     8|16|32   8|16|32   8       0x8B8      -            -             -            -          0           R:0|W    TRUE      -
//   %%REG   TRMCR        TRMCR        8|16|32   8|16|32   16      0x8C0      -            -             -            -          0           -        FALSE      - 
//   %%REG   ADTSTRA      ADTSTRA      8|16|32   8|16|32   32      0x8C4      -            -             -            -          0           W|R      FALSE      - 
//   %%REG   ADTSTRB      ADTSTRB      8|16|32   8|16|32   16      0x8C8      -            -             -            -          0           W|R      FALSE      - 
//   %%REG   ADTSTRC      ADTSTRC      8|16|32   8|16|32   16      0x8CC      -            -             -            -          0           W|R      FALSE      - 
//   %%REG   ADTSTRD      ADTSTRD      8|16|32   8|16|32   8       0x8D0      -            -             -            -          0           W|R      FALSE      - 
//   %%REG   SGTSEL       SGTSEL       8|16|32   8|16|32   32      0x1000     0            4             -            0x4        0           W|R      TRUE      - 
// 
// %REG_NAME  VCR
//    %%TITLE     name       upper   lower     init    access      support     callback    value    
//    %%BIT       VCULLMTBS  31      28        0       W|R         TRUE        -           -
//    %%BIT       WTTS       27      24        0       W|R         TRUE        -           -
//    %%BIT       DFENT     20      20        0       W|R         TRUE        -           - 
//    %%BIT       DFTAG     19      16        0       W|R         TRUE        -           - 
//    %%BIT       CNVCLS     14      11        0       W|R         TRUE        -           -
//    %%BIT       MPXV       10      8         0       W|R         TRUE        -           -
//    %%BIT       ADIE       7       7         0       W|R         TRUE        -           - 
//    %%BIT       GCTRL      5       0         0       W|R         TRUE        W           - 
// 
// %REG_NAME  PWDVCR
//    %%TITLE     name       upper   lower     init    access      support     callback    value    
//    %%BIT       WTTS       19      16        0       R           TRUE        -           -
//    %%BIT       MPXE       15      15        0       R           TRUE        -           -
//    %%BIT       MPXV       14      12        0       R           TRUE        -           -
//    %%BIT       VCULLMTBS  11      8         0       R           TRUE        -           -
//    %%BIT       GCTRL      5       0         0       R           TRUE        -           -
// 
// %REG_NAME  SGDIAGVCR
//    %%TITLE     name       upper   lower     init    access      support     callback    value    
//    %%BIT       CNVCLS     3       0         0       W|R         TRUE        W           -
// 
// %REG_NAME  DR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       DR1        31      16        0       R           TRUE        -
//    %%BIT       DR0        15      0         0       R           TRUE        -
// 
// %REG_NAME  PWDDR
//    %%TITLE     name       upper   lower     init    access      support     callback    value    
//    %%BIT       PWDDR      15      0         0       R           TRUE        -           -
// 
// %REG_NAME  SGDIAGDR01
//    %%TITLE     name       upper   lower     init    access      support     callback    value    
//    %%BIT       SGDIAGDR1  31      16        0       R           TRUE        -           -
//    %%BIT       SGDIAGDR0  15      0         0       R           TRUE        -           -
// 
// %REG_NAME  SGDIAGDR2
//    %%TITLE     name       upper   lower     init    access      support     callback    value    
//    %%BIT       SGDIAGDR2  15      0         0       R           TRUE        -           -
// 
// %REG_NAME  SGDIAGSRR
//    %%TITLE     name       upper   lower     init    access      support     callback    value    
//    %%BIT       SRR1       31      16        0       R           TRUE        -           -
//    %%BIT       SRR0       15      0         0       R           TRUE        -           -
// 
// %REG_NAME  DIR       
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       MPXE       31      31        0       R           TRUE        -         
//    %%BIT       MPXV       30      28        0       R           TRUE        -         
//    %%BIT       IDEF       26      26        0       R           TRUE        -         
//    %%BIT       WFLAG      25      25        0       R           TRUE        -         
//    %%BIT       PRTY       24      24        0       R           TRUE        -
//    %%BIT       ID         21      16        0       R           TRUE        -
//    %%BIT       DRn        15      0         0       R           TRUE        -
// 
// %REG_NAME  PWDDIR       
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       MPXE       31      31        0       R           TRUE        -         
//    %%BIT       MPXV       30      28        0       R           TRUE        -         
//    %%BIT       IDEF       26      26        0       R           TRUE        -         
//    %%BIT       WFLAG      25      25        0       R           TRUE        -         
//    %%BIT       PRTY       24      24        0       R           TRUE        -
//    %%BIT       ID         21      16        0       R           TRUE        -
//    %%BIT       PWDDR      15      0         0       R           TRUE        -
// 
// %REG_NAME  SGDIAGDIR       
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       IDEF       26      26        0       R           TRUE       -         
//    %%BIT       WFLAG      25      25        0       R           TRUE       -         
//    %%BIT       PRTY       24      24        0       R           TRUE       -
//    %%BIT       ID         21      16        0       R           TRUE       -
//    %%BIT       SGDIAGDRk  15      0         0       R           TRUE       -
// 
// %REG_NAME  SGSTCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       SGST       0       0         0       W|R         TRUE        W
// 
// %REG_NAME  SGSTPCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       SGSTP      0       0         0       D           TRUE        W
// 
// %REG_NAME  SGCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       ADTSTARTE  7       7         0       W|R         TRUE        -
//    %%BIT       ADSTARTE   6       6         0       W|R         TRUE        -
//    %%BIT       SCANMD     5       5         0       W|R         TRUE        -
//    %%BIT       ADIE       4       4         0       W|R         TRUE        W
//    %%BIT       TRGMD      1       0         0       W|R         TRUE        -
// 
// %REG_NAME  SGVCPR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       VCEP       14      8         0       D           TRUE        -
//    %%BIT       VCSP       6       0         0       D           TRUE        W
// 
// %REG_NAME  SGMCYCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       MCYC       7       0         0       W|R         TRUE        W
// 
// %REG_NAME  SGSR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       ADTACT     2       2         0       R           TRUE        -
//    %%BIT       SGACT      1       1         0       R           TRUE        -
// 
// %REG_NAME  ULLMSR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       ULS        1       0         0       D           FALSE       -
// 
// %REG_NAME SGVCSP
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       VCSP       6       0         0       D           TRUE         W
// 
// %REG_NAME SGVCEP
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       VCEP       6       0         0       D           TRUE         W
// 
// %REG_NAME  ADTSTCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       ADTST      0       0         0       W|R         TRUE        W
// 
// %REG_NAME  ADTENDCR  
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       ADTEND     0       0         0       W|R         TRUE        W
// 
// %REG_NAME  ADTIPR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       ADTIP      20      0         0       W|R         TRUE        W
// 
// %REG_NAME  ADTPRR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       ADTPR      20      0         2097151 W|R         TRUE        W
// 
// %REG_NAME  PWDCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       PWE        0       0         0       W|R         TRUE        W
// 
// %REG_NAME  PWDSGCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       TRGMD      0       0         0       W|R         TRUE        W
// 
// %REG_NAME  PWDSGSTCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       SGST       0       0         0       R:0|W       FALSE       -
// 
// %REG_NAME  PWDSGSR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       PWSGC      0       0         0       W|R         FALSE       -
// 
// %REG_NAME  SGDIAGSTCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       SGST       0       0         0       R:0|W       TRUE       W
// 
// %REG_NAME  SGDIAGSTPCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       SGSTP      0       0         0       R:0|W       TRUE       W
// 
// %REG_NAME  SGDIAGCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       VCULLMTBS1 23      20        0       W|R         TRUE       -
//    %%BIT       VCULLMTBS0 19      16        0       W|R         TRUE       -
//    %%BIT       SMD        12      12        0       W|R         TRUE       -
//    %%BIT       ISM        10      10        0       W|R         TRUE       -
//    %%BIT       SDPS       9       9         0       W|R         TRUE       -
//    %%BIT       ADIE       8       8         0       W|R         TRUE       -
//    %%BIT       TRGMD      0       0         0       W|R         TRUE       W
// 
// %REG_NAME  SGDIAGPCCR0
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       SDPCE31    31      31        0       W|R         TRUE       -
//    %%BIT       SDPCE30    30      30        0       W|R         TRUE       -
//    %%BIT       SDPCE29    29      29        0       W|R         TRUE       -
//    %%BIT       SDPCE28    28      28        0       W|R         TRUE       -
//    %%BIT       SDPCE27    27      27        0       W|R         TRUE       -
//    %%BIT       SDPCE26    26      26        0       W|R         TRUE       -
//    %%BIT       SDPCE25    25      25        0       W|R         TRUE       -
//    %%BIT       SDPCE24    24      24        0       W|R         TRUE       -
//    %%BIT       SDPCE23    23      23        0       W|R         TRUE       -
//    %%BIT       SDPCE22    22      22        0       W|R         TRUE       -
//    %%BIT       SDPCE21    21      21        0       W|R         TRUE       -
//    %%BIT       SDPCE20    20      20        0       W|R         TRUE       -
//    %%BIT       SDPCE19    19      19        0       W|R         TRUE       -
//    %%BIT       SDPCE18    18      18        0       W|R         TRUE       -
//    %%BIT       SDPCE17    17      17        0       W|R         TRUE       -
//    %%BIT       SDPCE16    16      16        0       W|R         TRUE       -
//    %%BIT       SDPCE15    15      15        0       W|R         TRUE       -
//    %%BIT       SDPCE14    14      14        0       W|R         TRUE       -
//    %%BIT       SDPCE13    13      13        0       W|R         TRUE       -
//    %%BIT       SDPCE12    12      12        0       W|R         TRUE       -
//    %%BIT       SDPCE11    11      11        0       W|R         TRUE       -
//    %%BIT       SDPCE10    10      10        0       W|R         TRUE       -
//    %%BIT       SDPCE9     9       9         0       W|R         TRUE       -
//    %%BIT       SDPCE8     8       8         0       W|R         TRUE       -
//    %%BIT       SDPCE7     7       7         0       W|R         TRUE       -
//    %%BIT       SDPCE6     6       6         0       W|R         TRUE       -
//    %%BIT       SDPCE5     5       5         0       W|R         TRUE       -
//    %%BIT       SDPCE4     4       4         0       W|R         TRUE       -
//    %%BIT       SDPCE3     3       3         0       W|R         TRUE       -
//    %%BIT       SDPCE2     2       2         0       W|R         TRUE       -
//    %%BIT       SDPCE1     1       1         0       W|R         TRUE       -
//    %%BIT       SDPCE0     0       0         0       W|R         TRUE       W
// 
// %REG_NAME  SGDIAGPCCR1
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       SDPCE63    31      31        0       W|R         TRUE       -
//    %%BIT       SDPCE62    30      30        0       W|R         TRUE       -
//    %%BIT       SDPCE61    29      29        0       W|R         TRUE       -
//    %%BIT       SDPCE60    28      28        0       W|R         TRUE       -
//    %%BIT       SDPCE59    27      27        0       W|R         TRUE       -
//    %%BIT       SDPCE58    26      26        0       W|R         TRUE       -
//    %%BIT       SDPCE57    25      25        0       W|R         TRUE       -
//    %%BIT       SDPCE56    24      24        0       W|R         TRUE       -
//    %%BIT       SDPCE55    23      23        0       W|R         TRUE       -
//    %%BIT       SDPCE54    22      22        0       W|R         TRUE       -
//    %%BIT       SDPCE53    21      21        0       W|R         TRUE       -
//    %%BIT       SDPCE52    20      20        0       W|R         TRUE       -
//    %%BIT       SDPCE51    19      19        0       W|R         TRUE       -
//    %%BIT       SDPCE50    18      18        0       W|R         TRUE       -
//    %%BIT       SDPCE49    17      17        0       W|R         TRUE       -
//    %%BIT       SDPCE48    16      16        0       W|R         TRUE       -
//    %%BIT       SDPCE47    15      15        0       W|R         TRUE       -
//    %%BIT       SDPCE46    14      14        0       W|R         TRUE       -
//    %%BIT       SDPCE45    13      13        0       W|R         TRUE       -
//    %%BIT       SDPCE44    12      12        0       W|R         TRUE       -
//    %%BIT       SDPCE43    11      11        0       W|R         TRUE       -
//    %%BIT       SDPCE42    10      10        0       W|R         TRUE       -
//    %%BIT       SDPCE41    9       9         0       W|R         TRUE       -
//    %%BIT       SDPCE40    8       8         0       W|R         TRUE       -
//    %%BIT       SDPCE39    7       7         0       W|R         TRUE       -
//    %%BIT       SDPCE38    6       6         0       W|R         TRUE       -
//    %%BIT       SDPCE37    5       5         0       W|R         TRUE       -
//    %%BIT       SDPCE36    4       4         0       W|R         TRUE       -
//    %%BIT       SDPCE35    3       3         0       W|R         TRUE       -
//    %%BIT       SDPCE34    2       2         0       W|R         TRUE       -
//    %%BIT       SDPCE33    1       1         0       W|R         TRUE       -
//    %%BIT       SDPCE32    0       0         0       W|R         TRUE       W
// 
// %REG_NAME  SGDIAGSR
//    %%TITLE     name       upper   lower     init    access      support     callback   
//    %%BIT       SDACT      1       1         0       R           TRUE       -
// 
// %REG_NAME  SGSTR
//    %%TITLE     name       upper   lower     init    access      support     callback   
//    %%BIT       ADTACT     13      12        0       R           TRUE        -
//    %%BIT       SHACT      7       7         0       R           TRUE        -
//    %%BIT       SVSACT     6       6         0       R           TRUE        -
//    %%BIT       SGACT      5       1         0       R           TRUE        -
//    %%BIT       SDACT      0       0         0       R           TRUE        -
// 
// %REG_NAME  ADHALTR
//    %%TITLE     name       upper   lower     init    access      support     callback   
//    %%BIT       HALT        0        0       0       W|R         TRUE         W
// 
// %REG_NAME  ADCR1
//    %%TITLE     name       upper   lower     init    access      support     callback
//    %%BIT       SUSMTD      1        0       0       D           TRUE         W
// 
// %REG_NAME  ADCR2
//    %%TITLE     name       upper   lower     init    access      support     callback
//    %%BIT       DFMT       6        4        0       D           TRUE         W
//    %%BIT       ADDNT      0        0        0       D           TRUE         -
// 
// %REG_NAME  SMPCR   
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       EXSMPT     23      16        0       D           TRUE        -
//    %%BIT       BUFAMPD    15      15        0       D           TRUE        -
//    %%BIT       SMPTS      12      12        0       D           TRUE        -
//    %%BIT       SMPT       7       0         0       D           TRUE        W
// 
// %REG_NAME  MPXCURCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       MSKCFMT    3       0         0       W|R         TRUE        W
// 
// %REG_NAME  MPXINTER
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       ADMPXIE    0       0         0       D           TRUE        W
// 
// %REG_NAME  MPXCURR1
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       MSKC       31      16        0       R           TRUE        -
//    %%BIT       MPXCMD     15      8         0       R           TRUE        -
//    %%BIT       MPXCUR     4       0         0       R           TRUE        -
// 
// %REG_NAME  MPXCURR2
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       MPXCUR     2       0         0       R           TRUE        -
// 
// %REG_NAME  MPXCMDR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       MPXCMD     7       0         0       W|R         TRUE        W
// 
// %REG_NAME MPXOWR
//    %%TITLE     name       upper   lower     init    access      support     callback    value
//    %%BIT       MPXOW      3       0         0       W|R         TRUE        W           "0x0-0xA"
// 
// %REG_NAME  DFASENTSGER
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       DFENTSG4E  12      12        0       D           TRUE        -
//    %%BIT       DFENTSG3E  11      11        0       D           TRUE        -
//    %%BIT       DFENTSG2E  10      10        0       D           TRUE        -
//    %%BIT       DFENTSG1E  9       9         0       D           TRUE        -
//    %%BIT       DFENTSG0E  8       8         0       D           TRUE        -
//    %%BIT       ASENTSG4E  4       4         0       D           TRUE        -
//    %%BIT       ASENTSG3E  3       3         0       D           TRUE        -
//    %%BIT       ASENTSG2E  2       2         0       D           TRUE        -
//    %%BIT       ASENTSG1E  1       1         0       D           TRUE        -
//    %%BIT       ASENTSG0E  0       0         0       D           TRUE        W
// 
// #%REG_NAME  GTMENTSGER
// #   %%TITLE     name       upper   lower     init    access      support     callback    
// #   %%BIT       GTMENTSG4E 4       4         0       D           TRUE        -
// #   %%BIT       GTMENTSG3E 3       3         0       D           TRUE        -
// #   %%BIT       GTMENTSG2E 2       2         0       D           TRUE        -
// #   %%BIT       GTMENTSG1E 1       1         0       D           TRUE        -
// #   %%BIT       GTMENTSG0E 0       0         0       D           TRUE        W
// 
// %REG_NAME  ADENDP
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       ENDP       6       0         0       D           TRUE        W
// 
// %REG_NAME  THSMPSTCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       SMPST       0       0        0       D           TRUE        W
// 
// %REG_NAME  THSTPCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       THSTP        0       0       0       D           TRUE        W
// 
// %REG_NAME  THCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       ASMPMSK      0       0       0       D           TRUE        W
// 
// %REG_NAME  THAHLDSTCR  
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       HLDST      0       0         0       D           TRUE        W
// 
// %REG_NAME  THBHLDSTCR  
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       HLDST      0       0         0       D           TRUE         W
// 
// %REG_NAME  THGSR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       TH5GS       10      10       0       D           TRUE        -
//    %%BIT       TH4GS       8       8        0       D           TRUE        -
//    %%BIT       TH3GS       6       6        0       D           TRUE        -
//    %%BIT       TH2GS       4       4        0       D           TRUE        -
//    %%BIT       TH1GS       2       2        0       D           TRUE        -
//    %%BIT       TH0GS       0       0        0       D           TRUE        W
// 
// %REG_NAME  THER
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       TH5E       5       5         0       D           TRUE        -
//    %%BIT       TH4E       4       4         0       D           TRUE        -
//    %%BIT       TH3E       3       3         0       D           TRUE        -
//    %%BIT       TH2E       2       2         0       D           TRUE        -
//    %%BIT       TH1E       1       1         0       D           TRUE        -
//    %%BIT       TH0E       0       0         0       D           TRUE        W
// 
// %REG_NAME  THACR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       HLDCTE     5       5         0       D           TRUE        -
//    %%BIT       HLDTE      4       4         0       D           TRUE        -
//    %%BIT       SGS        1       0         0       D           TRUE        W
// 
// %REG_NAME  THBCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       HLDCTE     5       5         0       D           TRUE         -
//    %%BIT       HLDTE      4       4         0       D           TRUE         -
//    %%BIT       SGS        1       0         0       D           TRUE         W
// 
// %REG_NAME  WAITTR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       WAITTIME   13      0         0       W|R         TRUE        W
// 
// %REG_NAME  EMUCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       SVSDIS     0       0         0       W|R         TRUE         W
// 
// %REG_NAME  TDCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       THSDE      7        7        0       D           TRUE        -
//    %%BIT       TDLV       1        0        0       D           TRUE        W 
// 
// %REG_NAME  ODCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       WADDE      8       8         0       D           TRUE        W
//    %%BIT       ODPW       4       0         0       D           FALSE       -
// 
// %REG_NAME  IEDCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       IDSCE      0       0         0       W|R         FALSE       -
// 
// %REG_NAME  SFTCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       TOCEIE     6       6         0       D           TRUE        -
//    %%BIT       SYNCEIE    5       5         0       D           FALSE       -
//    %%BIT       RDCLRE     4       4         0       D           TRUE        -
//    %%BIT       ULEIE      3       3         0       D           FALSE       -
//    %%BIT       OWEIE      2       2         0       D           TRUE        -
//    %%BIT       PEIE       1       1         0       D           TRUE        -
//    %%BIT       IDEIE      0       0         0       D           TRUE        W
// 
// %REG_NAME  TOCCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       TOCE       0       0         0       W|R         TRUE        W
// 
// %REG_NAME  ULLMTBR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       ULMTB      31      16        32766   D           FALSE       -
//    %%BIT       LLMTB      15      0         0       D           FALSE       -
// 
// %REG_NAME  TOCER
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       TOCESG     5       1         0       R           TRUE        -
//    %%BIT       TOCESD     0       0         0       R           TRUE        R
// 
// %REG_NAME  SYNCER
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       SYNCE       7       7        0       R           FALSE        -
// 
// %REG_NAME  ULER      
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       ULE        7       7         0       D           FALSE       -
//    %%BIT       ULECAP     6       0         0       D           FALSE       -
// 
// %REG_NAME  OWER      
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       OWE        7       7         0       R           TRUE        -
//    %%BIT       OWECAP     6       0         0       R           TRUE        -
// 
// %REG_NAME  PER       
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT        PE        7       7         0       R           TRUE        -
//    %%BIT        PECAP     6       0         0       R           TRUE        -
// 
// %REG_NAME  IDER      
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       IDE         7       7        0       R           TRUE        -
//    %%BIT       IDECAP      6       0        0       R           TRUE        -
// 
// %REG_NAME  ECR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       TOCESGC    13       9        0       W|R         TRUE        -
//    %%BIT       TOCESDC    8        8        0       W|R         TRUE        -
//    %%BIT       SYNCEC     5        5        0       W|R         FALSE       -
//    %%BIT       ULEC       3        3        0       W|R         FALSE       -
//    %%BIT       OWEC       2        2        0       W|R         TRUE        -
//    %%BIT       PEC        1        1        0       W|R         TRUE        -
//    %%BIT       IDEC       0        0        0       W|R         TRUE        W
// 
// %REG_NAME  STPDCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       SPDE       0        0        0       W|R         TRUE        W
// 
// 
// %REG_NAME  VCULLMTBR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       VCULMTB    31      16        32766   D           TRUE        W
//    %%BIT       VCLLMTB    15      0         0       D           TRUE        -
// 
// %REG_NAME  VCLMINTER1
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       ADUL31IE   31      31        0       W|R         TRUE        -       
//    %%BIT       ADUL30IE   30      30        0       W|R         TRUE        -
//    %%BIT       ADUL29IE   29      29        0       W|R         TRUE        -
//    %%BIT       ADUL28IE   28      28        0       W|R         TRUE        -
//    %%BIT       ADUL27IE   27      27        0       W|R         TRUE        -
//    %%BIT       ADUL26IE   26      26        0       W|R         TRUE        -
//    %%BIT       ADUL25IE   25      25        0       W|R         TRUE        -
//    %%BIT       ADUL24IE   24      24        0       W|R         TRUE        -
//    %%BIT       ADUL23IE   23      23        0       W|R         TRUE        -
//    %%BIT       ADUL22IE   22      22        0       W|R         TRUE        -
//    %%BIT       ADUL21IE   21      21        0       W|R         TRUE        -
//    %%BIT       ADUL20IE   20      20        0       W|R         TRUE        -
//    %%BIT       ADUL19IE   19      19        0       W|R         TRUE        -
//    %%BIT       ADUL18IE   18      18        0       W|R         TRUE        -
//    %%BIT       ADUL17IE   17      17        0       W|R         TRUE        -
//    %%BIT       ADUL16IE   16      16        0       W|R         TRUE        -
//    %%BIT       ADUL15IE   15      15        0       W|R         TRUE        -
//    %%BIT       ADUL14IE   14      14        0       W|R         TRUE        -
//    %%BIT       ADUL13IE   13      13        0       W|R         TRUE        -
//    %%BIT       ADUL12IE   12      12        0       W|R         TRUE        -
//    %%BIT       ADUL11IE   11      11        0       W|R         TRUE        -
//    %%BIT       ADUL10IE   10      10        0       W|R         TRUE        -
//    %%BIT       ADUL09IE   9       9         0       W|R         TRUE        -
//    %%BIT       ADUL08IE   8       8         0       W|R         TRUE        -
//    %%BIT       ADUL07IE   7       7         0       W|R         TRUE        -
//    %%BIT       ADUL06IE   6       6         0       W|R         TRUE        -
//    %%BIT       ADUL05IE   5       5         0       W|R         TRUE        -
//    %%BIT       ADUL04IE   4       4         0       W|R         TRUE        -
//    %%BIT       ADUL03IE   3       3         0       W|R         TRUE        -
//    %%BIT       ADUL02IE   2       2         0       W|R         TRUE        -
//    %%BIT       ADUL01IE   1       1         0       W|R         TRUE        -
//    %%BIT       ADUL00IE   0       0         0       W|R         TRUE        W
// 
// %REG_NAME  VCLMINTER2
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       ADUL63IE   31      31        0       W|R         TRUE        -
//    %%BIT       ADUL62IE   30      30        0       W|R         TRUE        -
//    %%BIT       ADUL61IE   29      29        0       W|R         TRUE        -
//    %%BIT       ADUL60IE   28      28        0       W|R         TRUE        -
//    %%BIT       ADUL59IE   27      27        0       W|R         TRUE        -
//    %%BIT       ADUL58IE   26      26        0       W|R         TRUE        -
//    %%BIT       ADUL57IE   25      25        0       W|R         TRUE        -
//    %%BIT       ADUL56IE   24      24        0       W|R         TRUE        -
//    %%BIT       ADUL55IE   23      23        0       W|R         TRUE        -
//    %%BIT       ADUL54IE   22      22        0       W|R         TRUE        -
//    %%BIT       ADUL53IE   21      21        0       W|R         TRUE        -
//    %%BIT       ADUL52IE   20      20        0       W|R         TRUE        -
//    %%BIT       ADUL51IE   19      19        0       W|R         TRUE        -
//    %%BIT       ADUL50IE   18      18        0       W|R         TRUE        -
//    %%BIT       ADUL49IE   17      17        0       W|R         TRUE        -
//    %%BIT       ADUL48IE   16      16        0       W|R         TRUE        -
//    %%BIT       ADUL47IE   15      15        0       W|R         TRUE        -
//    %%BIT       ADUL46IE   14      14        0       W|R         TRUE        -
//    %%BIT       ADUL45IE   13      13        0       W|R         TRUE        -
//    %%BIT       ADUL44IE   12      12        0       W|R         TRUE        -
//    %%BIT       ADUL43IE   11      11        0       W|R         TRUE        -
//    %%BIT       ADUL42IE   10      10        0       W|R         TRUE        -
//    %%BIT       ADUL41IE   9       9         0       W|R         TRUE        -
//    %%BIT       ADUL40IE   8       8         0       W|R         TRUE        -
//    %%BIT       ADUL39IE   7       7         0       W|R         TRUE        -
//    %%BIT       ADUL38IE   6       6         0       W|R         TRUE        -
//    %%BIT       ADUL37IE   5       5         0       W|R         TRUE        -
//    %%BIT       ADUL36IE   4       4         0       W|R         TRUE        -
//    %%BIT       ADUL35IE   3       3         0       W|R         TRUE        -
//    %%BIT       ADUL34IE   2       2         0       W|R         TRUE        -
//    %%BIT       ADUL33IE   1       1         0       W|R         TRUE        -
//    %%BIT       ADUL32IE   0       0         0       W|R         TRUE        W
// 
// %REG_NAME  VCLMINTER3
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       ADUL95IE   31      31        0       W|R         FALSE        -
//    %%BIT       ADUL94IE   30      30        0       W|R         FALSE        -
//    %%BIT       ADUL93IE   29      29        0       W|R         FALSE        -
//    %%BIT       ADUL92IE   28      28        0       W|R         FALSE        -
//    %%BIT       ADUL91IE   27      27        0       W|R         FALSE        -
//    %%BIT       ADUL90IE   26      26        0       W|R         FALSE        -
//    %%BIT       ADUL89IE   25      25        0       W|R         FALSE        -
//    %%BIT       ADUL88IE   24      24        0       W|R         FALSE        -
//    %%BIT       ADUL87IE   23      23        0       W|R         FALSE        -
//    %%BIT       ADUL86IE   22      22        0       W|R         FALSE        -
//    %%BIT       ADUL85IE   21      21        0       W|R         FALSE        -
//    %%BIT       ADUL84IE   20      20        0       W|R         FALSE        -
//    %%BIT       ADUL83IE   19      19        0       W|R         FALSE        -
//    %%BIT       ADUL82IE   18      18        0       W|R         FALSE        -
//    %%BIT       ADUL81IE   17      17        0       W|R         FALSE        -
//    %%BIT       ADUL80IE   16      16        0       W|R         FALSE        -
//    %%BIT       ADUL79IE   15      15        0       W|R         FALSE        -
//    %%BIT       ADUL78IE   14      14        0       W|R         FALSE        -
//    %%BIT       ADUL77IE   13      13        0       W|R         FALSE        -
//    %%BIT       ADUL76IE   12      12        0       W|R         FALSE        -
//    %%BIT       ADUL75IE   11      11        0       W|R         FALSE        -
//    %%BIT       ADUL74IE   10      10        0       W|R         FALSE        -
//    %%BIT       ADUL73IE   9       9         0       W|R         FALSE        -
//    %%BIT       ADUL72IE   8       8         0       W|R         FALSE        -
//    %%BIT       ADUL71IE   7       7         0       W|R         FALSE        -
//    %%BIT       ADUL70IE   6       6         0       W|R         FALSE        -
//    %%BIT       ADUL69IE   5       5         0       W|R         FALSE        -
//    %%BIT       ADUL68IE   4       4         0       W|R         FALSE        -
//    %%BIT       ADUL67IE   3       3         0       W|R         FALSE        -
//    %%BIT       ADUL66IE   2       2         0       W|R         FALSE        -
//    %%BIT       ADUL65IE   1       1         0       W|R         FALSE        -
//    %%BIT       ADUL64IE   0       0         0       W|R         FALSE        -
// 
// %REG_NAME  PWVCLMINTER
//    %%TITLE     name       upper   lower     init    access      support     callback
//    %%BIT       PWADULIE   0       0         0       W|R         TRUE        W
// 
// %REG_NAME  SDVCLMINTER
//    %%TITLE     name       upper   lower     init    access      support     callback
//    %%BIT       SDADULIE   0       0         0       W|R         TRUE        W
// 
// %REG_NAME  VCLMSR1
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       VC31LMS    31      31        0       R           TRUE        -       
//    %%BIT       VC30LMS    30      30        0       R           TRUE        -
//    %%BIT       VC29LMS    29      29        0       R           TRUE        -
//    %%BIT       VC28LMS    28      28        0       R           TRUE        -
//    %%BIT       VC27LMS    27      27        0       R           TRUE        -
//    %%BIT       VC26LMS    26      26        0       R           TRUE        -
//    %%BIT       VC25LMS    25      25        0       R           TRUE        -
//    %%BIT       VC24LMS    24      24        0       R           TRUE        -
//    %%BIT       VC23LMS    23      23        0       R           TRUE        -
//    %%BIT       VC22LMS    22      22        0       R           TRUE        -
//    %%BIT       VC21LMS    21      21        0       R           TRUE        -
//    %%BIT       VC20LMS    20      20        0       R           TRUE        -
//    %%BIT       VC19LMS    19      19        0       R           TRUE        -
//    %%BIT       VC18LMS    18      18        0       R           TRUE        -
//    %%BIT       VC17LMS    17      17        0       R           TRUE        -
//    %%BIT       VC16LMS    16      16        0       R           TRUE        -
//    %%BIT       VC15LMS    15      15        0       R           TRUE        -
//    %%BIT       VC14LMS    14      14        0       R           TRUE        -
//    %%BIT       VC13LMS    13      13        0       R           TRUE        -
//    %%BIT       VC12LMS    12      12        0       R           TRUE        -
//    %%BIT       VC11LMS    11      11        0       R           TRUE        -
//    %%BIT       VC10LMS    10      10        0       R           TRUE        -
//    %%BIT       VC09LMS    9       9         0       R           TRUE        -
//    %%BIT       VC08LMS    8       8         0       R           TRUE        -
//    %%BIT       VC07LMS    7       7         0       R           TRUE        -
//    %%BIT       VC06LMS    6       6         0       R           TRUE        -
//    %%BIT       VC05LMS    5       5         0       R           TRUE        -
//    %%BIT       VC04LMS    4       4         0       R           TRUE        -
//    %%BIT       VC03LMS    3       3         0       R           TRUE        -
//    %%BIT       VC02LMS    2       2         0       R           TRUE        -
//    %%BIT       VC01LMS    1       1         0       R           TRUE        -
//    %%BIT       VC00LMS    0       0         0       R           TRUE        -
// 
// %REG_NAME  VCLMSR2
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       VC63LMS    31      31        0       R           TRUE        -
//    %%BIT       VC62LMS    30      30        0       R           TRUE        -
//    %%BIT       VC61LMS    29      29        0       R           TRUE        -
//    %%BIT       VC60LMS    28      28        0       R           TRUE        -
//    %%BIT       VC59LMS    27      27        0       R           TRUE        -
//    %%BIT       VC58LMS    26      26        0       R           TRUE        -
//    %%BIT       VC57LMS    25      25        0       R           TRUE        -
//    %%BIT       VC56LMS    24      24        0       R           TRUE        -
//    %%BIT       VC55LMS    23      23        0       R           TRUE        -
//    %%BIT       VC54LMS    22      22        0       R           TRUE        -
//    %%BIT       VC53LMS    21      21        0       R           TRUE        -
//    %%BIT       VC52LMS    20      20        0       R           TRUE        -
//    %%BIT       VC51LMS    19      19        0       R           TRUE        -
//    %%BIT       VC50LMS    18      18        0       R           TRUE        -
//    %%BIT       VC49LMS    17      17        0       R           TRUE        -
//    %%BIT       VC48LMS    16      16        0       R           TRUE        -
//    %%BIT       VC47LMS    15      15        0       R           TRUE        -
//    %%BIT       VC46LMS    14      14        0       R           TRUE        -
//    %%BIT       VC45LMS    13      13        0       R           TRUE        -
//    %%BIT       VC44LMS    12      12        0       R           TRUE        -
//    %%BIT       VC43LMS    11      11        0       R           TRUE        -
//    %%BIT       VC42LMS    10      10        0       R           TRUE        -
//    %%BIT       VC41LMS    9       9         0       R           TRUE        -
//    %%BIT       VC40LMS    8       8         0       R           TRUE        -
//    %%BIT       VC39LMS    7       7         0       R           TRUE        -
//    %%BIT       VC38LMS    6       6         0       R           TRUE        -
//    %%BIT       VC37LMS    5       5         0       R           TRUE        -
//    %%BIT       VC36LMS    4       4         0       R           TRUE        -
//    %%BIT       VC35LMS    3       3         0       R           TRUE        -
//    %%BIT       VC34LMS    2       2         0       R           TRUE        -
//    %%BIT       VC33LMS    1       1         0       R           TRUE        -
//    %%BIT       VC32LMS    0       0         0       R           TRUE        -
// 
// %REG_NAME  VCLMSR3
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       VC95LMS    31      31        0       D           FALSE        -
//    %%BIT       VC94LMS    30      30        0       D           FALSE        -
//    %%BIT       VC93LMS    29      29        0       D           FALSE        -
//    %%BIT       VC92LMS    28      28        0       D           FALSE        -
//    %%BIT       VC91LMS    27      27        0       D           FALSE        -
//    %%BIT       VC90LMS    26      26        0       D           FALSE        -
//    %%BIT       VC89LMS    25      25        0       D           FALSE        -
//    %%BIT       VC88LMS    24      24        0       D           FALSE        -
//    %%BIT       VC87LMS    23      23        0       D           FALSE        -
//    %%BIT       VC86LMS    22      22        0       D           FALSE        -
//    %%BIT       VC85LMS    21      21        0       D           FALSE        -
//    %%BIT       VC84LMS    20      20        0       D           FALSE        -
//    %%BIT       VC83LMS    19      19        0       D           FALSE        -
//    %%BIT       VC82LMS    18      18        0       D           FALSE        -
//    %%BIT       VC81LMS    17      17        0       D           FALSE        -
//    %%BIT       VC80LMS    16      16        0       D           FALSE        -
//    %%BIT       VC79LMS    15      15        0       D           FALSE        -
//    %%BIT       VC78LMS    14      14        0       D           FALSE        -
//    %%BIT       VC77LMS    13      13        0       D           FALSE        -
//    %%BIT       VC76LMS    12      12        0       D           FALSE        -
//    %%BIT       VC75LMS    11      11        0       D           FALSE        -
//    %%BIT       VC74LMS    10      10        0       D           FALSE        -
//    %%BIT       VC73LMS    9       9         0       D           FALSE        -
//    %%BIT       VC72LMS    8       8         0       D           FALSE        -
//    %%BIT       VC71LMS    7       7         0       D           FALSE        -
//    %%BIT       VC70LMS    6       6         0       D           FALSE        -
//    %%BIT       VC69LMS    5       5         0       D           FALSE        -
//    %%BIT       VC68LMS    4       4         0       D           FALSE        -
//    %%BIT       VC67LMS    3       3         0       D           FALSE        -
//    %%BIT       VC66LMS    2       2         0       D           FALSE        -
//    %%BIT       VC65LMS    1       1         0       D           FALSE        -
//    %%BIT       VC64LMS    0       0         0       D           FALSE        -
// 
// %REG_NAME  PWVCLMSR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       PWVCLMS    0       0         0       R           TRUE        -
// 
// %REG_NAME  SDVCLMSR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       SR1LMS     2       2         0       R           TRUE        -
//    %%BIT       SR0LMS     1       1         0       R           TRUE        -
//    %%BIT       SDVC0LMS   0       0         0       R           TRUE        -
// 
// %REG_NAME  SGULCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       UE         15      15        0       R           TRUE        -
//    %%BIT       LE         14      14        0       R           TRUE        -
//    %%BIT       MPXE       11      11        0       R           TRUE        -
//    %%BIT       MPXV       10      8         0       R           TRUE        -
//    %%BIT       ULE        7       7         0       R           TRUE        -
//    %%BIT       ULPC       5       0         0       R           TRUE        -
// 
// 
// %REG_NAME  SGDIAGULCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       UE         15      15        0       R           TRUE        -
//    %%BIT       LE         14      14        0       R           TRUE        -
//    %%BIT       ULE        7       7         0       R           TRUE        -
//    %%BIT       ULPC       5       0         0       R           TRUE        -
// 
// %REG_NAME  VCLMSCR1
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       VC31LMSC   31      31        0       D           TRUE       -       
//    %%BIT       VC30LMSC   30      30        0       D           TRUE       -
//    %%BIT       VC29LMSC   29      29        0       D           TRUE       -
//    %%BIT       VC28LMSC   28      28        0       D           TRUE       -
//    %%BIT       VC27LMSC   27      27        0       D           TRUE       -
//    %%BIT       VC26LMSC   26      26        0       D           TRUE       -
//    %%BIT       VC25LMSC   25      25        0       D           TRUE       -
//    %%BIT       VC24LMSC   24      24        0       D           TRUE       -
//    %%BIT       VC23LMSC   23      23        0       D           TRUE       -
//    %%BIT       VC22LMSC   22      22        0       D           TRUE       -
//    %%BIT       VC21LMSC   21      21        0       D           TRUE       -
//    %%BIT       VC20LMSC   20      20        0       D           TRUE       -
//    %%BIT       VC19LMSC   19      19        0       D           TRUE       -
//    %%BIT       VC18LMSC   18      18        0       D           TRUE       -
//    %%BIT       VC17LMSC   17      17        0       D           TRUE       -
//    %%BIT       VC16LMSC   16      16        0       D           TRUE       -
//    %%BIT       VC15LMSC   15      15        0       D           TRUE       -
//    %%BIT       VC14LMSC   14      14        0       D           TRUE       -
//    %%BIT       VC13LMSC   13      13        0       D           TRUE       -
//    %%BIT       VC12LMSC   12      12        0       D           TRUE       -
//    %%BIT       VC11LMSC   11      11        0       D           TRUE       -
//    %%BIT       VC10LMSC   10      10        0       D           TRUE       -
//    %%BIT       VC09LMSC   9       9         0       D           TRUE       -
//    %%BIT       VC08LMSC   8       8         0       D           TRUE       -
//    %%BIT       VC07LMSC   7       7         0       D           TRUE       -
//    %%BIT       VC06LMSC   6       6         0       D           TRUE       -
//    %%BIT       VC05LMSC   5       5         0       D           TRUE       -
//    %%BIT       VC04LMSC   4       4         0       D           TRUE       -
//    %%BIT       VC03LMSC   3       3         0       D           TRUE       -
//    %%BIT       VC02LMSC   2       2         0       D           TRUE       -
//    %%BIT       VC01LMSC   1       1         0       D           TRUE       -
//    %%BIT       VC00LMSC   0       0         0       D           TRUE       W
// 
// %REG_NAME  VCLMSCR2
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       VC63LMSC   31      31        0       D           TRUE        -
//    %%BIT       VC62LMSC   30      30        0       D           TRUE        -
//    %%BIT       VC61LMSC   29      29        0       D           TRUE        -
//    %%BIT       VC60LMSC   28      28        0       D           TRUE        -
//    %%BIT       VC59LMSC   27      27        0       D           TRUE        -
//    %%BIT       VC58LMSC   26      26        0       D           TRUE        -
//    %%BIT       VC57LMSC   25      25        0       D           TRUE        -
//    %%BIT       VC56LMSC   24      24        0       D           TRUE        -
//    %%BIT       VC55LMSC   23      23        0       D           TRUE        -
//    %%BIT       VC54LMSC   22      22        0       D           TRUE        -
//    %%BIT       VC53LMSC   21      21        0       D           TRUE        -
//    %%BIT       VC52LMSC   20      20        0       D           TRUE        -
//    %%BIT       VC51LMSC   19      19        0       D           TRUE        -
//    %%BIT       VC50LMSC   18      18        0       D           TRUE        -
//    %%BIT       VC49LMSC   17      17        0       D           TRUE        -
//    %%BIT       VC48LMSC   16      16        0       D           TRUE        -
//    %%BIT       VC47LMSC   15      15        0       D           TRUE        -
//    %%BIT       VC46LMSC   14      14        0       D           TRUE        -
//    %%BIT       VC45LMSC   13      13        0       D           TRUE        -
//    %%BIT       VC44LMSC   12      12        0       D           TRUE        -
//    %%BIT       VC43LMSC   11      11        0       D           TRUE        -
//    %%BIT       VC42LMSC   10      10        0       D           TRUE        -
//    %%BIT       VC41LMSC   9       9         0       D           TRUE        -
//    %%BIT       VC40LMSC   8       8         0       D           TRUE        -
//    %%BIT       VC39LMSC   7       7         0       D           TRUE        -
//    %%BIT       VC38LMSC   6       6         0       D           TRUE        -
//    %%BIT       VC37LMSC   5       5         0       D           TRUE        -
//    %%BIT       VC36LMSC   4       4         0       D           TRUE        -
//    %%BIT       VC35LMSC   3       3         0       D           TRUE        -
//    %%BIT       VC34LMSC   2       2         0       D           TRUE        -
//    %%BIT       VC33LMSC   1       1         0       D           TRUE        -
//    %%BIT       VC32LMSC   0       0         0       D           TRUE        W
// 
// %REG_NAME  VCLMSCR3
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       VC95LMSC   31      31        0       D           FALSE        -
//    %%BIT       VC94LMSC   30      30        0       D           FALSE        -
//    %%BIT       VC93LMSC   29      29        0       D           FALSE        -
//    %%BIT       VC92LMSC   28      28        0       D           FALSE        -
//    %%BIT       VC91LMSC   27      27        0       D           FALSE        -
//    %%BIT       VC90LMSC   26      26        0       D           FALSE        -
//    %%BIT       VC89LMSC   25      25        0       D           FALSE        -
//    %%BIT       VC88LMSC   24      24        0       D           FALSE        -
//    %%BIT       VC87LMSC   23      23        0       D           FALSE        -
//    %%BIT       VC86LMSC   22      22        0       D           FALSE        -
//    %%BIT       VC85LMSC   21      21        0       D           FALSE        -
//    %%BIT       VC84LMSC   20      20        0       D           FALSE        -
//    %%BIT       VC83LMSC   19      19        0       D           FALSE        -
//    %%BIT       VC82LMSC   18      18        0       D           FALSE        -
//    %%BIT       VC81LMSC   17      17        0       D           FALSE        -
//    %%BIT       VC80LMSC   16      16        0       D           FALSE        -
//    %%BIT       VC79LMSC   15      15        0       D           FALSE        -
//    %%BIT       VC78LMSC   14      14        0       D           FALSE        -
//    %%BIT       VC77LMSC   13      13        0       D           FALSE        -
//    %%BIT       VC76LMSC   12      12        0       D           FALSE        -
//    %%BIT       VC75LMSC   11      11        0       D           FALSE        -
//    %%BIT       VC74LMSC   10      10        0       D           FALSE        -
//    %%BIT       VC73LMSC   9       9         0       D           FALSE        -
//    %%BIT       VC72LMSC   8       8         0       D           FALSE        -
//    %%BIT       VC71LMSC   7       7         0       D           FALSE        -
//    %%BIT       VC70LMSC   6       6         0       D           FALSE        -
//    %%BIT       VC69LMSC   5       5         0       D           FALSE        -
//    %%BIT       VC68LMSC   4       4         0       D           FALSE        -
//    %%BIT       VC67LMSC   3       3         0       D           FALSE        -
//    %%BIT       VC66LMSC   2       2         0       D           FALSE        -
//    %%BIT       VC65LMSC   1       1         0       D           FALSE        -
//    %%BIT       VC64LMSC   0       0         0       D           FALSE        -
// 
// %REG_NAME  PWVCLMSCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       PWVCLMSC   0       0         0       R:0|W       TRUE        W
// 
// %REG_NAME  SDVCLMSCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       SR1LMSC    2       2         0       R:0|W       TRUE        -
//    %%BIT       SR0LMSC    1       1         0       R:0|W       TRUE        -
//    %%BIT       SDVC0LMSC  0       0         0       R:0|W       TRUE        W
// 
// %REG_NAME  SGULCCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       SGULCC     5       1         0       R:0|W       TRUE        W
//    %%BIT       SDULCC     0       0         0       R:0|W       TRUE        -
// 
// %REG_NAME  VCLMASCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       ALLMSC     0       0         0       R:0|W       TRUE        W
// 
// %REG_NAME  TRMCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       TRMS       15      15        0       W|R         FALSE       -
//    %%BIT       TRMTTUNE   13      12        0       W|R         FALSE       -
//    %%BIT       TRMBTUNE   11      10        0       W|R         FALSE       -
//    %%BIT       TRMATUNE   9       8         0       W|R         FALSE       -
//    %%BIT       TRMT       5       4         0       R           FALSE       -
//    %%BIT       TRMB       3       2         0       R           FALSE       -
//    %%BIT       TRMA       1       0         0       R           FALSE       -
// 
// %REG_NAME  ADTSTRA 
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       SELAN      21      16        0       W|R         FALSE       -
//    %%BIT       ADTST      8       0        0        W|R         FALSE       -
//    
// %REG_NAME  ADTSTRB 
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       ADVAL      13      0        0        W|R         FALSE       -
// 
// %REG_NAME  ADTSTRC 
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       CKSTP      13      13        0       W|R         FALSE       -
//    %%BIT       ADMD       8       0         0       W|R         FALSE       -
// 
// %REG_NAME  ADTSTRD 
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       ADDISE     7       7         0       W|R         FALSE       -
//    %%BIT       ADDIS      4       0         0       W|R         FALSE       -
// 
// %REG_NAME  ADTSTRP1 
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       VMONFD     0       0         0       W|R         FALSE        -
// 
// %REG_NAME  SGTSEL
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       TxSEL5       5       5         0       W|R         TRUE        -
//    %%BIT       TxSEL4       4       4         0       W|R         TRUE        -
//    %%BIT       TxSEL3       3       3         0       W|R         TRUE        -
//    %%BIT       TxSEL2       2       2         0       W|R         TRUE        -
//    %%BIT       TxSEL1       1       1         0       W|R         TRUE        -
//    %%BIT       TxSEL0       0       0         0       W|R         TRUE        W
// 
// 
// ####################################################
// ## For handle Command
// ####################################################
// %CMD_BASEID  reg
// %CMD_NODUMP_API EnableInsertInput EnableDumpResult CommandCB AssertReset DumpProfile ClearProfile
// 
// ####################################################
// ## For PORTs
// ####################################################
// %HEADER_FILES adc_u2b.h
// %IMPLEMENTATION_FILES sarad_u2b.cpp sarad_u2b_regif.cpp adc_u2b.cpp adc_u2b_regif.cpp
// %PORT  ADmSG0TRG                     1         in        bool
// %PORT  ADmSG1TRG                     1         in        bool
// %PORT  ADmSG2TRG                     1         in        bool
// %PORT  ADmSG3TRG                     1         in        bool
// %PORT  ADmSG4TRG                     1         in        bool
// #%PORT  ADSTART_I                     1         in        bool
// #%PORT  ADSTART_O                     1         out       bool
// #%PORT  ADTSTART_I                    1         in        bool
// #%PORT  ADTSTART_O                    1         out       bool
// %PORT  ANm00                         64        in        double
// %PORT  ANm01                         64        in        double
// %PORT  ANm02                         64        in        double
// %PORT  ANm03                         64        in        double
// %PORT  ANm10                         64        in        double
// %PORT  ANm11                         64        in        double
// %PORT  ANm12                         64        in        double
// %PORT  ANm13                         64        in        double
// %PORT  ANm20                         64        in        double
// %PORT  ANm21                         64        in        double
// %PORT  ANm22                         64        in        double
// %PORT  ANm23                         64        in        double
// %PORT  ANm30                         64        in        double
// %PORT  ANm31                         64        in        double
// %PORT  ANm32                         64        in        double
// %PORT  ANm33                         64        in        double
// %PORT  ANm40                         64        in        double
// %PORT  ANm41                         64        in        double
// %PORT  ANm42                         64        in        double
// %PORT  ANm43                         64        in        double
// %PORT  ANm50                         64        in        double
// %PORT  ANm51                         64        in        double
// %PORT  ANm52                         64        in        double
// %PORT  ANm53                         64        in        double
// %PORT  ANm60                         64        in        double
// %PORT  ANm61                         64        in        double
// %PORT  ANm62                         64        in        double
// %PORT  ANm63                         64        in        double
// %PORT  ANm70                         64        in        double
// %PORT  ANm71                         64        in        double
// %PORT  ANm72                         64        in        double
// %PORT  ANm73                         64        in        double
// %PORT  ANm80                         64        in        double
// %PORT  ANm81                         64        in        double
// %PORT  ANm82                         64        in        double
// %PORT  ANm83                         64        in        double
// %PORT  ANm90                         64        in        double
// %PORT  ANm91                         64        in        double
// %PORT  ANm92                         64        in        double
// %PORT  ANm93                         64        in        double
// %PORT  IFVCHm                        7         in        sc_uint
// %PORT  IFRDm                         1         in        bool
// %PORT  IFREm                         1         in        bool
// %PORT  INT_ADm0                      1         out       bool
// %PORT  INT_ADm1                      1         out       bool
// %PORT  INT_ADm2                      1         out       bool
// %PORT  INT_ADm3                      1         out       bool
// %PORT  INT_ADm4                      1         out       bool
// %PORT  INT_MPXm                      1         out       bool
// %PORT  INT_ADEm                      1         out       bool
// %PORT  ADPEm                         1         out       bool
// %PORT  ADENDm0                       1         out       bool
// %PORT  ADENDm1                       1         out       bool
// %PORT  ADENDm2                       1         out       bool
// %PORT  ADENDm3                       1         out       bool
// %PORT  ADENDm4                       1         out       bool
// %PORT  INT_ULm                       1         out       bool
// %PORT  ADCm_IFDATA                   16        out       sc_uint
// %PORT  DFREQm                        1         out       bool
// #%PORT  ASREQm                        1         out       bool
// %PORT  DFTAGm                        4         out       sc_uint
// %PORT  DFDATAm                       16        out       sc_uint
// %PORT  PVCR_VALUEm                   18        in        sc_uint
// %PORT  PVCR_TRGm                     1         in        bool
// %PORT  PVCR_ENDm                     1         in        bool
// %PORT  PVCR_PWDDRm                   16        in        sc_uint
// %PORT  VCEND0[96]                    1         out       bool
// %PORT  VCULMO                        1         out       bool
// %PORT  VCLLMO                        1         out       bool
// %PORT  MPXCURm                       3         out       sc_uint
////////////////////////////////////////////////////////////////////////////////
/// @file adc_u2b_regif.cpp
/// @brief Register IF class of model ADC_U2B
/// $Id$
/// $Date$
/// $Revison$
/// $Author$
////////////////////////////////////////////////////////////////////////////////
#include "adc_u2b_regif.h"
#ifndef re_printf
#define re_printf get_fileline(__FILE__, __LINE__); _re_printf
#endif//re_printf

/// Constructor of Register IF class: define registers and bits
/// @return none
Cadc_u2b_regif::Cadc_u2b_regif(std::string name, uint buswidth)
    :vpcl::reg_super()
    #ifdef USR_CWR_SYSTEMC
    , cwmem("register", 0x1014)
    #endif
{
    uint FactorIndex_ADTSTCR_tmp[emNUM_ADTSTCR] = {   3,   4};
    uint FactorIndex_ADTENDCR_tmp[emNUM_ADTENDCR] = {   3,   4};
    uint FactorIndex_ADTIPR_tmp[emNUM_ADTIPR] = {   3,   4};
    uint FactorIndex_ADTPRR_tmp[emNUM_ADTPRR] = {   3,   4};
    for(uint i = 0; i < emNUM_ADTSTCR; i++) {
        mFactorIndexADTSTCR[i] = FactorIndex_ADTSTCR_tmp[i];
    }
    for(uint i = 0; i < emNUM_ADTENDCR; i++) {
        mFactorIndexADTENDCR[i] = FactorIndex_ADTENDCR_tmp[i];
    }
    for(uint i = 0; i < emNUM_ADTIPR; i++) {
        mFactorIndexADTIPR[i] = FactorIndex_ADTIPR_tmp[i];
    }
    for(uint i = 0; i < emNUM_ADTPRR; i++) {
        mFactorIndexADTPRR[i] = FactorIndex_ADTPRR_tmp[i];
    }

    CommandInit();
    PWDVCR      = new vpcl::re_register(0x0180, this, "PWDVCR"     , name.c_str());
    PWDDR       = new vpcl::re_register(0x0260, this, "PWDDR"      , name.c_str());
    SGDIAGDR01  = new vpcl::re_register(0x0264, this, "SGDIAGDR01" , name.c_str());
    SGDIAGDR2   = new vpcl::re_register(0x0268, this, "SGDIAGDR2"  , name.c_str());
    SGDIAGSRR   = new vpcl::re_register(0x026C, this, "SGDIAGSRR"  , name.c_str());
    PWDDIR      = new vpcl::re_register(0x0400, this, "PWDDIR"     , name.c_str());
    PWDCR       = new vpcl::re_register(0x0580, this, "PWDCR"      , name.c_str());
    PWDSGCR     = new vpcl::re_register(0x0584, this, "PWDSGCR"    , name.c_str());
    PWDSGSTCR   = new vpcl::re_register(0x0588, this, "PWDSGSTCR"  , name.c_str());
    PWDSGSR     = new vpcl::re_register(0x058C, this, "PWDSGSR"    , name.c_str());
    SGDIAGSTCR  = new vpcl::re_register(0x05C0, this, "SGDIAGSTCR" , name.c_str());
    SGDIAGSTPCR = new vpcl::re_register(0x05C4, this, "SGDIAGSTPCR", name.c_str());
    SGDIAGCR    = new vpcl::re_register(0x05D0, this, "SGDIAGCR"   , name.c_str());
    SGDIAGPCCR0 = new vpcl::re_register(0x05E0, this, "SGDIAGPCCR0", name.c_str());
    SGDIAGPCCR1 = new vpcl::re_register(0x05E4, this, "SGDIAGPCCR1", name.c_str());
    SGDIAGSR    = new vpcl::re_register(0x05F0, this, "SGDIAGSR"   , name.c_str());
    SGSTR       = new vpcl::re_register(0x0600, this, "SGSTR"      , name.c_str());
    ADHALTR     = new vpcl::re_register(0x0640, this, "ADHALTR"    , name.c_str());
    ADCR1       = new vpcl::re_register(0x0644, this, "ADCR1"      , name.c_str());
    ADCR2       = new vpcl::re_register(0x0648, this, "ADCR2"      , name.c_str());
    SMPCR       = new vpcl::re_register(0x064C, this, "SMPCR"      , name.c_str());
    MPXCURCR    = new vpcl::re_register(0x0650, this, "MPXCURCR"   , name.c_str());
    MPXINTER    = new vpcl::re_register(0x0654, this, "MPXINTER"   , name.c_str());
    MPXCURR1    = new vpcl::re_register(0x0658, this, "MPXCURR1"   , name.c_str());
    MPXCURR2    = new vpcl::re_register(0x065C, this, "MPXCURR2"   , name.c_str());
    MPXCMDR     = new vpcl::re_register(0x0660, this, "MPXCMDR"    , name.c_str());
    MPXOWR      = new vpcl::re_register(0x0664, this, "MPXOWR"     , name.c_str());
    DFASENTSGER = new vpcl::re_register(0x0670, this, "DFASENTSGER", name.c_str());
    THSMPSTCR   = new vpcl::re_register(0x0690, this, "THSMPSTCR"  , name.c_str());
    THSTPCR     = new vpcl::re_register(0x0694, this, "THSTPCR"    , name.c_str());
    THCR        = new vpcl::re_register(0x0698, this, "THCR"       , name.c_str());
    THAHLDSTCR  = new vpcl::re_register(0x06A0, this, "THAHLDSTCR" , name.c_str());
    THBHLDSTCR  = new vpcl::re_register(0x06A4, this, "THBHLDSTCR" , name.c_str());
    THGSR       = new vpcl::re_register(0x06B0, this, "THGSR"      , name.c_str());
    THER        = new vpcl::re_register(0x06B4, this, "THER"       , name.c_str());
    THACR       = new vpcl::re_register(0x06C0, this, "THACR"      , name.c_str());
    THBCR       = new vpcl::re_register(0x06C4, this, "THBCR"      , name.c_str());
    EMUCR       = new vpcl::re_register(0x0750, this, "EMUCR"      , name.c_str());
    ADTSTRP1    = new vpcl::re_register(0x0754, this, "ADTSTRP1"   , name.c_str());
    TDCR        = new vpcl::re_register(0x0760, this, "TDCR"       , name.c_str());
    ODCR        = new vpcl::re_register(0x0764, this, "ODCR"       , name.c_str());
    IEDCR       = new vpcl::re_register(0x0768, this, "IEDCR"      , name.c_str());
    SFTCR       = new vpcl::re_register(0x0770, this, "SFTCR"      , name.c_str());
    TOCCR       = new vpcl::re_register(0x0774, this, "TOCCR"      , name.c_str());
    TOCER       = new vpcl::re_register(0x0790, this, "TOCER"      , name.c_str());
    SYNCER      = new vpcl::re_register(0x0794, this, "SYNCER"     , name.c_str());
    ULER        = new vpcl::re_register(0x0798, this, "ULER"       , name.c_str());
    OWER        = new vpcl::re_register(0x079C, this, "OWER"       , name.c_str());
    PER         = new vpcl::re_register(0x07A0, this, "PER"        , name.c_str());
    IDER        = new vpcl::re_register(0x07A4, this, "IDER"       , name.c_str());
    ECR         = new vpcl::re_register(0x07A8, this, "ECR"        , name.c_str());
    VCLMINTER1  = new vpcl::re_register(0x0840, this, "VCLMINTER1" , name.c_str());
    VCLMINTER2  = new vpcl::re_register(0x0844, this, "VCLMINTER2" , name.c_str());
    VCLMINTER3  = new vpcl::re_register(0x0848, this, "VCLMINTER3" , name.c_str());
    PWVCLMINTER = new vpcl::re_register(0x084C, this, "PWVCLMINTER", name.c_str());
    SDVCLMINTER = new vpcl::re_register(0x0850, this, "SDVCLMINTER", name.c_str());
    VCLMSR1     = new vpcl::re_register(0x0860, this, "VCLMSR1"    , name.c_str());
    VCLMSR2     = new vpcl::re_register(0x0864, this, "VCLMSR2"    , name.c_str());
    VCLMSR3     = new vpcl::re_register(0x0868, this, "VCLMSR3"    , name.c_str());
    PWVCLMSR    = new vpcl::re_register(0x086C, this, "PWVCLMSR"   , name.c_str());
    SDVCLMSR    = new vpcl::re_register(0x0870, this, "SDVCLMSR"   , name.c_str());
    SGDIAGULCR  = new vpcl::re_register(0x0894, this, "SGDIAGULCR" , name.c_str());
    VCLMSCR1    = new vpcl::re_register(0x08A0, this, "VCLMSCR1"   , name.c_str());
    VCLMSCR2    = new vpcl::re_register(0x08A4, this, "VCLMSCR2"   , name.c_str());
    VCLMSCR3    = new vpcl::re_register(0x08A8, this, "VCLMSCR3"   , name.c_str());
    PWVCLMSCR   = new vpcl::re_register(0x08AC, this, "PWVCLMSCR"  , name.c_str());
    SDVCLMSCR   = new vpcl::re_register(0x08B0, this, "SDVCLMSCR"  , name.c_str());
    SGULCCR     = new vpcl::re_register(0x08B4, this, "SGULCCR"    , name.c_str());
    VCLMASCR    = new vpcl::re_register(0x08B8, this, "VCLMASCR"   , name.c_str());
    TRMCR       = new vpcl::re_register(0x08C0, this, "TRMCR"      , name.c_str());
    ADTSTRA     = new vpcl::re_register(0x08C4, this, "ADTSTRA"    , name.c_str());
    ADTSTRB     = new vpcl::re_register(0x08C8, this, "ADTSTRB"    , name.c_str());
    ADTSTRC     = new vpcl::re_register(0x08CC, this, "ADTSTRC"    , name.c_str());
    ADTSTRD     = new vpcl::re_register(0x08D0, this, "ADTSTRD"    , name.c_str());
    std::ostringstream str_tmp;
    for(uint i = 0; i < emNUM_VCR; i++) {
        str_tmp.str("");
        str_tmp<<"VCR"<< i;
        VCR        [i] = new vpcl::re_register((0x0000) + 4*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_SGDIAGVCR; i++) {
        str_tmp.str("");
        str_tmp<<"SGDIAGVCR"<< i;
        SGDIAGVCR  [i] = new vpcl::re_register((0x0184) + 4*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_DR; i++) {
        str_tmp.str("");
        str_tmp<<"DR"<< i;
        DR         [i] = new vpcl::re_register((0x01A0) + 4*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_DIR; i++) {
        str_tmp.str("");
        str_tmp<<"DIR"<< i;
        DIR        [i] = new vpcl::re_register((0x0280) + 4*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_SGDIAGDIR; i++) {
        str_tmp.str("");
        str_tmp<<"SGDIAGDIR"<< i;
        SGDIAGDIR  [i] = new vpcl::re_register((0x0404) + 4*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_SGSTCR; i++) {
        str_tmp.str("");
        str_tmp<<"SGSTCR"<< i;
        SGSTCR     [i] = new vpcl::re_register((0x0440) + 64*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_SGSTPCR; i++) {
        str_tmp.str("");
        str_tmp<<"SGSTPCR"<< i;
        SGSTPCR    [i] = new vpcl::re_register((0x0444) + 64*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_SGCR; i++) {
        str_tmp.str("");
        str_tmp<<"SGCR"<< i;
        SGCR       [i] = new vpcl::re_register((0x0450) + 64*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_SGVCPR; i++) {
        str_tmp.str("");
        str_tmp<<"SGVCPR"<< i;
        SGVCPR     [i] = new vpcl::re_register((0x0454) + 64*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_SGMCYCR; i++) {
        str_tmp.str("");
        str_tmp<<"SGMCYCR"<< i;
        SGMCYCR    [i] = new vpcl::re_register((0x0458) + 64*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_SGSR; i++) {
        str_tmp.str("");
        str_tmp<<"SGSR"<< i;
        SGSR       [i] = new vpcl::re_register((0x0460) + 64*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_ULLMSR; i++) {
        str_tmp.str("");
        str_tmp<<"ULLMSR"<< i;
        ULLMSR     [i] = new vpcl::re_register((0x0470) + 64*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_SGVCSP; i++) {
        str_tmp.str("");
        str_tmp<<"SGVCSP"<< i;
        SGVCSP     [i] = new vpcl::re_register((0x0474) + 64*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_SGVCEP; i++) {
        str_tmp.str("");
        str_tmp<<"SGVCEP"<< i;
        SGVCEP     [i] = new vpcl::re_register((0x0478) + 64*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_ADTSTCR; i++) {
        str_tmp.str("");
        str_tmp<<"ADTSTCR"<< mFactorIndexADTSTCR[i];
        ADTSTCR    [mFactorIndexADTSTCR[i]] = new vpcl::re_register((0x0508) + 64*(mFactorIndexADTSTCR[i]-3), this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_ADTENDCR; i++) {
        str_tmp.str("");
        str_tmp<<"ADTENDCR"<< mFactorIndexADTENDCR[i];
        ADTENDCR   [mFactorIndexADTENDCR[i]] = new vpcl::re_register((0x050C) + 64*(mFactorIndexADTENDCR[i]-3), this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_ADTIPR; i++) {
        str_tmp.str("");
        str_tmp<<"ADTIPR"<< mFactorIndexADTIPR[i];
        ADTIPR     [mFactorIndexADTIPR[i]] = new vpcl::re_register((0x0524) + 64*(mFactorIndexADTIPR[i]-3), this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_ADTPRR; i++) {
        str_tmp.str("");
        str_tmp<<"ADTPRR"<< mFactorIndexADTPRR[i];
        ADTPRR     [mFactorIndexADTPRR[i]] = new vpcl::re_register((0x0528) + 64*(mFactorIndexADTPRR[i]-3), this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_ADENDP; i++) {
        str_tmp.str("");
        str_tmp<<"ADENDP"<< i;
        ADENDP     [i] = new vpcl::re_register((0x0674) + 4*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_WAITTR; i++) {
        str_tmp.str("");
        str_tmp<<"WAITTR"<< i;
        WAITTR     [i] = new vpcl::re_register((0x0700) + 4*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_ULLMTBR; i++) {
        str_tmp.str("");
        str_tmp<<"ULLMTBR"<< i;
        ULLMTBR    [i] = new vpcl::re_register((0x0780) + 4*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_STPDCR; i++) {
        str_tmp.str("");
        str_tmp<<"STPDCR"<< i;
        STPDCR     [i] = new vpcl::re_register((0x07B0) + 4*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_VCULLMTBR; i++) {
        str_tmp.str("");
        str_tmp<<"VCULLMTBR"<< i;
        VCULLMTBR  [i] = new vpcl::re_register((0x0800) + 4*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_SGULCR; i++) {
        str_tmp.str("");
        str_tmp<<"SGULCR"<< i;
        SGULCR     [i] = new vpcl::re_register((0x0880) + 4*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_SGTSEL; i++) {
        str_tmp.str("");
        str_tmp<<"SGTSEL"<< i;
        SGTSEL     [i] = new vpcl::re_register((0x1000) + 4*i, this, str_tmp.str(), name.c_str());
    }

    // Construct the register pointer list
    mCurReg = NULL;

    uint index = 0;
    mRegMap = new uint [1<<13];
    for (uint i = 0; i < (1<<13); i++) {
        mRegMap[i] = (1<<13);
    }

    for(uint i = 0; i < emNUM_VCR;        i++) {
        mRegMap[(0x0000)     + i*4 ] = index;
        mRegMap[(0x0000 + 1) + i*4 ] = index;
        mRegMap[(0x0000 + 2) + i*4 ] = index;
        mRegMap[(0x0000 + 3) + i*4 ] = index++;
    }
    mRegMap[0x0180]     = index;
    mRegMap[0x0180 + 1] = index;
    mRegMap[0x0180 + 2] = index;
    mRegMap[0x0180 + 3] = index++;
    for(uint i = 0; i < emNUM_SGDIAGVCR;  i++) {
        mRegMap[(0x0184)     + i*4 ] = index++;
    }
    for(uint i = 0; i < emNUM_DR;         i++) {
        mRegMap[(0x01A0)     + i*4 ] = index;
        mRegMap[(0x01A0 + 1) + i*4 ] = index;
        mRegMap[(0x01A0 + 2) + i*4 ] = index;
        mRegMap[(0x01A0 + 3) + i*4 ] = index++;
    }
    mRegMap[0x0260]     = index;
    mRegMap[0x0260 + 1] = index++;
    mRegMap[0x0264]     = index;
    mRegMap[0x0264 + 1] = index;
    mRegMap[0x0264 + 2] = index;
    mRegMap[0x0264 + 3] = index++;
    mRegMap[0x0268]     = index;
    mRegMap[0x0268 + 1] = index++;
    mRegMap[0x026C]     = index;
    mRegMap[0x026C + 1] = index;
    mRegMap[0x026C + 2] = index;
    mRegMap[0x026C + 3] = index++;
    for(uint i = 0; i < emNUM_DIR;        i++) {
        mRegMap[(0x0280)     + i*4 ] = index;
        mRegMap[(0x0280 + 1) + i*4 ] = index;
        mRegMap[(0x0280 + 2) + i*4 ] = index;
        mRegMap[(0x0280 + 3) + i*4 ] = index++;
    }
    mRegMap[0x0400]     = index;
    mRegMap[0x0400 + 1] = index;
    mRegMap[0x0400 + 2] = index;
    mRegMap[0x0400 + 3] = index++;
    for(uint i = 0; i < emNUM_SGDIAGDIR;  i++) {
        mRegMap[(0x0404)     + i*4 ] = index;
        mRegMap[(0x0404 + 1) + i*4 ] = index;
        mRegMap[(0x0404 + 2) + i*4 ] = index;
        mRegMap[(0x0404 + 3) + i*4 ] = index++;
    }
    for(uint i = 0; i < emNUM_SGSTCR;     i++) {
        mRegMap[(0x0440)     + i*64] = index++;
    }
    for(uint i = 0; i < emNUM_SGSTPCR;    i++) {
        mRegMap[(0x0444)     + i*64] = index++;
    }
    for(uint i = 0; i < emNUM_SGCR;       i++) {
        mRegMap[(0x0450)     + i*64] = index++;
    }
    for(uint i = 0; i < emNUM_SGVCPR;     i++) {
        mRegMap[(0x0454)     + i*64] = index;
        mRegMap[(0x0454 + 1) + i*64] = index++;
    }
    for(uint i = 0; i < emNUM_SGMCYCR;    i++) {
        mRegMap[(0x0458)     + i*64] = index++;
    }
    for(uint i = 0; i < emNUM_SGSR;       i++) {
        mRegMap[(0x0460)     + i*64] = index++;
    }
    for(uint i = 0; i < emNUM_ULLMSR;     i++) {
        mRegMap[(0x0470)     + i*64] = index++;
    }
    for(uint i = 0; i < emNUM_SGVCSP;     i++) {
        mRegMap[(0x0474)     + i*64] = index++;
    }
    for(uint i = 0; i < emNUM_SGVCEP;     i++) {
        mRegMap[(0x0478)     + i*64] = index++;
    }
    for(uint i = 0; i < emNUM_ADTSTCR;    i++) {
        mRegMap[(0x0508)     + (mFactorIndexADTSTCR[i]-3)*64] = index++;
    }
    for(uint i = 0; i < emNUM_ADTENDCR;   i++) {
        mRegMap[(0x050C)     + (mFactorIndexADTENDCR[i]-3)*64] = index++;
    }
    for(uint i = 0; i < emNUM_ADTIPR;     i++) {
        mRegMap[(0x0524)     + (mFactorIndexADTIPR[i]-3)*64] = index;
        mRegMap[(0x0524 + 1) + (mFactorIndexADTIPR[i]-3)*64] = index;
        mRegMap[(0x0524 + 2) + (mFactorIndexADTIPR[i]-3)*64] = index;
        mRegMap[(0x0524 + 3) + (mFactorIndexADTIPR[i]-3)*64] = index++;
    }
    for(uint i = 0; i < emNUM_ADTPRR;     i++) {
        mRegMap[(0x0528)     + (mFactorIndexADTPRR[i]-3)*64] = index;
        mRegMap[(0x0528 + 1) + (mFactorIndexADTPRR[i]-3)*64] = index;
        mRegMap[(0x0528 + 2) + (mFactorIndexADTPRR[i]-3)*64] = index;
        mRegMap[(0x0528 + 3) + (mFactorIndexADTPRR[i]-3)*64] = index++;
    }
    mRegMap[0x0580]     = index++;
    mRegMap[0x0584]     = index++;
    mRegMap[0x0588]     = index++;
    mRegMap[0x058C]     = index++;
    mRegMap[0x05C0]     = index++;
    mRegMap[0x05C4]     = index++;
    mRegMap[0x05D0]     = index;
    mRegMap[0x05D0 + 1] = index;
    mRegMap[0x05D0 + 2] = index;
    mRegMap[0x05D0 + 3] = index++;
    mRegMap[0x05E0]     = index;
    mRegMap[0x05E0 + 1] = index;
    mRegMap[0x05E0 + 2] = index;
    mRegMap[0x05E0 + 3] = index++;
    mRegMap[0x05E4]     = index;
    mRegMap[0x05E4 + 1] = index;
    mRegMap[0x05E4 + 2] = index;
    mRegMap[0x05E4 + 3] = index++;
    mRegMap[0x05F0]     = index;
    mRegMap[0x05F0 + 1] = index++;
    mRegMap[0x0600]     = index;
    mRegMap[0x0600 + 1] = index++;
    mRegMap[0x0640]     = index++;
    mRegMap[0x0644]     = index++;
    mRegMap[0x0648]     = index++;
    mRegMap[0x064C]     = index;
    mRegMap[0x064C + 1] = index;
    mRegMap[0x064C + 2] = index;
    mRegMap[0x064C + 3] = index++;
    mRegMap[0x0650]     = index++;
    mRegMap[0x0654]     = index++;
    mRegMap[0x0658]     = index;
    mRegMap[0x0658 + 1] = index;
    mRegMap[0x0658 + 2] = index;
    mRegMap[0x0658 + 3] = index++;
    mRegMap[0x065C]     = index++;
    mRegMap[0x0660]     = index++;
    mRegMap[0x0664]     = index++;
    mRegMap[0x0670]     = index;
    mRegMap[0x0670 + 1] = index++;
    for(uint i = 0; i < emNUM_ADENDP;     i++) {
        mRegMap[(0x0674)     + i*4 ] = index++;
    }
    mRegMap[0x0690]     = index++;
    mRegMap[0x0694]     = index++;
    mRegMap[0x0698]     = index++;
    mRegMap[0x06A0]     = index++;
    mRegMap[0x06A4]     = index++;
    mRegMap[0x06B0]     = index;
    mRegMap[0x06B0 + 1] = index++;
    mRegMap[0x06B4]     = index++;
    mRegMap[0x06C0]     = index++;
    mRegMap[0x06C4]     = index++;
    for(uint i = 0; i < emNUM_WAITTR;     i++) {
        mRegMap[(0x0700)     + i*4 ] = index;
        mRegMap[(0x0700 + 1) + i*4 ] = index++;
    }
    mRegMap[0x0750]     = index++;
    mRegMap[0x0754]     = index++;
    mRegMap[0x0760]     = index++;
    mRegMap[0x0764]     = index;
    mRegMap[0x0764 + 1] = index++;
    mRegMap[0x0768]     = index++;
    mRegMap[0x0770]     = index++;
    mRegMap[0x0774]     = index++;
    for(uint i = 0; i < emNUM_ULLMTBR;    i++) {
        mRegMap[(0x0780)     + i*4 ] = index;
        mRegMap[(0x0780 + 1) + i*4 ] = index;
        mRegMap[(0x0780 + 2) + i*4 ] = index;
        mRegMap[(0x0780 + 3) + i*4 ] = index++;
    }
    mRegMap[0x0790]     = index++;
    mRegMap[0x0794]     = index++;
    mRegMap[0x0798]     = index++;
    mRegMap[0x079C]     = index++;
    mRegMap[0x07A0]     = index++;
    mRegMap[0x07A4]     = index++;
    mRegMap[0x07A8]     = index;
    mRegMap[0x07A8 + 1] = index++;
    for(uint i = 0; i < emNUM_STPDCR;     i++) {
        mRegMap[(0x07B0)     + i*4 ] = index++;
    }
    for(uint i = 0; i < emNUM_VCULLMTBR;  i++) {
        mRegMap[(0x0800)     + i*4 ] = index;
        mRegMap[(0x0800 + 1) + i*4 ] = index;
        mRegMap[(0x0800 + 2) + i*4 ] = index;
        mRegMap[(0x0800 + 3) + i*4 ] = index++;
    }
    mRegMap[0x0840]     = index;
    mRegMap[0x0840 + 1] = index;
    mRegMap[0x0840 + 2] = index;
    mRegMap[0x0840 + 3] = index++;
    mRegMap[0x0844]     = index;
    mRegMap[0x0844 + 1] = index;
    mRegMap[0x0844 + 2] = index;
    mRegMap[0x0844 + 3] = index++;
    mRegMap[0x0848]     = index;
    mRegMap[0x0848 + 1] = index;
    mRegMap[0x0848 + 2] = index;
    mRegMap[0x0848 + 3] = index++;
    mRegMap[0x084C]     = index++;
    mRegMap[0x0850]     = index++;
    mRegMap[0x0860]     = index;
    mRegMap[0x0860 + 1] = index;
    mRegMap[0x0860 + 2] = index;
    mRegMap[0x0860 + 3] = index++;
    mRegMap[0x0864]     = index;
    mRegMap[0x0864 + 1] = index;
    mRegMap[0x0864 + 2] = index;
    mRegMap[0x0864 + 3] = index++;
    mRegMap[0x0868]     = index;
    mRegMap[0x0868 + 1] = index;
    mRegMap[0x0868 + 2] = index;
    mRegMap[0x0868 + 3] = index++;
    mRegMap[0x086C]     = index;
    mRegMap[0x086C + 1] = index;
    mRegMap[0x086C + 2] = index;
    mRegMap[0x086C + 3] = index++;
    mRegMap[0x0870]     = index;
    mRegMap[0x0870 + 1] = index;
    mRegMap[0x0870 + 2] = index;
    mRegMap[0x0870 + 3] = index++;
    for(uint i = 0; i < emNUM_SGULCR;     i++) {
        mRegMap[(0x0880)     + i*4 ] = index;
        mRegMap[(0x0880 + 1) + i*4 ] = index++;
    }
    mRegMap[0x0894]     = index;
    mRegMap[0x0894 + 1] = index++;
    mRegMap[0x08A0]     = index;
    mRegMap[0x08A0 + 1] = index;
    mRegMap[0x08A0 + 2] = index;
    mRegMap[0x08A0 + 3] = index++;
    mRegMap[0x08A4]     = index;
    mRegMap[0x08A4 + 1] = index;
    mRegMap[0x08A4 + 2] = index;
    mRegMap[0x08A4 + 3] = index++;
    mRegMap[0x08A8]     = index;
    mRegMap[0x08A8 + 1] = index;
    mRegMap[0x08A8 + 2] = index;
    mRegMap[0x08A8 + 3] = index++;
    mRegMap[0x08AC]     = index++;
    mRegMap[0x08B0]     = index++;
    mRegMap[0x08B4]     = index++;
    mRegMap[0x08B8]     = index++;
    mRegMap[0x08C0]     = index;
    mRegMap[0x08C0 + 1] = index++;
    mRegMap[0x08C4]     = index;
    mRegMap[0x08C4 + 1] = index;
    mRegMap[0x08C4 + 2] = index;
    mRegMap[0x08C4 + 3] = index++;
    mRegMap[0x08C8]     = index;
    mRegMap[0x08C8 + 1] = index++;
    mRegMap[0x08CC]     = index;
    mRegMap[0x08CC + 1] = index++;
    mRegMap[0x08D0]     = index++;
    for(uint i = 0; i < emNUM_SGTSEL;     i++) {
        mRegMap[(0x1000)     + i*4 ] = index;
        mRegMap[(0x1000 + 1) + i*4 ] = index;
        mRegMap[(0x1000 + 2) + i*4 ] = index;
        mRegMap[(0x1000 + 3) + i*4 ] = index++;
    }
    mTotalRegNum = index;
    mRegArray = new SRegList* [mTotalRegNum];
    index = 0;
#ifdef USR_CWR_SYSTEMC
    for(uint i = 0; i < emNUM_VCR        ; i++) mCurReg = mRegArray[index++] = new SRegList(VCR          [i], mCurReg, i,  4, "8|16|32", "8|16|32", false, &cwmem);
#else
    for(uint i = 0; i < emNUM_VCR        ; i++) mCurReg = mRegArray[index++] = new SRegList(VCR          [i], mCurReg, i,  4, "8|16|32", "8|16|32");
#endif
    mCurReg = mRegArray[index++] = new SRegList(PWDVCR       , mCurReg, 0,  4, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_SGDIAGVCR  ; i++) mCurReg = mRegArray[index++] = new SRegList(SGDIAGVCR    [i], mCurReg, i,  1, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_DR         ; i++) mCurReg = mRegArray[index++] = new SRegList(DR           [i], mCurReg, i,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(PWDDR        , mCurReg, 0,  2, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(SGDIAGDR01   , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(SGDIAGDR2    , mCurReg, 0,  2, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(SGDIAGSRR    , mCurReg, 0,  4, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_DIR        ; i++) mCurReg = mRegArray[index++] = new SRegList(DIR          [i], mCurReg, i,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(PWDDIR       , mCurReg, 0,  4, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_SGDIAGDIR  ; i++) mCurReg = mRegArray[index++] = new SRegList(SGDIAGDIR    [i], mCurReg, i,  4, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_SGSTCR     ; i++) mCurReg = mRegArray[index++] = new SRegList(SGSTCR       [i], mCurReg, i,  1, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_SGSTPCR    ; i++) mCurReg = mRegArray[index++] = new SRegList(SGSTPCR      [i], mCurReg, i,  1, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_SGCR       ; i++) mCurReg = mRegArray[index++] = new SRegList(SGCR         [i], mCurReg, i,  1, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_SGVCPR     ; i++) mCurReg = mRegArray[index++] = new SRegList(SGVCPR       [i], mCurReg, i,  2,   "16|32", "8|16|32");
    for(uint i = 0; i < emNUM_SGMCYCR    ; i++) mCurReg = mRegArray[index++] = new SRegList(SGMCYCR      [i], mCurReg, i,  1, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_SGSR       ; i++) mCurReg = mRegArray[index++] = new SRegList(SGSR         [i], mCurReg, i,  1, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_ULLMSR     ; i++) mCurReg = mRegArray[index++] = new SRegList(ULLMSR       [i], mCurReg, i,  1, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_SGVCSP     ; i++) mCurReg = mRegArray[index++] = new SRegList(SGVCSP       [i], mCurReg, i,  1, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_SGVCEP     ; i++) mCurReg = mRegArray[index++] = new SRegList(SGVCEP       [i], mCurReg, i,  1, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_ADTSTCR    ; i++) mCurReg = mRegArray[index++] = new SRegList(ADTSTCR      [mFactorIndexADTSTCR    [i]], mCurReg, mFactorIndexADTSTCR    [i],  1, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_ADTENDCR   ; i++) mCurReg = mRegArray[index++] = new SRegList(ADTENDCR     [mFactorIndexADTENDCR   [i]], mCurReg, mFactorIndexADTENDCR   [i],  1, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_ADTIPR     ; i++) mCurReg = mRegArray[index++] = new SRegList(ADTIPR       [mFactorIndexADTIPR     [i]], mCurReg, mFactorIndexADTIPR     [i],  4, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_ADTPRR     ; i++) mCurReg = mRegArray[index++] = new SRegList(ADTPRR       [mFactorIndexADTPRR     [i]], mCurReg, mFactorIndexADTPRR     [i],  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(PWDCR        , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(PWDSGCR      , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(PWDSGSTCR    , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(PWDSGSR      , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(SGDIAGSTCR   , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(SGDIAGSTPCR  , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(SGDIAGCR     , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(SGDIAGPCCR0  , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(SGDIAGPCCR1  , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(SGDIAGSR     , mCurReg, 0,  2, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(SGSTR        , mCurReg, 0,  2, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(ADHALTR      , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(ADCR1        , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(ADCR2        , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(SMPCR        , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(MPXCURCR     , mCurReg, 0,  1,    "8|16",    "8|16");
    mCurReg = mRegArray[index++] = new SRegList(MPXINTER     , mCurReg, 0,  1,    "8|16",    "8|16");
    mCurReg = mRegArray[index++] = new SRegList(MPXCURR1     , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(MPXCURR2     , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(MPXCMDR      , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(MPXOWR       , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(DFASENTSGER  , mCurReg, 0,  2, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_ADENDP     ; i++) mCurReg = mRegArray[index++] = new SRegList(ADENDP       [i], mCurReg, i,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(THSMPSTCR    , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(THSTPCR      , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(THCR         , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(THAHLDSTCR   , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(THBHLDSTCR   , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(THGSR        , mCurReg, 0,  2, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(THER         , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(THACR        , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(THBCR        , mCurReg, 0,  1, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_WAITTR     ; i++) mCurReg = mRegArray[index++] = new SRegList(WAITTR       [i], mCurReg, i,  2,    "8|16",    "8|16");
    mCurReg = mRegArray[index++] = new SRegList(EMUCR        , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(ADTSTRP1     , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TDCR         , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(ODCR         , mCurReg, 0,  2, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(IEDCR        , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(SFTCR        , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TOCCR        , mCurReg, 0,  1, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_ULLMTBR    ; i++) mCurReg = mRegArray[index++] = new SRegList(ULLMTBR      [i], mCurReg, i,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TOCER        , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(SYNCER       , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(ULER         , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(OWER         , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(PER          , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(IDER         , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(ECR          , mCurReg, 0,  2, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_STPDCR     ; i++) mCurReg = mRegArray[index++] = new SRegList(STPDCR       [i], mCurReg, i,  1, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_VCULLMTBR  ; i++) mCurReg = mRegArray[index++] = new SRegList(VCULLMTBR    [i], mCurReg, i,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(VCLMINTER1   , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(VCLMINTER2   , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(VCLMINTER3   , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(PWVCLMINTER  , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(SDVCLMINTER  , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(VCLMSR1      , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(VCLMSR2      , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(VCLMSR3      , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(PWVCLMSR     , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(SDVCLMSR     , mCurReg, 0,  4, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_SGULCR     ; i++) mCurReg = mRegArray[index++] = new SRegList(SGULCR       [i], mCurReg, i,  2, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(SGDIAGULCR   , mCurReg, 0,  2, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(VCLMSCR1     , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(VCLMSCR2     , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(VCLMSCR3     , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(PWVCLMSCR    , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(SDVCLMSCR    , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(SGULCCR      , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(VCLMASCR     , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TRMCR        , mCurReg, 0,  2, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(ADTSTRA      , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(ADTSTRB      , mCurReg, 0,  2, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(ADTSTRC      , mCurReg, 0,  2, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(ADTSTRD      , mCurReg, 0,  1, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_SGTSEL     ; i++) mCurReg = mRegArray[index++] = new SRegList(SGTSEL       [i], mCurReg, i,  4, "8|16|32", "8|16|32");

    mRegList = mCurReg;

    (*PWDVCR       ) (19, 16, "WTTS"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*PWDVCR       ) (15, 15, "MPXE"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*PWDVCR       ) (14, 12, "MPXV"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*PWDVCR       ) (11,  8, "VCULLMTBS", 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*PWDVCR       ) ( 5,  0, "GCTRL"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*PWDDR        ) (15,  0, "PWDDR"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*SGDIAGDR01   ) (31, 16, "SGDIAGDR1", 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*SGDIAGDR01   ) (15,  0, "SGDIAGDR0", 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*SGDIAGDR2    ) (15,  0, "SGDIAGDR2", 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*SGDIAGSRR    ) (31, 16, "SRR1"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*SGDIAGSRR    ) (15,  0, "SRR0"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*PWDDIR       ) (31, 31, "MPXE"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*PWDDIR       ) (30, 28, "MPXV"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*PWDDIR       ) (26, 26, "IDEF"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*PWDDIR       ) (25, 25, "WFLAG"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*PWDDIR       ) (24, 24, "PRTY"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*PWDDIR       ) (21, 16, "ID"      , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*PWDDIR       ) (15,  0, "PWDDR"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*PWDCR        ) ( 0,  0, "PWE"     , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PWDSGCR      ) ( 0,  0, "TRGMD"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PWDSGSTCR    ) ( 0,  0, "SGST"    , 0x0       , "R:0|W" , vpcl::SPP_DISABLE);
    (*PWDSGSR      ) ( 0,  0, "PWSGC"   , 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*SGDIAGSTCR   ) ( 0,  0, "SGST"    , 0x0       , "R:0|W" , vpcl::SPP_ENABLE);
    (*SGDIAGSTPCR  ) ( 0,  0, "SGSTP"   , 0x0       , "R:0|W" , vpcl::SPP_ENABLE);
    (*SGDIAGCR     ) (23, 20, "VCULLMTBS1", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGCR     ) (19, 16, "VCULLMTBS0", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGCR     ) (12, 12, "SMD"     , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGCR     ) (10, 10, "ISM"     , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGCR     ) ( 9,  9, "SDPS"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGCR     ) ( 8,  8, "ADIE"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGCR     ) ( 0,  0, "TRGMD"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR0  ) (31, 31, "SDPCE31" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR0  ) (30, 30, "SDPCE30" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR0  ) (29, 29, "SDPCE29" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR0  ) (28, 28, "SDPCE28" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR0  ) (27, 27, "SDPCE27" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR0  ) (26, 26, "SDPCE26" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR0  ) (25, 25, "SDPCE25" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR0  ) (24, 24, "SDPCE24" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR0  ) (23, 23, "SDPCE23" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR0  ) (22, 22, "SDPCE22" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR0  ) (21, 21, "SDPCE21" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR0  ) (20, 20, "SDPCE20" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR0  ) (19, 19, "SDPCE19" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR0  ) (18, 18, "SDPCE18" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR0  ) (17, 17, "SDPCE17" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR0  ) (16, 16, "SDPCE16" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR0  ) (15, 15, "SDPCE15" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR0  ) (14, 14, "SDPCE14" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR0  ) (13, 13, "SDPCE13" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR0  ) (12, 12, "SDPCE12" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR0  ) (11, 11, "SDPCE11" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR0  ) (10, 10, "SDPCE10" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR0  ) ( 9,  9, "SDPCE9"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR0  ) ( 8,  8, "SDPCE8"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR0  ) ( 7,  7, "SDPCE7"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR0  ) ( 6,  6, "SDPCE6"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR0  ) ( 5,  5, "SDPCE5"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR0  ) ( 4,  4, "SDPCE4"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR0  ) ( 3,  3, "SDPCE3"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR0  ) ( 2,  2, "SDPCE2"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR0  ) ( 1,  1, "SDPCE1"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR0  ) ( 0,  0, "SDPCE0"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR1  ) (31, 31, "SDPCE63" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR1  ) (30, 30, "SDPCE62" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR1  ) (29, 29, "SDPCE61" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR1  ) (28, 28, "SDPCE60" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR1  ) (27, 27, "SDPCE59" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR1  ) (26, 26, "SDPCE58" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR1  ) (25, 25, "SDPCE57" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR1  ) (24, 24, "SDPCE56" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR1  ) (23, 23, "SDPCE55" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR1  ) (22, 22, "SDPCE54" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR1  ) (21, 21, "SDPCE53" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR1  ) (20, 20, "SDPCE52" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR1  ) (19, 19, "SDPCE51" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR1  ) (18, 18, "SDPCE50" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR1  ) (17, 17, "SDPCE49" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR1  ) (16, 16, "SDPCE48" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR1  ) (15, 15, "SDPCE47" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR1  ) (14, 14, "SDPCE46" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR1  ) (13, 13, "SDPCE45" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR1  ) (12, 12, "SDPCE44" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR1  ) (11, 11, "SDPCE43" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR1  ) (10, 10, "SDPCE42" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR1  ) ( 9,  9, "SDPCE41" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR1  ) ( 8,  8, "SDPCE40" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR1  ) ( 7,  7, "SDPCE39" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR1  ) ( 6,  6, "SDPCE38" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR1  ) ( 5,  5, "SDPCE37" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR1  ) ( 4,  4, "SDPCE36" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR1  ) ( 3,  3, "SDPCE35" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR1  ) ( 2,  2, "SDPCE34" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR1  ) ( 1,  1, "SDPCE33" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGPCCR1  ) ( 0,  0, "SDPCE32" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SGDIAGSR     ) ( 1,  1, "SDACT"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*SGSTR        ) (13, 12, "ADTACT"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*SGSTR        ) ( 7,  7, "SHACT"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*SGSTR        ) ( 6,  6, "SVSACT"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*SGSTR        ) ( 5,  1, "SGACT"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*SGSTR        ) ( 0,  0, "SDACT"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*ADHALTR      ) ( 0,  0, "HALT"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*ADCR1        ) ( 1,  0, "SUSMTD"  , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*ADCR2        ) ( 6,  4, "DFMT"    , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*ADCR2        ) ( 0,  0, "ADDNT"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*SMPCR        ) (23, 16, "EXSMPT"  , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*SMPCR        ) (15, 15, "BUFAMPD" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*SMPCR        ) (12, 12, "SMPTS"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*SMPCR        ) ( 7,  0, "SMPT"    , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*MPXCURCR     ) ( 3,  0, "MSKCFMT" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*MPXINTER     ) ( 0,  0, "ADMPXIE" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*MPXCURR1     ) (31, 16, "MSKC"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*MPXCURR1     ) (15,  8, "MPXCMD"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*MPXCURR1     ) ( 4,  0, "MPXCUR"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*MPXCURR2     ) ( 2,  0, "MPXCUR"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*MPXCMDR      ) ( 7,  0, "MPXCMD"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*MPXOWR       ) ( 3,  0, "MPXOW"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE, "0x0-0xA");
    (*DFASENTSGER  ) (12, 12, "DFENTSG4E", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*DFASENTSGER  ) (11, 11, "DFENTSG3E", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*DFASENTSGER  ) (10, 10, "DFENTSG2E", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*DFASENTSGER  ) ( 9,  9, "DFENTSG1E", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*DFASENTSGER  ) ( 8,  8, "DFENTSG0E", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*DFASENTSGER  ) ( 4,  4, "ASENTSG4E", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*DFASENTSGER  ) ( 3,  3, "ASENTSG3E", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*DFASENTSGER  ) ( 2,  2, "ASENTSG2E", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*DFASENTSGER  ) ( 1,  1, "ASENTSG1E", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*DFASENTSGER  ) ( 0,  0, "ASENTSG0E", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THSMPSTCR    ) ( 0,  0, "SMPST"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THSTPCR      ) ( 0,  0, "THSTP"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THCR         ) ( 0,  0, "ASMPMSK" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THAHLDSTCR   ) ( 0,  0, "HLDST"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THBHLDSTCR   ) ( 0,  0, "HLDST"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THGSR        ) (10, 10, "TH5GS"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THGSR        ) ( 8,  8, "TH4GS"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THGSR        ) ( 6,  6, "TH3GS"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THGSR        ) ( 4,  4, "TH2GS"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THGSR        ) ( 2,  2, "TH1GS"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THGSR        ) ( 0,  0, "TH0GS"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THER         ) ( 5,  5, "TH5E"    , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THER         ) ( 4,  4, "TH4E"    , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THER         ) ( 3,  3, "TH3E"    , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THER         ) ( 2,  2, "TH2E"    , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THER         ) ( 1,  1, "TH1E"    , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THER         ) ( 0,  0, "TH0E"    , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THACR        ) ( 5,  5, "HLDCTE"  , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THACR        ) ( 4,  4, "HLDTE"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THACR        ) ( 1,  0, "SGS"     , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THBCR        ) ( 5,  5, "HLDCTE"  , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THBCR        ) ( 4,  4, "HLDTE"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THBCR        ) ( 1,  0, "SGS"     , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*EMUCR        ) ( 0,  0, "SVSDIS"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*ADTSTRP1     ) ( 0,  0, "VMONFD"  , 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*TDCR         ) ( 7,  7, "THSDE"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*TDCR         ) ( 1,  0, "TDLV"    , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*ODCR         ) ( 8,  8, "WADDE"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*ODCR         ) ( 4,  0, "ODPW"    , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*IEDCR        ) ( 0,  0, "IDSCE"   , 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*SFTCR        ) ( 6,  6, "TOCEIE"  , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*SFTCR        ) ( 5,  5, "SYNCEIE" , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*SFTCR        ) ( 4,  4, "RDCLRE"  , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*SFTCR        ) ( 3,  3, "ULEIE"   , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*SFTCR        ) ( 2,  2, "OWEIE"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*SFTCR        ) ( 1,  1, "PEIE"    , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*SFTCR        ) ( 0,  0, "IDEIE"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*TOCCR        ) ( 0,  0, "TOCE"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TOCER        ) ( 5,  1, "TOCESG"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TOCER        ) ( 0,  0, "TOCESD"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*SYNCER       ) ( 7,  7, "SYNCE"   , 0x0       , "R"     , vpcl::SPP_DISABLE);
    (*ULER         ) ( 7,  7, "ULE"     , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*ULER         ) ( 6,  0, "ULECAP"  , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*OWER         ) ( 7,  7, "OWE"     , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*OWER         ) ( 6,  0, "OWECAP"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*PER          ) ( 7,  7, "PE"      , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*PER          ) ( 6,  0, "PECAP"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*IDER         ) ( 7,  7, "IDE"     , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*IDER         ) ( 6,  0, "IDECAP"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*ECR          ) (13,  9, "TOCESGC" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*ECR          ) ( 8,  8, "TOCESDC" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*ECR          ) ( 5,  5, "SYNCEC"  , 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*ECR          ) ( 3,  3, "ULEC"    , 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*ECR          ) ( 2,  2, "OWEC"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*ECR          ) ( 1,  1, "PEC"     , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*ECR          ) ( 0,  0, "IDEC"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (31, 31, "ADUL31IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (30, 30, "ADUL30IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (29, 29, "ADUL29IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (28, 28, "ADUL28IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (27, 27, "ADUL27IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (26, 26, "ADUL26IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (25, 25, "ADUL25IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (24, 24, "ADUL24IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (23, 23, "ADUL23IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (22, 22, "ADUL22IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (21, 21, "ADUL21IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (20, 20, "ADUL20IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (19, 19, "ADUL19IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (18, 18, "ADUL18IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (17, 17, "ADUL17IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (16, 16, "ADUL16IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (15, 15, "ADUL15IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (14, 14, "ADUL14IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (13, 13, "ADUL13IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (12, 12, "ADUL12IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (11, 11, "ADUL11IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (10, 10, "ADUL10IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) ( 9,  9, "ADUL09IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) ( 8,  8, "ADUL08IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) ( 7,  7, "ADUL07IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) ( 6,  6, "ADUL06IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) ( 5,  5, "ADUL05IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) ( 4,  4, "ADUL04IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) ( 3,  3, "ADUL03IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) ( 2,  2, "ADUL02IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) ( 1,  1, "ADUL01IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) ( 0,  0, "ADUL00IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) (31, 31, "ADUL63IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) (30, 30, "ADUL62IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) (29, 29, "ADUL61IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) (28, 28, "ADUL60IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) (27, 27, "ADUL59IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) (26, 26, "ADUL58IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) (25, 25, "ADUL57IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) (24, 24, "ADUL56IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) (23, 23, "ADUL55IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) (22, 22, "ADUL54IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) (21, 21, "ADUL53IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) (20, 20, "ADUL52IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) (19, 19, "ADUL51IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) (18, 18, "ADUL50IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) (17, 17, "ADUL49IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) (16, 16, "ADUL48IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) (15, 15, "ADUL47IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) (14, 14, "ADUL46IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) (13, 13, "ADUL45IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) (12, 12, "ADUL44IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) (11, 11, "ADUL43IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) (10, 10, "ADUL42IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) ( 9,  9, "ADUL41IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) ( 8,  8, "ADUL40IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) ( 7,  7, "ADUL39IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) ( 6,  6, "ADUL38IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) ( 5,  5, "ADUL37IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) ( 4,  4, "ADUL36IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) ( 3,  3, "ADUL35IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) ( 2,  2, "ADUL34IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) ( 1,  1, "ADUL33IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) ( 0,  0, "ADUL32IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER3   ) (31, 31, "ADUL95IE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*VCLMINTER3   ) (30, 30, "ADUL94IE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*VCLMINTER3   ) (29, 29, "ADUL93IE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*VCLMINTER3   ) (28, 28, "ADUL92IE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*VCLMINTER3   ) (27, 27, "ADUL91IE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*VCLMINTER3   ) (26, 26, "ADUL90IE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*VCLMINTER3   ) (25, 25, "ADUL89IE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*VCLMINTER3   ) (24, 24, "ADUL88IE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*VCLMINTER3   ) (23, 23, "ADUL87IE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*VCLMINTER3   ) (22, 22, "ADUL86IE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*VCLMINTER3   ) (21, 21, "ADUL85IE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*VCLMINTER3   ) (20, 20, "ADUL84IE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*VCLMINTER3   ) (19, 19, "ADUL83IE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*VCLMINTER3   ) (18, 18, "ADUL82IE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*VCLMINTER3   ) (17, 17, "ADUL81IE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*VCLMINTER3   ) (16, 16, "ADUL80IE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*VCLMINTER3   ) (15, 15, "ADUL79IE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*VCLMINTER3   ) (14, 14, "ADUL78IE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*VCLMINTER3   ) (13, 13, "ADUL77IE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*VCLMINTER3   ) (12, 12, "ADUL76IE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*VCLMINTER3   ) (11, 11, "ADUL75IE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*VCLMINTER3   ) (10, 10, "ADUL74IE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*VCLMINTER3   ) ( 9,  9, "ADUL73IE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*VCLMINTER3   ) ( 8,  8, "ADUL72IE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*VCLMINTER3   ) ( 7,  7, "ADUL71IE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*VCLMINTER3   ) ( 6,  6, "ADUL70IE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*VCLMINTER3   ) ( 5,  5, "ADUL69IE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*VCLMINTER3   ) ( 4,  4, "ADUL68IE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*VCLMINTER3   ) ( 3,  3, "ADUL67IE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*VCLMINTER3   ) ( 2,  2, "ADUL66IE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*VCLMINTER3   ) ( 1,  1, "ADUL65IE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*VCLMINTER3   ) ( 0,  0, "ADUL64IE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*PWVCLMINTER  ) ( 0,  0, "PWADULIE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*SDVCLMINTER  ) ( 0,  0, "SDADULIE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (31, 31, "VC31LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (30, 30, "VC30LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (29, 29, "VC29LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (28, 28, "VC28LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (27, 27, "VC27LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (26, 26, "VC26LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (25, 25, "VC25LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (24, 24, "VC24LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (23, 23, "VC23LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (22, 22, "VC22LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (21, 21, "VC21LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (20, 20, "VC20LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (19, 19, "VC19LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (18, 18, "VC18LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (17, 17, "VC17LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (16, 16, "VC16LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (15, 15, "VC15LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (14, 14, "VC14LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (13, 13, "VC13LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (12, 12, "VC12LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (11, 11, "VC11LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (10, 10, "VC10LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) ( 9,  9, "VC09LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) ( 8,  8, "VC08LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) ( 7,  7, "VC07LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) ( 6,  6, "VC06LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) ( 5,  5, "VC05LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) ( 4,  4, "VC04LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) ( 3,  3, "VC03LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) ( 2,  2, "VC02LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) ( 1,  1, "VC01LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) ( 0,  0, "VC00LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) (31, 31, "VC63LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) (30, 30, "VC62LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) (29, 29, "VC61LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) (28, 28, "VC60LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) (27, 27, "VC59LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) (26, 26, "VC58LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) (25, 25, "VC57LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) (24, 24, "VC56LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) (23, 23, "VC55LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) (22, 22, "VC54LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) (21, 21, "VC53LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) (20, 20, "VC52LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) (19, 19, "VC51LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) (18, 18, "VC50LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) (17, 17, "VC49LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) (16, 16, "VC48LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) (15, 15, "VC47LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) (14, 14, "VC46LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) (13, 13, "VC45LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) (12, 12, "VC44LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) (11, 11, "VC43LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) (10, 10, "VC42LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) ( 9,  9, "VC41LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) ( 8,  8, "VC40LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) ( 7,  7, "VC39LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) ( 6,  6, "VC38LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) ( 5,  5, "VC37LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) ( 4,  4, "VC36LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) ( 3,  3, "VC35LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) ( 2,  2, "VC34LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) ( 1,  1, "VC33LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) ( 0,  0, "VC32LMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSR3      ) (31, 31, "VC95LMS" , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSR3      ) (30, 30, "VC94LMS" , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSR3      ) (29, 29, "VC93LMS" , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSR3      ) (28, 28, "VC92LMS" , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSR3      ) (27, 27, "VC91LMS" , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSR3      ) (26, 26, "VC90LMS" , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSR3      ) (25, 25, "VC89LMS" , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSR3      ) (24, 24, "VC88LMS" , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSR3      ) (23, 23, "VC87LMS" , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSR3      ) (22, 22, "VC86LMS" , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSR3      ) (21, 21, "VC85LMS" , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSR3      ) (20, 20, "VC84LMS" , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSR3      ) (19, 19, "VC83LMS" , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSR3      ) (18, 18, "VC82LMS" , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSR3      ) (17, 17, "VC81LMS" , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSR3      ) (16, 16, "VC80LMS" , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSR3      ) (15, 15, "VC79LMS" , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSR3      ) (14, 14, "VC78LMS" , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSR3      ) (13, 13, "VC77LMS" , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSR3      ) (12, 12, "VC76LMS" , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSR3      ) (11, 11, "VC75LMS" , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSR3      ) (10, 10, "VC74LMS" , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSR3      ) ( 9,  9, "VC73LMS" , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSR3      ) ( 8,  8, "VC72LMS" , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSR3      ) ( 7,  7, "VC71LMS" , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSR3      ) ( 6,  6, "VC70LMS" , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSR3      ) ( 5,  5, "VC69LMS" , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSR3      ) ( 4,  4, "VC68LMS" , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSR3      ) ( 3,  3, "VC67LMS" , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSR3      ) ( 2,  2, "VC66LMS" , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSR3      ) ( 1,  1, "VC65LMS" , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSR3      ) ( 0,  0, "VC64LMS" , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*PWVCLMSR     ) ( 0,  0, "PWVCLMS" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*SDVCLMSR     ) ( 2,  2, "SR1LMS"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*SDVCLMSR     ) ( 1,  1, "SR0LMS"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*SDVCLMSR     ) ( 0,  0, "SDVC0LMS", 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*SGDIAGULCR   ) (15, 15, "UE"      , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*SGDIAGULCR   ) (14, 14, "LE"      , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*SGDIAGULCR   ) ( 7,  7, "ULE"     , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*SGDIAGULCR   ) ( 5,  0, "ULPC"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (31, 31, "VC31LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (30, 30, "VC30LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (29, 29, "VC29LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (28, 28, "VC28LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (27, 27, "VC27LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (26, 26, "VC26LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (25, 25, "VC25LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (24, 24, "VC24LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (23, 23, "VC23LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (22, 22, "VC22LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (21, 21, "VC21LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (20, 20, "VC20LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (19, 19, "VC19LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (18, 18, "VC18LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (17, 17, "VC17LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (16, 16, "VC16LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (15, 15, "VC15LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (14, 14, "VC14LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (13, 13, "VC13LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (12, 12, "VC12LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (11, 11, "VC11LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (10, 10, "VC10LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) ( 9,  9, "VC09LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) ( 8,  8, "VC08LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) ( 7,  7, "VC07LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) ( 6,  6, "VC06LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) ( 5,  5, "VC05LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) ( 4,  4, "VC04LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) ( 3,  3, "VC03LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) ( 2,  2, "VC02LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) ( 1,  1, "VC01LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) ( 0,  0, "VC00LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) (31, 31, "VC63LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) (30, 30, "VC62LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) (29, 29, "VC61LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) (28, 28, "VC60LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) (27, 27, "VC59LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) (26, 26, "VC58LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) (25, 25, "VC57LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) (24, 24, "VC56LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) (23, 23, "VC55LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) (22, 22, "VC54LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) (21, 21, "VC53LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) (20, 20, "VC52LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) (19, 19, "VC51LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) (18, 18, "VC50LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) (17, 17, "VC49LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) (16, 16, "VC48LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) (15, 15, "VC47LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) (14, 14, "VC46LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) (13, 13, "VC45LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) (12, 12, "VC44LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) (11, 11, "VC43LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) (10, 10, "VC42LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) ( 9,  9, "VC41LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) ( 8,  8, "VC40LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) ( 7,  7, "VC39LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) ( 6,  6, "VC38LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) ( 5,  5, "VC37LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) ( 4,  4, "VC36LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) ( 3,  3, "VC35LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) ( 2,  2, "VC34LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) ( 1,  1, "VC33LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) ( 0,  0, "VC32LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR3     ) (31, 31, "VC95LMSC", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSCR3     ) (30, 30, "VC94LMSC", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSCR3     ) (29, 29, "VC93LMSC", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSCR3     ) (28, 28, "VC92LMSC", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSCR3     ) (27, 27, "VC91LMSC", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSCR3     ) (26, 26, "VC90LMSC", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSCR3     ) (25, 25, "VC89LMSC", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSCR3     ) (24, 24, "VC88LMSC", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSCR3     ) (23, 23, "VC87LMSC", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSCR3     ) (22, 22, "VC86LMSC", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSCR3     ) (21, 21, "VC85LMSC", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSCR3     ) (20, 20, "VC84LMSC", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSCR3     ) (19, 19, "VC83LMSC", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSCR3     ) (18, 18, "VC82LMSC", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSCR3     ) (17, 17, "VC81LMSC", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSCR3     ) (16, 16, "VC80LMSC", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSCR3     ) (15, 15, "VC79LMSC", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSCR3     ) (14, 14, "VC78LMSC", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSCR3     ) (13, 13, "VC77LMSC", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSCR3     ) (12, 12, "VC76LMSC", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSCR3     ) (11, 11, "VC75LMSC", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSCR3     ) (10, 10, "VC74LMSC", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSCR3     ) ( 9,  9, "VC73LMSC", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSCR3     ) ( 8,  8, "VC72LMSC", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSCR3     ) ( 7,  7, "VC71LMSC", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSCR3     ) ( 6,  6, "VC70LMSC", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSCR3     ) ( 5,  5, "VC69LMSC", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSCR3     ) ( 4,  4, "VC68LMSC", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSCR3     ) ( 3,  3, "VC67LMSC", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSCR3     ) ( 2,  2, "VC66LMSC", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSCR3     ) ( 1,  1, "VC65LMSC", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*VCLMSCR3     ) ( 0,  0, "VC64LMSC", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*PWVCLMSCR    ) ( 0,  0, "PWVCLMSC", 0x0       , "R:0|W" , vpcl::SPP_ENABLE);
    (*SDVCLMSCR    ) ( 2,  2, "SR1LMSC" , 0x0       , "R:0|W" , vpcl::SPP_ENABLE);
    (*SDVCLMSCR    ) ( 1,  1, "SR0LMSC" , 0x0       , "R:0|W" , vpcl::SPP_ENABLE);
    (*SDVCLMSCR    ) ( 0,  0, "SDVC0LMSC", 0x0       , "R:0|W" , vpcl::SPP_ENABLE);
    (*SGULCCR      ) ( 5,  1, "SGULCC"  , 0x0       , "R:0|W" , vpcl::SPP_ENABLE);
    (*SGULCCR      ) ( 0,  0, "SDULCC"  , 0x0       , "R:0|W" , vpcl::SPP_ENABLE);
    (*VCLMASCR     ) ( 0,  0, "ALLMSC"  , 0x0       , "R:0|W" , vpcl::SPP_ENABLE);
    (*TRMCR        ) (15, 15, "TRMS"    , 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*TRMCR        ) (13, 12, "TRMTTUNE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*TRMCR        ) (11, 10, "TRMBTUNE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*TRMCR        ) ( 9,  8, "TRMATUNE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*TRMCR        ) ( 5,  4, "TRMT"    , 0x0       , "R"     , vpcl::SPP_DISABLE);
    (*TRMCR        ) ( 3,  2, "TRMB"    , 0x0       , "R"     , vpcl::SPP_DISABLE);
    (*TRMCR        ) ( 1,  0, "TRMA"    , 0x0       , "R"     , vpcl::SPP_DISABLE);
    (*ADTSTRA      ) (21, 16, "SELAN"   , 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*ADTSTRA      ) ( 8,  0, "ADTST"   , 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*ADTSTRB      ) (13,  0, "ADVAL"   , 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*ADTSTRC      ) (13, 13, "CKSTP"   , 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*ADTSTRC      ) ( 8,  0, "ADMD"    , 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*ADTSTRD      ) ( 7,  7, "ADDISE"  , 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*ADTSTRD      ) ( 4,  0, "ADDIS"   , 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    for(uint i = 0; i < emNUM_SGVCSP; i++) {
        (*SGVCSP       [i]) ( 6,  0, "VCSP"    , 0x0       , "D"     , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_SGDIAGVCR; i++) {
        (*SGDIAGVCR    [i]) ( 3,  0, "CNVCLS"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_ADTSTCR; i++) {
        (*ADTSTCR      [mFactorIndexADTSTCR[i]]) ( 0,  0, "ADTST"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_ULLMTBR; i++) {
        (*ULLMTBR      [i]) (31, 16, "ULMTB"   , 0x7FFE    , "D"     , vpcl::SPP_DISABLE);
        (*ULLMTBR      [i]) (15,  0, "LLMTB"   , 0x0       , "D"     , vpcl::SPP_DISABLE);
    }
    for(uint i = 0; i < emNUM_ULLMSR; i++) {
        (*ULLMSR       [i]) ( 1,  0, "ULS"     , 0x0       , "D"     , vpcl::SPP_DISABLE);
    }
    for(uint i = 0; i < emNUM_DR; i++) {
        (*DR           [i]) (31, 16, "DR1"     , 0x0       , "R"     , vpcl::SPP_ENABLE);
        (*DR           [i]) (15,  0, "DR0"     , 0x0       , "R"     , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_DIR; i++) {
        (*DIR          [i]) (31, 31, "MPXE"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
        (*DIR          [i]) (30, 28, "MPXV"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
        (*DIR          [i]) (26, 26, "IDEF"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
        (*DIR          [i]) (25, 25, "WFLAG"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
        (*DIR          [i]) (24, 24, "PRTY"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
        (*DIR          [i]) (21, 16, "ID"      , 0x0       , "R"     , vpcl::SPP_ENABLE);
        (*DIR          [i]) (15,  0, "DRn"     , 0x0       , "R"     , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_WAITTR; i++) {
        (*WAITTR       [i]) (13,  0, "WAITTIME", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_SGVCEP; i++) {
        (*SGVCEP       [i]) ( 6,  0, "VCEP"    , 0x0       , "D"     , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_ADENDP; i++) {
        (*ADENDP       [i]) ( 6,  0, "ENDP"    , 0x0       , "D"     , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_SGCR; i++) {
        (*SGCR         [i]) ( 7,  7, "ADTSTARTE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*SGCR         [i]) ( 6,  6, "ADSTARTE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*SGCR         [i]) ( 5,  5, "SCANMD"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*SGCR         [i]) ( 4,  4, "ADIE"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*SGCR         [i]) ( 1,  0, "TRGMD"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_SGSTCR; i++) {
        (*SGSTCR       [i]) ( 0,  0, "SGST"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_ADTENDCR; i++) {
        (*ADTENDCR     [mFactorIndexADTENDCR[i]]) ( 0,  0, "ADTEND"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_SGDIAGDIR; i++) {
        (*SGDIAGDIR    [i]) (26, 26, "IDEF"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
        (*SGDIAGDIR    [i]) (25, 25, "WFLAG"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
        (*SGDIAGDIR    [i]) (24, 24, "PRTY"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
        (*SGDIAGDIR    [i]) (21, 16, "ID"      , 0x0       , "R"     , vpcl::SPP_ENABLE);
        (*SGDIAGDIR    [i]) (15,  0, "SGDIAGDRk", 0x0       , "R"     , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_VCR; i++) {
        (*VCR          [i]) (31, 28, "VCULLMTBS", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*VCR          [i]) (27, 24, "WTTS"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*VCR          [i]) (20, 20, "DFENT"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*VCR          [i]) (19, 16, "DFTAG"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*VCR          [i]) (14, 11, "CNVCLS"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*VCR          [i]) (10,  8, "MPXV"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*VCR          [i]) ( 7,  7, "ADIE"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*VCR          [i]) ( 5,  0, "GCTRL"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_SGMCYCR; i++) {
        (*SGMCYCR      [i]) ( 7,  0, "MCYC"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_STPDCR; i++) {
        (*STPDCR       [i]) ( 0,  0, "SPDE"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_ADTPRR; i++) {
        (*ADTPRR       [mFactorIndexADTPRR[i]]) (20,  0, "ADTPR"   , 0x1FFFFF  , "W|R"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_SGVCPR; i++) {
        (*SGVCPR       [i]) (14,  8, "VCEP"    , 0x0       , "D"     , vpcl::SPP_ENABLE);
        (*SGVCPR       [i]) ( 6,  0, "VCSP"    , 0x0       , "D"     , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_SGTSEL; i++) {
        (*SGTSEL       [i]) ( 5,  5, "TxSEL5"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*SGTSEL       [i]) ( 4,  4, "TxSEL4"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*SGTSEL       [i]) ( 3,  3, "TxSEL3"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*SGTSEL       [i]) ( 2,  2, "TxSEL2"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*SGTSEL       [i]) ( 1,  1, "TxSEL1"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*SGTSEL       [i]) ( 0,  0, "TxSEL0"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_SGSTPCR; i++) {
        (*SGSTPCR      [i]) ( 0,  0, "SGSTP"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_SGSR; i++) {
        (*SGSR         [i]) ( 2,  2, "ADTACT"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
        (*SGSR         [i]) ( 1,  1, "SGACT"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_VCULLMTBR; i++) {
        (*VCULLMTBR    [i]) (31, 16, "VCULMTB" , 0x7FFE    , "D"     , vpcl::SPP_ENABLE);
        (*VCULLMTBR    [i]) (15,  0, "VCLLMTB" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_SGULCR; i++) {
        (*SGULCR       [i]) (15, 15, "UE"      , 0x0       , "R"     , vpcl::SPP_ENABLE);
        (*SGULCR       [i]) (14, 14, "LE"      , 0x0       , "R"     , vpcl::SPP_ENABLE);
        (*SGULCR       [i]) (11, 11, "MPXE"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
        (*SGULCR       [i]) (10,  8, "MPXV"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
        (*SGULCR       [i]) ( 7,  7, "ULE"     , 0x0       , "R"     , vpcl::SPP_ENABLE);
        (*SGULCR       [i]) ( 5,  0, "ULPC"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_ADTIPR; i++) {
        (*ADTIPR       [mFactorIndexADTIPR[i]]) (20,  0, "ADTIP"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    }

    mFileName = "";
    mInstName = name;
    mLineNum = 0;
    mBusWidth = buswidth;
    mBusByteWidth = mBusWidth/8;   // using in BIG ENDIAN
    mIsReset = false;

    // Constructor the callback function of each register
    for (uint i = 0; i < mTotalRegNum; i++) {
        mWrCbAPI[mRegArray[i]->my_p->name()][mRegArray[i]->my_p->name()] = NULL;
        mRdCbAPI[mRegArray[i]->my_p->name()][mRegArray[i]->my_p->name()] = NULL;
    }

    // Constructor the mWrCbAPI, mRdCbAPI variable of each register
    mWrCbAPI["PWDCR"    ]["PWE"      ] = &Cadc_u2b_regif::cb_PWDCR_PWE;
    mWrCbAPI["PWDSGCR"  ]["TRGMD"    ] = &Cadc_u2b_regif::cb_PWDSGCR_TRGMD;
    mWrCbAPI["SGDIAGSTCR"]["SGST"     ] = &Cadc_u2b_regif::cb_SGDIAGSTCR_SGST;
    mWrCbAPI["SGDIAGSTPCR"]["SGSTP"    ] = &Cadc_u2b_regif::cb_SGDIAGSTPCR_SGSTP;
    mWrCbAPI["SGDIAGCR" ]["TRGMD"    ] = &Cadc_u2b_regif::cb_SGDIAGCR_TRGMD;
    mWrCbAPI["SGDIAGPCCR0"]["SDPCE0"   ] = &Cadc_u2b_regif::cb_SGDIAGPCCR0_SDPCE0;
    mWrCbAPI["SGDIAGPCCR1"]["SDPCE32"  ] = &Cadc_u2b_regif::cb_SGDIAGPCCR1_SDPCE32;
    mWrCbAPI["ADHALTR"  ]["HALT"     ] = &Cadc_u2b_regif::cb_ADHALTR_HALT;
    mWrCbAPI["ADCR1"    ]["SUSMTD"   ] = &Cadc_u2b_regif::cb_ADCR1_SUSMTD;
    mWrCbAPI["ADCR2"    ]["DFMT"     ] = &Cadc_u2b_regif::cb_ADCR2_DFMT;
    mWrCbAPI["SMPCR"    ]["SMPT"     ] = &Cadc_u2b_regif::cb_SMPCR_SMPT;
    mWrCbAPI["MPXCURCR" ]["MSKCFMT"  ] = &Cadc_u2b_regif::cb_MPXCURCR_MSKCFMT;
    mWrCbAPI["MPXINTER" ]["ADMPXIE"  ] = &Cadc_u2b_regif::cb_MPXINTER_ADMPXIE;
    mWrCbAPI["MPXCMDR"  ]["MPXCMD"   ] = &Cadc_u2b_regif::cb_MPXCMDR_MPXCMD;
    mWrCbAPI["MPXOWR"   ]["MPXOW"    ] = &Cadc_u2b_regif::cb_MPXOWR_MPXOW;
    mWrCbAPI["DFASENTSGER"]["ASENTSG0E"] = &Cadc_u2b_regif::cb_DFASENTSGER_ASENTSG0E;
    mWrCbAPI["THSMPSTCR"]["SMPST"    ] = &Cadc_u2b_regif::cb_THSMPSTCR_SMPST;
    mWrCbAPI["THSTPCR"  ]["THSTP"    ] = &Cadc_u2b_regif::cb_THSTPCR_THSTP;
    mWrCbAPI["THCR"     ]["ASMPMSK"  ] = &Cadc_u2b_regif::cb_THCR_ASMPMSK;
    mWrCbAPI["THAHLDSTCR"]["HLDST"    ] = &Cadc_u2b_regif::cb_THAHLDSTCR_HLDST;
    mWrCbAPI["THBHLDSTCR"]["HLDST"    ] = &Cadc_u2b_regif::cb_THBHLDSTCR_HLDST;
    mWrCbAPI["THGSR"    ]["TH0GS"    ] = &Cadc_u2b_regif::cb_THGSR_TH0GS;
    mWrCbAPI["THER"     ]["TH0E"     ] = &Cadc_u2b_regif::cb_THER_TH0E;
    mWrCbAPI["THACR"    ]["SGS"      ] = &Cadc_u2b_regif::cb_THACR_SGS;
    mWrCbAPI["THBCR"    ]["SGS"      ] = &Cadc_u2b_regif::cb_THBCR_SGS;
    mWrCbAPI["EMUCR"    ]["SVSDIS"   ] = &Cadc_u2b_regif::cb_EMUCR_SVSDIS;
    mWrCbAPI["TDCR"     ]["TDLV"     ] = &Cadc_u2b_regif::cb_TDCR_TDLV;
    mWrCbAPI["ODCR"     ]["WADDE"    ] = &Cadc_u2b_regif::cb_ODCR_WADDE;
    mWrCbAPI["SFTCR"    ]["IDEIE"    ] = &Cadc_u2b_regif::cb_SFTCR_IDEIE;
    mWrCbAPI["TOCCR"    ]["TOCE"     ] = &Cadc_u2b_regif::cb_TOCCR_TOCE;
    mWrCbAPI["ECR"      ]["IDEC"     ] = &Cadc_u2b_regif::cb_ECR_IDEC;
    mWrCbAPI["VCLMINTER1"]["ADUL00IE" ] = &Cadc_u2b_regif::cb_VCLMINTER1_ADUL00IE;
    mWrCbAPI["VCLMINTER2"]["ADUL32IE" ] = &Cadc_u2b_regif::cb_VCLMINTER2_ADUL32IE;
    mWrCbAPI["PWVCLMINTER"]["PWADULIE" ] = &Cadc_u2b_regif::cb_PWVCLMINTER_PWADULIE;
    mWrCbAPI["SDVCLMINTER"]["SDADULIE" ] = &Cadc_u2b_regif::cb_SDVCLMINTER_SDADULIE;
    mWrCbAPI["VCLMSCR1" ]["VC00LMSC" ] = &Cadc_u2b_regif::cb_VCLMSCR1_VC00LMSC;
    mWrCbAPI["VCLMSCR2" ]["VC32LMSC" ] = &Cadc_u2b_regif::cb_VCLMSCR2_VC32LMSC;
    mWrCbAPI["PWVCLMSCR"]["PWVCLMSC" ] = &Cadc_u2b_regif::cb_PWVCLMSCR_PWVCLMSC;
    mWrCbAPI["SDVCLMSCR"]["SDVC0LMSC"] = &Cadc_u2b_regif::cb_SDVCLMSCR_SDVC0LMSC;
    mWrCbAPI["SGULCCR"  ]["SGULCC"   ] = &Cadc_u2b_regif::cb_SGULCCR_SGULCC;
    mWrCbAPI["VCLMASCR" ]["ALLMSC"   ] = &Cadc_u2b_regif::cb_VCLMASCR_ALLMSC;

    mRdCbAPI["TOCER"    ]["TOCESD"   ] = &Cadc_u2b_regif::cb_TOCER_TOCESD;

    for(uint i = 0; i < emNUM_VCR; i++) {
        str_tmp.str("");
        str_tmp<<"VCR"<< i;
        mWrCbAPI[str_tmp.str()]["GCTRL"] = &Cadc_u2b_regif::cb_VCR_GCTRL;
    }
    for(uint i = 0; i < emNUM_SGDIAGVCR; i++) {
        str_tmp.str("");
        str_tmp<<"SGDIAGVCR"<< i;
        mWrCbAPI[str_tmp.str()]["CNVCLS"] = &Cadc_u2b_regif::cb_SGDIAGVCR_CNVCLS;
    }
    for(uint i = 0; i < emNUM_SGSTCR; i++) {
        str_tmp.str("");
        str_tmp<<"SGSTCR"<< i;
        mWrCbAPI[str_tmp.str()]["SGST"] = &Cadc_u2b_regif::cb_SGSTCR_SGST;
    }
    for(uint i = 0; i < emNUM_SGSTPCR; i++) {
        str_tmp.str("");
        str_tmp<<"SGSTPCR"<< i;
        mWrCbAPI[str_tmp.str()]["SGSTP"] = &Cadc_u2b_regif::cb_SGSTPCR_SGSTP;
    }
    for(uint i = 0; i < emNUM_SGCR; i++) {
        str_tmp.str("");
        str_tmp<<"SGCR"<< i;
        mWrCbAPI[str_tmp.str()]["ADIE"] = &Cadc_u2b_regif::cb_SGCR_ADIE;
    }
    for(uint i = 0; i < emNUM_SGVCPR; i++) {
        str_tmp.str("");
        str_tmp<<"SGVCPR"<< i;
        mWrCbAPI[str_tmp.str()]["VCSP"] = &Cadc_u2b_regif::cb_SGVCPR_VCSP;
    }
    for(uint i = 0; i < emNUM_SGMCYCR; i++) {
        str_tmp.str("");
        str_tmp<<"SGMCYCR"<< i;
        mWrCbAPI[str_tmp.str()]["MCYC"] = &Cadc_u2b_regif::cb_SGMCYCR_MCYC;
    }
    for(uint i = 0; i < emNUM_SGVCSP; i++) {
        str_tmp.str("");
        str_tmp<<"SGVCSP"<< i;
        mWrCbAPI[str_tmp.str()]["VCSP"] = &Cadc_u2b_regif::cb_SGVCSP_VCSP;
    }
    for(uint i = 0; i < emNUM_SGVCEP; i++) {
        str_tmp.str("");
        str_tmp<<"SGVCEP"<< i;
        mWrCbAPI[str_tmp.str()]["VCEP"] = &Cadc_u2b_regif::cb_SGVCEP_VCEP;
    }
    for(uint i = 0; i < emNUM_ADTSTCR; i++) {
        str_tmp.str("");
        str_tmp<<"ADTSTCR"<< mFactorIndexADTSTCR[i];
        mWrCbAPI[str_tmp.str()]["ADTST"] = &Cadc_u2b_regif::cb_ADTSTCR_ADTST;
    }
    for(uint i = 0; i < emNUM_ADTENDCR; i++) {
        str_tmp.str("");
        str_tmp<<"ADTENDCR"<< mFactorIndexADTENDCR[i];
        mWrCbAPI[str_tmp.str()]["ADTEND"] = &Cadc_u2b_regif::cb_ADTENDCR_ADTEND;
    }
    for(uint i = 0; i < emNUM_ADTIPR; i++) {
        str_tmp.str("");
        str_tmp<<"ADTIPR"<< mFactorIndexADTIPR[i];
        mWrCbAPI[str_tmp.str()]["ADTIP"] = &Cadc_u2b_regif::cb_ADTIPR_ADTIP;
    }
    for(uint i = 0; i < emNUM_ADTPRR; i++) {
        str_tmp.str("");
        str_tmp<<"ADTPRR"<< mFactorIndexADTPRR[i];
        mWrCbAPI[str_tmp.str()]["ADTPR"] = &Cadc_u2b_regif::cb_ADTPRR_ADTPR;
    }
    for(uint i = 0; i < emNUM_ADENDP; i++) {
        str_tmp.str("");
        str_tmp<<"ADENDP"<< i;
        mWrCbAPI[str_tmp.str()]["ENDP"] = &Cadc_u2b_regif::cb_ADENDP_ENDP;
    }
    for(uint i = 0; i < emNUM_WAITTR; i++) {
        str_tmp.str("");
        str_tmp<<"WAITTR"<< i;
        mWrCbAPI[str_tmp.str()]["WAITTIME"] = &Cadc_u2b_regif::cb_WAITTR_WAITTIME;
    }
    for(uint i = 0; i < emNUM_STPDCR; i++) {
        str_tmp.str("");
        str_tmp<<"STPDCR"<< i;
        mWrCbAPI[str_tmp.str()]["SPDE"] = &Cadc_u2b_regif::cb_STPDCR_SPDE;
    }
    for(uint i = 0; i < emNUM_VCULLMTBR; i++) {
        str_tmp.str("");
        str_tmp<<"VCULLMTBR"<< i;
        mWrCbAPI[str_tmp.str()]["VCULMTB"] = &Cadc_u2b_regif::cb_VCULLMTBR_VCULMTB;
    }
    for(uint i = 0; i < emNUM_SGTSEL; i++) {
        str_tmp.str("");
        str_tmp<<"SGTSEL"<< i;
        mWrCbAPI[str_tmp.str()]["TxSEL0"] = &Cadc_u2b_regif::cb_SGTSEL_TxSEL0;
    }

    #ifdef USE_WEB_SIM
    InitializeRegValueID();
    mNotifyRegValueIDAPI = &Cadc_u2b_regif::NotifyRegValueID;
    #endif
}

/// Destructor: delete pointers
/// @return none
Cadc_u2b_regif::~Cadc_u2b_regif()
{
    // Delete registers' pointer
    for (uint i = 0 ; i < mTotalRegNum ; i++) {
        delete mRegArray[i]->my_p;
        mRegArray[i]->prev = NULL;
        delete mRegArray[i];
    }
    delete [] mRegMap;
    delete [] mRegArray;
}

/// Mask unselected bit
/// @return selected value
Cadc_u2b_regif::uint Cadc_u2b_regif::bit_select(cuint val,    ///< [in] Writting address
                                                cuint start,  ///< [in] start bit position
                                                cuint end)    ///< [in] end bit position
{
    uint ret_val = val;
    if (end - start + 1 < 32) {
        ret_val = (val>>start) & (uint)((1<<(end-start+1))-1);
    }
    return ret_val;
}

/// Write the value to requested module register
/// @return true if writing transaction is finished normally
bool Cadc_u2b_regif::reg_wr(cuint addr,                    ///< [in] Writting address
                            const unsigned char *p_data,   ///< [in] Writing data
                            cuint size)                    ///< [in] Data size (byte)
{
    assert(size != 0);
    #ifdef IS_MODELED_ENDIAN_BIG
    if ((addr % mBusByteWidth) + size > mBusByteWidth) {
        re_printf("error", "Invalid access address 0x%08X with access size %d bytes\n", addr, size);
        return false;
    }
    #endif

    bool ret_val = false;
    assert(p_data != NULL);
    ret_val = reg_wr_process (addr, p_data, size, false);
    return ret_val;
}

/// Read the register value of requested module
/// @return true if reading transaction is finished normally
bool Cadc_u2b_regif::reg_rd(cuint addr,              ///< [in]  Reading address
                            unsigned char *p_data,   ///< [out] Reading data
                            cuint size)              ///< [in]  Data size (byte)
{
    assert(size != 0);
    #ifdef IS_MODELED_ENDIAN_BIG
    if ((addr % mBusByteWidth) + size > mBusByteWidth) {
        re_printf("error", "Invalid access address 0x%08X with access size %d bytes\n", addr, size);
        return false;
    }
    #endif

    bool ret_val = false;
    assert(p_data != NULL);
    ret_val = reg_rd_process (addr, p_data, size, false);
    return ret_val;
}

/// Write the value to requested module register
/// @return true if writing transaction is finished normally
bool Cadc_u2b_regif::reg_wr_dbg(cuint addr,                    ///< [in] Writting address
                                const unsigned char *p_data,   ///< [in] Writing data
                                cuint size)                    ///< [in] Data size (byte)
{
    assert(size != 0);
    #ifdef IS_MODELED_ENDIAN_BIG
    if ((addr % mBusByteWidth) + size > mBusByteWidth) {
        re_printf("error", "Invalid access address 0x%08X with access size %d bytes\n", addr, size);
        return false;
    }
    #endif

    bool ret_val = false;
    assert(p_data != NULL);
    ret_val = reg_wr_process (addr, p_data, size, true);
    return ret_val;
}

/// Read the register value of requested module
/// @return true if reading transaction is finished normally
bool Cadc_u2b_regif::reg_rd_dbg(cuint addr,              ///< [in]  Reading address
                                unsigned char *p_data,   ///< [out] Reading data
                                cuint size)              ///< [in]  Data size (byte)
{
    assert(size != 0);
    #ifdef IS_MODELED_ENDIAN_BIG
    if ((addr % mBusByteWidth) + size > mBusByteWidth) {
        re_printf("error", "Invalid access address 0x%08X with access size %d bytes\n", addr, size);
        return false;
    }
    #endif

    bool ret_val = false;
    assert(p_data != NULL);
    ret_val = reg_rd_process (addr, p_data, size, true);
    return ret_val;
}

/// Write the value to requested module register
/// @return true if writing transaction is finished normally
bool Cadc_u2b_regif::reg_wr_process(cuint addr,                   ///< [in] Writting address
                                    const unsigned char *p_data,  ///< [in] Writing data
                                    cuint size,                   ///< [in] Data size (byte)
                                    bool IsDbgFunc)               ///< [in] Flag indicate reg_rd or reg_rd_dbg
{
    if (mIsReset) {
        re_printf("warning", "Cannot write during reset period\n");
        return true;
    }
    uint tmp_addr = addr;
    #ifdef IS_MODELED_ENDIAN_BIG
    if (size < mBusByteWidth) {
        tmp_addr = addr ^ (mBusByteWidth - size);
    }
    #endif
    bool ret_val = false;
    bool valid_addr = false;
    assert(p_data != NULL);
    std::list<uint> list_index;
    uint masked_addr = bit_select(tmp_addr, 0, 13-1);
    uint access_addr = masked_addr;
    while (masked_addr + size > access_addr) {
        int reg_index = get_reg_index(access_addr);
        if (reg_index != -1) {
            vpcl::re_register *reg_p = mRegArray[reg_index]->my_p; 
            if (IsDbgFunc || valid_addr || ChkSize(mRegArray[reg_index]->wacc_size, size, tmp_addr, true)) {
                valid_addr = true;
                list_index.push_back(reg_index);
            } else {
                re_printf("error", "Writing access size to %s at address 0x%08X is wrong: %d byte(s).\n", reg_p->name().c_str(), tmp_addr, size);
                return false;
            }
            access_addr = reg_p->addr() + mRegArray[reg_index]->length;
        } else {
            if (IsDbgFunc || valid_addr) {
                access_addr += 1;
            } else {
                access_addr += size; // To break out while loop
            }
        }
    }
    if (valid_addr) {
        std::list<uint>::iterator it;
        for (it=list_index.begin() ; it!=list_index.end() ; it++) {
            access_addr = masked_addr;
            uint d_size = size;
            uint index = 0;
            if (masked_addr < mRegArray[(*it)]->my_p->addr()) { // adjust access address & index
                access_addr = mRegArray[(*it)]->my_p->addr();
                index = mRegArray[(*it)]->my_p->addr() - masked_addr;
            }
            if ((masked_addr + size) < (mRegArray[(*it)]->my_p->addr() + mRegArray[(*it)]->length)) { // adjust access size
                d_size = masked_addr + size - access_addr;
            } else { // adjust access size
                d_size = (mRegArray[(*it)]->my_p->addr() + mRegArray[(*it)]->length) - access_addr;
            }
            if (size > mRegArray[(*it)]->length) { // adjust index for big endianess
                #ifdef IS_MODELED_ENDIAN_BIG
                index = index ^ (size - mRegArray[(*it)]->length);
                #endif
            }
            ret_val = reg_wr_func(tmp_addr - masked_addr + access_addr, &(p_data[index]), d_size, (*it), IsDbgFunc);
        }
    } else {
        if (!IsDbgFunc) {
            re_printf("error", "Invalid access address 0x%08X\n", tmp_addr);
        } else {
            ret_val = true;
        }
    }
    return ret_val;
}

/// Read the register value of requested module
/// @return true if reading transaction is finished normally
bool Cadc_u2b_regif::reg_rd_process(cuint addr,              ///< [in]  Reading address
                                    unsigned char *p_data,   ///< [out] Reading data
                                    cuint size,              ///< [in]  Data size (byte)
                                    bool IsDbgFunc)          ///< [in]  Flag indicate reg_rd or reg_rd_dbg
{
    uint tmp_addr = addr;
    #ifdef IS_MODELED_ENDIAN_BIG
    if (size < mBusByteWidth) {
        tmp_addr = addr ^ (mBusByteWidth - size);
    }
    #endif
    bool ret_val = false;
    bool valid_addr = false;
    assert(p_data != NULL);
    std::list<uint> list_index;
    uint masked_addr = bit_select(tmp_addr, 0, 13-1);
    uint access_addr = masked_addr;
    while (masked_addr + size > access_addr) {
        int reg_index = get_reg_index(access_addr);
        if (reg_index != -1) {
            vpcl::re_register *reg_p = mRegArray[reg_index]->my_p; 
            if (IsDbgFunc || valid_addr || ChkSize(mRegArray[reg_index]->racc_size, size, tmp_addr, false)) {
                valid_addr = true;
                list_index.push_back(reg_index);
            } else {
                re_printf("error", "Reading access size to %s at address 0x%08X is wrong: %d byte(s).\n", reg_p->name().c_str(), tmp_addr, size);
                return false;
            }
            access_addr = reg_p->addr() + mRegArray[reg_index]->length;
        } else {
            if (mAPBAccessMode || IsDbgFunc || valid_addr) {
                access_addr += 1;
            } else {
                access_addr += size;  // To break out while loop
            }
        }
    }
    if (valid_addr) {
        std::list<uint>::iterator it;
        for (it=list_index.begin() ; it!=list_index.end() ; it++) {
            access_addr = masked_addr;
            uint d_size = size;
            uint index = 0;
            if (masked_addr < mRegArray[(*it)]->my_p->addr()) { // adjust access address & index
                access_addr = mRegArray[(*it)]->my_p->addr();
                index = mRegArray[(*it)]->my_p->addr() - masked_addr;
            }
            if ((masked_addr + size) < (mRegArray[(*it)]->my_p->addr() + mRegArray[(*it)]->length)) { // adjust access size
                d_size = masked_addr + size - access_addr;
            } else { // adjust access size
                d_size = (mRegArray[(*it)]->my_p->addr() + mRegArray[(*it)]->length) - access_addr;
            }
            if (size > mRegArray[(*it)]->length) { // adjust index for big endianess
                #ifdef IS_MODELED_ENDIAN_BIG
                index = index ^ (size - mRegArray[(*it)]->length);
                #endif
            }
            ret_val = reg_rd_func(tmp_addr - masked_addr + access_addr, &(p_data[index]), d_size, (*it), IsDbgFunc);
        }
    } else {
        if (!(IsDbgFunc || mAPBAccessMode)) {
            memset(p_data, 0, size);
            re_printf("error", "Invalid access address 0x%08X\n", tmp_addr);
        } else {
            memset(p_data, 0, size);
            ret_val = true;
        }
    }
    return ret_val;
}

/// Process reading function
/// @return true if reading successfully
bool Cadc_u2b_regif::reg_rd_func(cuint addr,                     ///< [in]  Reading address
                                 unsigned char *p_data,          ///< [out] Reading data
                                 cuint size,                     ///< [in]  Data size (byte)
                                 cuint reg_index,                ///< [in]  Register index
                                 bool IsDbgFunc)                 ///< [in]  Flag indicate reg_rd or reg_rd_dbg
{
    vpcl::re_register* Register = mRegArray[reg_index]->my_p;
    assert(Register != NULL);
    uint pre_data = 0;
    uint pst_data = 0;
    uint reg_length = mRegArray[reg_index]->length;
    uint start_pos = 0;
    uint mask_size = (1 << (reg_length/2)) - 1;
    if (size < reg_length) {
        #ifdef IS_MODELED_ENDIAN_BIG
        start_pos =  (reg_length - size)*8 - (addr & mask_size)*8; // Start bit position
        #else
        start_pos =  (addr & mask_size)*8;  // Start bit position
        #endif
    }

    if (mIsReset) {
        re_printf("warning", "Cannot launch call-back function during reset period\n");
    } else {
        if (size < reg_length) {
            re_printf("warning","Should read all bit in a register\n");
        }
        pre_data = (uint)(*Register);
        pst_data = Register->read();
        if (!IsDbgFunc) {
            for (vpcl::bit_info *it=Register->mBitInfo ; it!=NULL ; it=it->next) {
                if (((mRdCbAPI[Register->name()][it->name()]) != NULL)
                && (((start_pos < it->mStartAddr) && (it->mEndAddr < start_pos + size * 8))
                 || ((it->mStartAddr <= start_pos) && (start_pos <= it->mEndAddr))
                 || ((it->mStartAddr <= start_pos + size * 8) && (start_pos + size * 8 <= it->mEndAddr)) )) {
                    (this->*(mRdCbAPI[Register->name()][it->name()]))(RegCBstr(mRegArray[reg_index]->channel, false, size, pre_data, pst_data));
                }
            }
        } else {
            for (vpcl::bit_info *it=Register->mBitInfo ; it!=NULL ; it=it->next) {
                if (((mRdDbgCbAPI[Register->name()][it->name()]) != NULL)
                && (((start_pos < it->mStartAddr) && (it->mEndAddr < start_pos + size * 8))
                 || ((it->mStartAddr <= start_pos) && (start_pos <= it->mEndAddr))
                 || ((it->mStartAddr <= start_pos + size * 8) && (start_pos + size * 8 <= it->mEndAddr)) )) {
                    (this->*(mRdDbgCbAPI[Register->name()][it->name()]))(RegCBstr(mRegArray[reg_index]->channel, false, size, pre_data, pst_data));
                }
            }
        }
    }

    pst_data = (uint)(*Register);
    if (size < reg_length) {
        uint read_data = 0;
        if (((reg_length%2 == 0) && (reg_length%size == 0) && ((addr&mask_size)%size == 0)) 
         || (!IsDbgFunc)) {
            for (uint i = start_pos; i < (8*size + start_pos); i++) {
                read_data |= (pst_data & (1 << i)) >> start_pos;
            }
            pst_data = read_data;
        }
    }

    assert(p_data != NULL);
    memcpy(p_data, &pst_data, size);
    DumpRegMsg("R", Register->name(), "", size, addr, 0, 0, pst_data, mRegArray[reg_index]->length*8);
    for (vpcl::bit_info *it=Register->mBitInfo ; it!=NULL ; it=it->next) {
        uint val = (uint)(*Register);
        val = bit_select(val, it->mStartAddr, it->mEndAddr);
        if (mDumpBitInfo) {
            DumpRegMsg("R", Register->name(), it->name(), size, addr, 0, 0, val, it->mEndAddr - it->mStartAddr + 1);
        }
    }
    return true;
}

/// Process writing function
/// @return true if writing successfully
bool Cadc_u2b_regif::reg_wr_func(cuint addr,                       ///< [in] Writting address
                                 const unsigned char *p_data,      ///< [in] Writing data
                                 cuint size,                       ///< [in] Data size (byte)
                                 cuint reg_index,                  ///< [in] Register index
                                 bool IsDbgFunc)                   ///< [in] Flag indicate reg_wr or reg_wr_dbg
{
    vpcl::re_register* Register = mRegArray[reg_index]->my_p;
    uint pre_data = 0;
    uint data = 0;
    uint reg_length = mRegArray[reg_index]->length;
    uint start_pos = 0;
    assert ((p_data != NULL) && (Register != NULL));
    memcpy(&data, p_data, size);
    uint wr_data = data;
    if (size < reg_length) {
        uint mask_size = (1 << (reg_length/2)) - 1;
        if (((reg_length%2 == 0) && (reg_length%size == 0) && ((addr&mask_size)%size == 0)) 
         || (!IsDbgFunc)) {
            uint new_data = (uint)(*Register);  // For writing to register
            uint written_data = 0;         // For transferring to callback function
            #ifdef IS_MODELED_ENDIAN_BIG
            start_pos =  (reg_length - size)*8 - (addr & mask_size)*8; // Start bit position
            #else
            start_pos =  (addr & mask_size)*8;  // Start bit position
            #endif
            for (uint i = start_pos; i < (8*size + start_pos); i++) {
                new_data = (new_data & (~(1 << i))) | ((data << start_pos) & (1 << i));
                written_data = (written_data & (~(1 << i))) | ((data << start_pos) & (1 << i));
            }
            data = new_data;
        }
    }

    if (!mRegArray[reg_index]->block || IsDbgFunc) {
        pre_data = (uint)(*Register);
        if (IsDbgFunc) {
            bool backup_warning = Register->mMessageLevel["warning"];
            bool backup_error = Register->mMessageLevel["error"];
            Register->mMessageLevel["warning"] = false;
            Register->mMessageLevel["error"]   = false;

            Register->write(data);

            Register->mMessageLevel["warning"] = backup_warning;
            Register->mMessageLevel["error"]   = backup_error;
        } else {
            Register->write(data);
        }
        
        DumpRegMsg("W", Register->name(), "", size, addr, wr_data, pre_data, (uint)(*Register), mRegArray[reg_index]->length*8);
        for (vpcl::bit_info *it=Register->mBitInfo ; it!=NULL ; it=it->next) {
            uint val = (uint)(*Register);
            val = bit_select(val, it->mStartAddr, it->mEndAddr);
            uint pre_val = pre_data;
            pre_val = bit_select(pre_val, it->mStartAddr, it->mEndAddr);
            if (mDumpBitInfo) {
                DumpRegMsg("W", Register->name(), it->name(), size, addr, (unsigned int)*it, pre_val, val, it->mEndAddr - it->mStartAddr + 1);
            }
            if ((mWrCbAPI[Register->name()][it->name()]) != NULL) {
                (this->*(mWrCbAPI[Register->name()][it->name()]))(RegCBstr(mRegArray[reg_index]->channel, true, size, pre_data, data));
            }
        }
    } else {
        re_printf("warning","%s is blocked writing from Bus I/F.\n", Register->name().c_str());
    }
    return true;
}

/// Check access size
/// @@return true if detect_size equal expect_size
bool Cadc_u2b_regif::ChkSize(std::string expect_size, cuint detect_size, cuint addr, bool is_wr)
{
    std::vector<std::string> arg_vec = Str2Vec(expect_size, '|');
    std::vector<std::string>::iterator it;
    char *err_p = NULL;
    uint size = 0;
    if (detect_size > mBusByteWidth) {
        re_printf("error", "Invalid access size: %d bytes\n", detect_size);
        return false;
    }
    if (addr%detect_size != 0) {
        re_printf("error", "Invalid access address 0x%08X with access size %d bytes\n", addr, detect_size);
        return false;
    }
    if (is_wr || !(mAPBAccessMode)) {
        for (it = arg_vec.begin(); it != arg_vec.end(); it++) {
            errno = 0; size = (uint) strtoull((*it).c_str(), &err_p, 0);
            assert(err_p != NULL);
            if (errno != ERANGE && *err_p == '\0') {
                if ((size/8) == detect_size) {
                    return true;
                }
            }
        }
    } else {
        return true;
    }
    return false;
}

/// Initialize reg_handle_command variables
/// @return none
void Cadc_u2b_regif::CommandInit()
{
    mDumpRegisterRW = false;
    mAPBAccessMode  = false;
    mDumpBitInfo    = true;
    mMessageLevel["fatal"]   = true;
    mMessageLevel["error"]   = true;
    mMessageLevel["warning"] = false;
    mMessageLevel["info"]    = false;
}

/// Process reg_handle_command command
/// @return string
std::string Cadc_u2b_regif::reg_handle_command(const std::vector<std::string>& args)
{
    std::string ret = "";
    std::string err_msg = "Error ("   + mInstName + ") ";   // error message
    if (args[0] == "reg") {
        if (args[1] == "help") {
            ret += "    --- reg ---\n";
            ret += "    reg MessageLevel <fatal|error|warning|info> Select debug message level (Default: fatal|error)\n";
            ret += "    reg DumpRegisterRW <true/false>             Select dump register access information  (Default: false)\n";
            ret += "    reg APBAccessMode <true/false>              Select for APB access mode when reading (Default: false)\n";
            ret += "    reg DumpBitInfo <true/false>                Select for dump bit information (Default: true)\n";
            ret += "    reg <register_name> MessageLevel <fatal|error|warning|info> Select debug message level for register (Default: fatal|error)\n";
            ret += "    reg <register_name> force <value>           Force register with setting value\n";
            ret += "    reg <register_name> release                 Release register from force value\n";
            ret += "    reg <register_name> <value>                 Write a value into register\n";
            ret += "    reg <register_name>                         Read value of register\n";
            ret += "    reg help                                    Show a direction\n";
        } else if (args[1] == "DumpRegisterRW") {
            if (args.size() == 2) {
                if (mDumpRegisterRW) {
                    ret = "true";
                } else {
                    ret = "false";
                }
            } else if (args.size() == 3) {
                if (args[2] == "true") {
                    mDumpRegisterRW = true;
                } else if (args[2] == "false") {
                    mDumpRegisterRW = false;
                } else {
                    ret = err_msg + "DumpRegisterRW command needs an argument [true/false]\n";
                }
            } else {
                ret = err_msg + "DumpRegisterRW has too much arguments\n";
            }
        } else if (args[1] == "APBAccessMode") {
            if (args.size() == 2) {
                if (mAPBAccessMode) {
                    ret = "true";
                } else {
                    ret = "false";
                }
            } else if (args.size() == 3) {
                if (args[2] == "true") {
                    mAPBAccessMode = true;
                } else if (args[2] == "false") {
                    mAPBAccessMode = false;
                } else {
                    ret = err_msg + "APBAccessMode command needs an argument [true/false]\n";
                }
            } else {
                ret = err_msg + "APBAccessMode has too much arguments\n";
            }
        } else if (args[1] == "DumpBitInfo") {
            if (args.size() == 2) {
                if (mDumpBitInfo) {
                    ret = "true";
                } else {
                    ret = "false";
                }
            } else if (args.size() == 3) {
                if (args[2] == "true") {
                    mDumpBitInfo = true;
                } else if (args[2] == "false") {
                    mDumpBitInfo = false;
                } else {
                    ret = err_msg + "DumpBitInfo command needs an argument [true/false]\n";
                }
            } else {
                ret = err_msg + "DumpBitInfo has too much arguments\n";
            }
        } else if (args[1] == "MessageLevel") {
            // read mode
            if (args.size() == 2) {
                std::map<std::string, bool>::iterator it;
                for (it = mMessageLevel.begin(); it != mMessageLevel.end(); it++) {
                    if ( it->second ) {
                        ret += " " + it->first;
                    }
                }
            // write mode
            } else if (args.size() == 3) {
                std::vector<std::string> arg_vec = Str2Vec(args[2], '|');
                std::map<std::string, bool>::iterator msgit;
                for (msgit =mMessageLevel.begin(); msgit != mMessageLevel.end(); msgit++) {
                    msgit->second = false;
                }
                std::vector<std::string>::iterator it;
                for (it = arg_vec.begin(); it != arg_vec.end(); it++) {
                    mMessageLevel[*it] = true;
                }
            } else {
                ret = err_msg + "MessageLevel has too much arguments\n";
            }
        } else {
            bool matched = false;
            for (uint i = 0; i < mTotalRegNum; i++) {
                if (args[1] == mRegArray[i]->my_p->name()) {
                    ret = AccessRegCommand(args, mRegArray[i]->my_p, mRegArray[i]->block);
                    matched = true;
                    break;
                }
            }
            if (!matched) {
                ret = err_msg + "Register name " + (std::string)args[1] + " is invalid\n";
            }
        }
    }
    return ret;
}

/// process reg_handle_command of "reg" parameter
/// @return string
std::string Cadc_u2b_regif::AccessRegCommand(const std::vector<std::string>& args, vpcl::re_register *Register, bool &BlockReg)
{
    std::string ret = "";
    char *err_p = NULL;
    std::string err_msg = "Error ("   + mInstName + ") ";   // error message
    uint data = 0;
    std::ostringstream str_tmp;
    assert(Register != NULL);
    if (args.size() == 2) {
        data = (uint)(*Register);
        str_tmp<<std::setw(14)<<std::left<<(Register->name());
        str_tmp<<"0x"<<std::setw(8)<<std::hex<<std::uppercase<<std::left<<data<<"\n";
        ret = str_tmp.str();
    } else if ((args.size() == 3) && (args[2] == "release")) {
        BlockReg = false;
    } else if ((args.size() == 4) && (args[2] == "force")) {
        errno = 0; data = (uint) strtoull(args[3].c_str(), &err_p, 0);
        assert(err_p != NULL);
        if (errno != ERANGE && *err_p == '\0') {
            *Register = data;
            BlockReg = true;
            
        } else {
            ret = err_msg + "[" + Register->name() + "] Invalid force value\n";
        }
    } else if ((args.size() >= 3) && (args[2] == "MessageLevel")) {
        if (args.size() == 3) {
            ret = Register->name() + " ";
            ret += Register->GetMessageLevel();
        } else if (args.size() == 4) {
            std::map<std::string, bool> MessageLevel;
            std::vector<std::string> arg_vec = Str2Vec(args[3], '|');
            std::vector<std::string>::iterator it;
            for (it = arg_vec.begin(); it != arg_vec.end(); it++) {
                MessageLevel[*it] = true;
            }
            Register->SetMessageLevel(MessageLevel);
        } else {
            ret = err_msg + "[" + Register->name() + "] MessageLevel has too much arguments\n";
        }
    } else if ((args.size() == 3) && (args[2] != "release")) {
        errno = 0; data = (uint) strtoull(args[2].c_str(), &err_p, 0);
        if (errno != ERANGE && *err_p == '\0') {
            *Register = data;
            
        } else {
            ret = err_msg + "[" + Register->name() + "] Invalid write value\n";
        }
    } else {
        ret = err_msg + "Wrong command : ";
        for (uint index = 0; index < args.size(); index ++) {
            ret += args[index] + " ";
        }
    }
    return ret;
}

#ifdef USE_WEB_SIM
/// Build register value ID library
/// @return none
void Cadc_u2b_regif::InitializeRegValueID()
{//{{{
    vpcl::bit_info* bit_ref[emBitNum] = { };

    for (unsigned int bit = 0; bit < emBitNum; bit++) {
        // Construct bit_info array
        mBitInfoPtr[bit] = bit_ref[bit];
        // Initial value of target bits
        mTargetRegVal[bit] = *(mBitInfoPtr[bit]);
    }

    // Construct mRegValueIDLib
    int bit_val[emRegIDNum][emBitNum] = { };

}//}}}

/// Calculate register value
/// @return none
void Cadc_u2b_regif::CalcTargetRegVal(void)
{//{{{
    bool is_update = false;
    unsigned int value = 0;
    for (unsigned int bit = 0; bit < emBitNum; bit++) {
        value = *(mBitInfoPtr[bit]);
        if (mTargetRegVal[bit] != value) {
            mTargetRegVal[bit] = value;
            is_update = true;
        }
    }
    if (is_update) {
        IssueRegValueID();
    }
}//}}}

/// Send register value ID to IP core
/// @return none
void Cadc_u2b_regif::IssueRegValueID(void)
{//{{{
    for (unsigned int id = 0; id < emRegIDNum; id++) {
        unsigned int bit;
        for (bit = 0; bit < emBitNum; bit++) {
            if (mRegValueIDLib[bit].BitVal[bit] > -1) { // In case that BitVal = "-" (dont care)
                if (mTargetRegVal[bit] != (unsigned int)mRegValueIDLib[id].BitVal[bit]) {
                    bit = emBitNum + 1; // Break the loop
                }
            }
        }
        // when all fields of current ID are matched, issue RegValueID
        if (bit == emBitNum) {
            (this->*(mNotifyRegValueIDAPI))(mRegValueIDLib[id].RegValueID);
            id = emRegIDNum; // Break the loop
        }
    }
}//}}}
#endif








/// convert string to vector
/// @return vector
std::vector<std::string> Cadc_u2b_regif::Str2Vec(std::string str, const char sep)
{
    std::vector<std::string> buf;
    std::string::size_type index = 0;
    for (uint i=0 ; i<str.size() ; i++) {
        if (str[i] == sep) {
            buf.push_back(str.substr(index, i-index));
            index = i+1;
        }
    }
    buf.push_back(str.substr(index));
    return buf;
}

/// Align nuber to hexadecimal format
/// @return aligned number
std::string Cadc_u2b_regif::Num2HexStr(cuint num, cuint num_length, bool space_strip, bool is_wr_data, uint acc_size)
{
    std::ostringstream str_tmp;
    #ifdef MSG_WO_WR_DATA
    str_tmp<<"0x"<<std::hex<<std::uppercase<<std::right<<num;
    str_tmp<<std::setfill(' ')<<std::setw(10-str_tmp.str().length())<<"";
    #else
    uint total_length = 0;
    acc_size = acc_size*8;
    if ((acc_size < num_length) && is_wr_data) {
        total_length = (acc_size + 3)/4; // Calculate number of hexadecimal number
    } else {
        total_length = (num_length + 3)/4; // Calculate number of hexadecimal number
    }
    str_tmp<<"0x"<<std::setfill('0')<<std::setw(total_length)<<std::hex<<std::uppercase<<std::right<<num;
    if (!space_strip) {
        str_tmp<<std::setfill(' ')<<std::setw(10-str_tmp.str().length())<<"";   
    }
    #endif
    return str_tmp.str();
}

/// Dump register access information
/// @return none
void Cadc_u2b_regif::DumpRegMsg(const std::string operation, const std::string RegName, const std::string BitName, cuint size, cuint addr, cuint wr_data, cuint pre_data, cuint data, cuint reg_length)
{
    if (mDumpRegisterRW) {
        std::string reg_name = RegName;
        std::ostringstream str_tmp;
        if (BitName != "") {
            reg_name += ":" + BitName;
        }
        str_tmp<<"REG ["<<std::setw(22)<<std::left<<reg_name<<"] ";
        str_tmp<<operation;
        str_tmp<<" Size= "<<size;
        str_tmp<<" Addr= "<<Num2HexStr(addr,13, false, false, size);
        if (operation == "R") {
            str_tmp<<" Data= "<<Num2HexStr(data    , reg_length, true, true, size);
        } else {
            #ifdef MSG_WO_WR_DATA
            str_tmp<<" Data= "<<Num2HexStr(pre_data, reg_length, false, false, size);
            #else
            str_tmp<<" Data= "<<Num2HexStr(wr_data , reg_length, false, true, size);
            str_tmp<<" : "    <<Num2HexStr(pre_data, reg_length, false, false, size);
            #endif
            str_tmp<<" => "   <<Num2HexStr(data    , reg_length, true, false, size);
        }
        re_printf("DumpRegMsg", "%s\n", str_tmp.str().c_str());
    }
}

/// find register pointer based on accessed address
/// @return accessed register pointer
int Cadc_u2b_regif::get_reg_index(cuint access_addr)
{
    if (access_addr < (1<<13)) {
        if (mRegMap[access_addr] != (1<<13)) {
            return mRegMap[access_addr];
        }
    }
    return -1;
}

/// find first register pointer
/// @return first register pointer
vpcl::re_register *Cadc_u2b_regif::first_reg_object()
{
    mCurReg = mRegList;
    return mCurReg->my_p;
}

/// find next register pointer
/// @return next register pointer
vpcl::re_register *Cadc_u2b_regif::next_reg_object()
{
    assert(mCurReg != NULL);
    mCurReg = mCurReg->prev;
    if (mCurReg != NULL) {
        return mCurReg->my_p;
    }
    return NULL;
}

/// write callback function of CoWare
/// @return none
void Cadc_u2b_regif::wr_cb(cuint addr, uint data)
{
    #ifdef USR_CWR_SYSTEMC
    cwmem.put( (addr&0xFFFF), data);
    #else
    array[addr&0xFFFF] = data;
    #endif
}

/// read callback function of CoWare
/// @return read data
Cadc_u2b_regif::uint Cadc_u2b_regif::rd_cb(cuint addr)
{
    #ifdef USR_CWR_SYSTEMC
    uint data=0;
    data = cwmem.get((addr&0xFFFF));
    return data;
    #else
    return array[addr&0xFFFF];
    #endif
}

/// print message function
/// @return none
void Cadc_u2b_regif::_re_printf(std::string group, const char *message, ...)
{
    // message group check
    if (group == "DumpRegMsg") {
        group = "info";
    } else {
        #ifndef REGIF_SC_REPORT
        if (!mMessageLevel[group]) return;
        #endif//REGIF_SC_REPORT
    }

    if (message == NULL) return;

    // print header
    #ifndef REGIF_NOT_USE_SYSTEMC
    std::stringstream t_stream;
    std::string cur_time;

    double tu_value = 0;
    std::string tu_name = "";
    if (sc_get_time_resolution() < sc_time(1, SC_PS)) {
        tu_value = 1000000000000000LL;
        tu_name = " fs";
    } else if (sc_get_time_resolution() < sc_time(1, SC_NS)) {
        tu_value = 1000000000000LL;
        tu_name = " ps";
    } else if (sc_get_time_resolution() < sc_time(1, SC_US)) {
        tu_value = 1000000000;
        tu_name = " ns";
    } else if (sc_get_time_resolution() < sc_time(1, SC_MS)) {
        tu_value = 1000000;
        tu_name = " us";
    } else if (sc_get_time_resolution() < sc_time(1, SC_SEC)) {
        tu_value = 1000;
        tu_name = " ms";
    } else {
        tu_value = 1;
        tu_name = " s";
    }
    t_stream << sc_time_stamp().value() * (uint64) (sc_get_time_resolution().to_seconds() * tu_value) << tu_name;

    cur_time = t_stream.str();
    #else
    std::string cur_time = "";
    #endif

    #ifndef REGIF_SC_REPORT
    #ifdef MSG_COLOR
    // color setting
    //
    // severity color       color Linux       Windows
    // fatal    RED         RED   \033[0;31m  FOREGROUND_RED
    // error    RED         BLUE  \033[0;34m  FOREGROUND_BLUE
    // warning  RED
    // info     BLUE
    #ifdef _WIN32
    HANDLE hStdout;
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    if (group == "error" || group == "warning") {
        SetConsoleTextAttribute(hStdout, FOREGROUND_RED);
    } else if (group == "info" ){
        SetConsoleTextAttribute(hStdout, FOREGROUND_BLUE);
    }
    #else
    if (group == "error" || group == "warning") {
        printf("\033[0;31m");
    } else if (group == "info" ){
        printf("\033[0;34m");
    }
    #endif
    #endif //MSG_COLOR
    printf("%8s [%20s] (%10s) ", group.c_str(), cur_time.c_str(), mInstName.c_str());
    #endif//REGIF_SC_REPORT

    // print body
    va_list argptr;
    va_start(argptr, message);
    if (argptr == NULL) return;
    #ifdef REGIF_SC_REPORT
    char str[1024];
    sprintf(str, "[%20s] ", cur_time.c_str());
    vsprintf(str+23, message, argptr);
    if (group == "error") {
        SC_REPORT_ERROR(mInstName.c_str(), str);
    } else if (group == "warning") {
        SC_REPORT_WARNING(mInstName.c_str(), str);
    } else if (group == "info") {
        SC_REPORT_INFO(mInstName.c_str(), str);
    }
    #else //REGIF_SC_REPORT
    vprintf(message, argptr);
    #endif//REGIF_SC_REPORT

    #ifndef REGIF_SC_REPORT
    #ifdef DumpFileNameLineNum
    // print footer
    if (group == "error") {
        printf(" [%s:%d]\n", mFileName.c_str(), mLineNum);
    }
    #endif//DumpFileNameLineNum
    #endif//REGIF_SC_REPORT
    va_end(argptr);

    #ifndef REGIF_SC_REPORT
    #ifdef MSG_COLOR
    #ifdef _WIN32
    SetConsoleTextAttribute(hStdout, csbi.wAttributes);
    #else
    printf("\033[m");
    #endif
    #endif //MSG_COLOR
    #endif//REGIF_SC_REPORT

    fflush(stdout);
    fflush(stderr);

}

/// Get file name and line number
/// @return none
void Cadc_u2b_regif::get_fileline(std::string filename, int line_number)
{
    mFileName = filename;
    mLineNum  = line_number;
}

/// API for instance registration
/// @return none
void Cadc_u2b_regif::set_instance_name(std::string InstName)
{
    mInstName = InstName;
}

/// Method to change value of mIsReset
/// @return none
void Cadc_u2b_regif::EnableReset(const bool is_active)
{
    // update register IF class's reset status
    mIsReset = is_active;

    // update re_register's reset status
    for (uint i = 0; i < mTotalRegNum; i++) {
        mRegArray[i]->my_p->EnableReset(is_active);
        if (is_active) {
            re_printf("info", "Initialize %s (%08x)\n", mRegArray[i]->my_p->name().c_str(), (uint)(*mRegArray[i]->my_p));
        }
    }

}

#ifdef USR_CWR_SYSTEMC
uint Cadc_u2b_regif::cw_rd_cb(tlm::tlm_generic_payload& trans, int tag)
{
    int reg_index = get_reg_index((uint)tag);
    assert(reg_index != (1<<16));
    uint length = mRegArray[reg_index]->length;
    uint tmp_addr = (uint)tag;
    #ifdef IS_MODELED_ENDIAN_BIG
    if (length < mBusByteWidth) {
        tmp_addr = (uint)tag ^ (mBusByteWidth - length);
    }
    #endif
    unsigned char* ptr = (unsigned char*)trans.get_data_ptr();
    memset(ptr,0,sizeof(REG_TYPE));
    reg_rd_dbg(tmp_addr, ptr, length);
    return sizeof(REG_TYPE);
}

uint Cadc_u2b_regif::cw_wr_cb(tlm::tlm_generic_payload& trans, int tag)
{
    int reg_index = get_reg_index((uint)tag);
    assert(reg_index != (1<<16));
    uint length = mRegArray[reg_index]->length;
    uint tmp_addr = (uint)tag;
    #ifdef IS_MODELED_ENDIAN_BIG
    if (length < mBusByteWidth) {
        tmp_addr = (uint)tag ^ (mBusByteWidth - length);
    }
    #endif
    unsigned char* ptr = (unsigned char*)trans.get_data_ptr();
    reg_wr_dbg(tmp_addr, ptr, length);
    return sizeof(REG_TYPE);
}

void Cadc_u2b_regif::cw_set_all_callback_reg(void)
{
    for(uint indx=0; indx<mTotalRegNum; indx++){
        cw_set_callback_reg( mRegArray[indx]->my_cw_p, (unsigned int)mRegArray[indx]->my_p->addr());
    }
}
#endif
