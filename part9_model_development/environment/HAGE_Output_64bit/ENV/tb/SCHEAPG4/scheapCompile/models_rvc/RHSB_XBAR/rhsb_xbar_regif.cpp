// -----------------------------------------------------------------------------
// $Id: rhsb_xbar_regif.cpp 1339 2019-11-14 09:01:36Z chuonghoangle $
//
// Copyright(c) 2016-2019 Renesas Electronics Corporation
// Copyright(c) 2016-2019 Renesas Design Vietnam Co., Ltd.
// RENESAS ELECTRONICS CONFIDENTIAL AND PROPRIETARY.
// This program must be used solely for the purpose for which
// it was furnished by Renesas Electronics Corporation. No part of this
// program may be reproduced or disclosed to others, in any
// form, without the prior written permission of Renesas Electronics
// Corporation.
// -----------------------------------------------------------------------------
// This file is generated by Register I/F generator
//    gen_regif.py 1.9 2013/12/04 09:51:36 sontran
//    gen_regif_class.py 1.60 2014/10/24 09:42:15 ducduong
//    regif_cpp.skl 1.53 2014/10/13 03:19:16 sontran
//
// Input file : RHSB_XBAR_regif.txt
////////////////////////////////////////////////////////////////////////////////
// %MODULE RHSB_XBAR
//     #                   name            offset_size
//     %%REG_INSTANCE      reg_def         6
// 
// %REG_CHANNEL reg_def
//     %%TITLE  name       reg_name   wsize   rsize    length  offset  factor_start  factor_end  factor_index  factor_step  access  init        support  callback
//     %%REG    RHSBGCR0H  RHSBGCR0H  8|16|32 8|16|32  32      0x0000  -             -           -             -             W|R      0           TRUE     -
//     %%REG    RHSBGCR0L  RHSBGCR0L  8|16|32 8|16|32  32      0x0004  -             -           -             -             W|R      0           TRUE     -
//     %%REG    RHSBGCRO0  RHSBGCRO0  8|16|32 8|16|32  32      0x0020  -             -           -             -             W|R      0           TRUE     -
//     %%REG    RHSBGCR1H  RHSBGCR1H  8|16|32 8|16|32  32      0x0008  -             -           -             -             W|R      0           TRUE     -
//     %%REG    RHSBGCR1L  RHSBGCR1L  8|16|32 8|16|32  32      0x000C  -             -           -             -             W|R      0           TRUE     -
//     %%REG    RHSBGCRO1  RHSBGCRO1  8|16|32 8|16|32  32      0x0024  -             -           -             -             W|R      0           TRUE     -
//     %%REG    RHSBGCR2H  RHSBGCR2H  8|16|32 8|16|32  32      0x0010  -             -           -             -             W|R      0           TRUE     -
//     %%REG    RHSBGCR2L  RHSBGCR2L  8|16|32 8|16|32  32      0x0014  -             -           -             -             W|R      0           TRUE     -
//     %%REG    RHSBGCRO2  RHSBGCRO2  8|16|32 8|16|32  32      0x0028  -             -           -             -             W|R      0           TRUE     -
//     %%REG    RHSBGCR3H  RHSBGCR3H  8|16|32 8|16|32  32      0x0018  -             -           -             -             W|R      0           TRUE     -
//     %%REG    RHSBGCR3L  RHSBGCR3L  8|16|32 8|16|32  32      0x001C  -             -           -             -             W|R      0           TRUE     -
//     %%REG    RHSBGCRO3  RHSBGCRO3  8|16|32 8|16|32  32      0x002C  -             -           -             -             W|R      0           TRUE     -
// 
// %REG_NAME RHSBGCR0H
//     %%TITLE  name        upper  lower  init  access  support  callback
//     %%BIT    MMD015       31      28     0     W|R     TRUE     -
//     %%BIT    MMD014       27      24     0     W|R     TRUE     -
//     %%BIT    MMD013       23      20     0     W|R     TRUE     -
//     %%BIT    MMD012       19      16     0     W|R     TRUE     -
//     %%BIT    MMD011       15      12     0     W|R     TRUE     -
//     %%BIT    MMD010       11      8      0     W|R     TRUE     -
//     %%BIT    MMD09        7       4      0     W|R     TRUE     -
//     %%BIT    MMD08        3       0      0     W|R     TRUE     -
// 
// %REG_NAME RHSBGCR0L
//     %%TITLE  name        upper  lower  init  access  support  callback
//     %%BIT    MMD07       31      28     0     W|R     TRUE     -
//     %%BIT    MMD06       27      24     0     W|R     TRUE     -
//     %%BIT    MMD05       23      20     0     W|R     TRUE     -
//     %%BIT    MMD04       19      16     0     W|R     TRUE     -
//     %%BIT    MMD03       15      12     0     W|R     TRUE     -
//     %%BIT    MMD02       11      8      0     W|R     TRUE     -
//     %%BIT    MMD01       7       4      0     W|R     TRUE     -
//     %%BIT    MMD00       3       0      0     W|R     TRUE     -
// 
// %REG_NAME RHSBGCRO0
//     %%TITLE  name        upper  lower  init  access  support  callback
//     %%BIT    MMDO015       31     30     0     W|R     TRUE     -
//     %%BIT    MMDO014       29     28     0     W|R     TRUE     -
//     %%BIT    MMDO013       27     26     0     W|R     TRUE     -
//     %%BIT    MMDO012       25     24     0     W|R     TRUE     -
//     %%BIT    MMDO011       23     22     0     W|R     TRUE     -
//     %%BIT    MMDO010       21     20     0     W|R     TRUE     -
//     %%BIT    MMDO09        19     18     0     W|R     TRUE     -
//     %%BIT    MMDO08        17     16     0     W|R     TRUE     -
//     %%BIT    MMDO07        15     14     0     W|R     TRUE     -
//     %%BIT    MMDO06        13     12     0     W|R     TRUE     -
//     %%BIT    MMDO05        11     10     0     W|R     TRUE     -
//     %%BIT    MMDO04        9      8      0     W|R     TRUE     -
//     %%BIT    MMDO03        7      6      0     W|R     TRUE     -
//     %%BIT    MMDO02        5      4      0     W|R     TRUE     -
//     %%BIT    MMDO01        3      2      0     W|R     TRUE     -
//     %%BIT    MMDO00        1      0      0     W|R     TRUE     -
// 
// %REG_NAME RHSBGCR1H
//     %%TITLE  name        upper  lower  init  access  support  callback
//     %%BIT    MMD115       31      28     0     W|R     TRUE     -
//     %%BIT    MMD114       27      24     0     W|R     TRUE     -
//     %%BIT    MMD113       23      20     0     W|R     TRUE     -
//     %%BIT    MMD112       19      16     0     W|R     TRUE     -
//     %%BIT    MMD111       15      12     0     W|R     TRUE     -
//     %%BIT    MMD110       11      8      0     W|R     TRUE     -
//     %%BIT    MMD19        7       4      0     W|R     TRUE     -
//     %%BIT    MMD18        3       0      0     W|R     TRUE     -
// 
// %REG_NAME RHSBGCR1L
//     %%TITLE  name        upper  lower  init  access  support  callback
//     %%BIT    MMD17       31      28     0     W|R     TRUE     -
//     %%BIT    MMD16       27      24     0     W|R     TRUE     -
//     %%BIT    MMD15       23      20     0     W|R     TRUE     -
//     %%BIT    MMD14       19      16     0     W|R     TRUE     -
//     %%BIT    MMD13       15      12     0     W|R     TRUE     -
//     %%BIT    MMD12       11      8      0     W|R     TRUE     -
//     %%BIT    MMD11       7       4      0     W|R     TRUE     -
//     %%BIT    MMD10       3       0      0     W|R     TRUE     -
// 
// %REG_NAME RHSBGCRO1
//     %%TITLE  name        upper  lower  init  access  support  callback
//     %%BIT    MMDO115       31     30     0     W|R     TRUE     -
//     %%BIT    MMDO114       29     28     0     W|R     TRUE     -
//     %%BIT    MMDO113       27     26     0     W|R     TRUE     -
//     %%BIT    MMDO112       25     24     0     W|R     TRUE     -
//     %%BIT    MMDO111       23     22     0     W|R     TRUE     -
//     %%BIT    MMDO110       21     20     0     W|R     TRUE     -
//     %%BIT    MMDO19        19     18     0     W|R     TRUE     -
//     %%BIT    MMDO18        17     16     0     W|R     TRUE     -
//     %%BIT    MMDO17        15     14     0     W|R     TRUE     -
//     %%BIT    MMDO16        13     12     0     W|R     TRUE     -
//     %%BIT    MMDO15        11     10     0     W|R     TRUE     -
//     %%BIT    MMDO14        9      8      0     W|R     TRUE     -
//     %%BIT    MMDO13        7      6      0     W|R     TRUE     -
//     %%BIT    MMDO12        5      4      0     W|R     TRUE     -
//     %%BIT    MMDO11        3      2      0     W|R     TRUE     -
//     %%BIT    MMDO10        1      0      0     W|R     TRUE     -
// 
// %REG_NAME RHSBGCR2H
//     %%TITLE  name        upper  lower  init  access  support  callback
//     %%BIT    MMD215       31      28     0     W|R     TRUE     -
//     %%BIT    MMD214       27      24     0     W|R     TRUE     -
//     %%BIT    MMD213       23      20     0     W|R     TRUE     -
//     %%BIT    MMD212       19      16     0     W|R     TRUE     -
//     %%BIT    MMD211       15      12     0     W|R     TRUE     -
//     %%BIT    MMD210       11      8      0     W|R     TRUE     -
//     %%BIT    MMD29        7       4      0     W|R     TRUE     -
//     %%BIT    MMD28        3       0      0     W|R     TRUE     -
// 
// %REG_NAME RHSBGCR2L
//     %%TITLE  name        upper  lower  init  access  support  callback
//     %%BIT    MMD27       31      28     0     W|R     TRUE     -
//     %%BIT    MMD26       27      24     0     W|R     TRUE     -
//     %%BIT    MMD25       23      20     0     W|R     TRUE     -
//     %%BIT    MMD24       19      16     0     W|R     TRUE     -
//     %%BIT    MMD23       15      12     0     W|R     TRUE     -
//     %%BIT    MMD22       11      8      0     W|R     TRUE     -
//     %%BIT    MMD21       7       4      0     W|R     TRUE     -
//     %%BIT    MMD20       3       0      0     W|R     TRUE     -
// 
// %REG_NAME RHSBGCRO2
//     %%TITLE  name        upper  lower  init  access  support  callback
//     %%BIT    MMDO215       31     30     0     W|R     TRUE     -
//     %%BIT    MMDO214       29     28     0     W|R     TRUE     -
//     %%BIT    MMDO213       27     26     0     W|R     TRUE     -
//     %%BIT    MMDO212       25     24     0     W|R     TRUE     -
//     %%BIT    MMDO211       23     22     0     W|R     TRUE     -
//     %%BIT    MMDO210       21     20     0     W|R     TRUE     -
//     %%BIT    MMDO29        19     18     0     W|R     TRUE     -
//     %%BIT    MMDO28        17     16     0     W|R     TRUE     -
//     %%BIT    MMDO27        15     14     0     W|R     TRUE     -
//     %%BIT    MMDO26        13     12     0     W|R     TRUE     -
//     %%BIT    MMDO25        11     10     0     W|R     TRUE     -
//     %%BIT    MMDO24        9      8      0     W|R     TRUE     -
//     %%BIT    MMDO23        7      6      0     W|R     TRUE     -
//     %%BIT    MMDO22        5      4      0     W|R     TRUE     -
//     %%BIT    MMDO21        3      2      0     W|R     TRUE     -
//     %%BIT    MMDO20        1      0      0     W|R     TRUE     -
// 
// %REG_NAME RHSBGCR3H
//     %%TITLE  name        upper  lower  init  access  support  callback
//     %%BIT    MMD315       31      28     0     W|R     TRUE     -
//     %%BIT    MMD314       27      24     0     W|R     TRUE     -
//     %%BIT    MMD313       23      20     0     W|R     TRUE     -
//     %%BIT    MMD312       19      16     0     W|R     TRUE     -
//     %%BIT    MMD311       15      12     0     W|R     TRUE     -
//     %%BIT    MMD310       11      8      0     W|R     TRUE     -
//     %%BIT    MMD39        7       4      0     W|R     TRUE     -
//     %%BIT    MMD38        3       0      0     W|R     TRUE     -
// 
// %REG_NAME RHSBGCR3L
//     %%TITLE  name        upper  lower  init  access  support  callback
//     %%BIT    MMD37       31      28     0     W|R     TRUE     -
//     %%BIT    MMD36       27      24     0     W|R     TRUE     -
//     %%BIT    MMD35       23      20     0     W|R     TRUE     -
//     %%BIT    MMD34       19      16     0     W|R     TRUE     -
//     %%BIT    MMD33       15      12     0     W|R     TRUE     -
//     %%BIT    MMD32       11      8      0     W|R     TRUE     -
//     %%BIT    MMD31       7       4      0     W|R     TRUE     -
//     %%BIT    MMD30       3       0      0     W|R     TRUE     -
// 
// %REG_NAME RHSBGCRO3
//     %%TITLE  name        upper  lower  init  access  support  callback
//     %%BIT    MMDO315       31     30     0     W|R     TRUE     -
//     %%BIT    MMDO314       29     28     0     W|R     TRUE     -
//     %%BIT    MMDO313       27     26     0     W|R     TRUE     -
//     %%BIT    MMDO312       25     24     0     W|R     TRUE     -
//     %%BIT    MMDO311       23     22     0     W|R     TRUE     -
//     %%BIT    MMDO310       21     20     0     W|R     TRUE     -
//     %%BIT    MMDO39        19     18     0     W|R     TRUE     -
//     %%BIT    MMDO38        17     16     0     W|R     TRUE     -
//     %%BIT    MMDO37        15     14     0     W|R     TRUE     -
//     %%BIT    MMDO36        13     12     0     W|R     TRUE     -
//     %%BIT    MMDO35        11     10     0     W|R     TRUE     -
//     %%BIT    MMDO34        9      8      0     W|R     TRUE     -
//     %%BIT    MMDO33        7      6      0     W|R     TRUE     -
//     %%BIT    MMDO32        5      4      0     W|R     TRUE     -
//     %%BIT    MMDO31        3      2      0     W|R     TRUE     -
//     %%BIT    MMDO30        1      0      0     W|R     TRUE     -
// 
////////////////////////////////////////////////////////////////////////////////
/// @file rhsb_xbar_regif.cpp
/// @brief Register IF class of model RHSB_XBAR
/// $Id: rhsb_xbar_regif.cpp 1339 2019-11-14 09:01:36Z chuonghoangle $
/// $Date: 2019-11-14 18:01:36 +0900 (2019/11/14 (æœ¨)) $
/// $Revison$
/// $Author: chuonghoangle $
////////////////////////////////////////////////////////////////////////////////
#include "rhsb_xbar_regif.h"
#ifndef re_printf
#define re_printf get_fileline(__FILE__, __LINE__); _re_printf
#endif//re_printf

/// Constructor of Register IF class: define registers and bits
/// @return none
Crhsb_xbar_regif::Crhsb_xbar_regif(std::string name, uint buswidth)
    :vpcl::reg_super()
    #ifdef CWR_SYSTEMC
    , cwmem("register", scml_memsize(0x30/4))
    #endif
{
    CommandInit();
    RHSBGCR0H = new vpcl::re_register(0x0000, this, "RHSBGCR0H", name.c_str());
    RHSBGCR0L = new vpcl::re_register(0x0004, this, "RHSBGCR0L", name.c_str());
    RHSBGCRO0 = new vpcl::re_register(0x0020, this, "RHSBGCRO0", name.c_str());
    RHSBGCR1H = new vpcl::re_register(0x0008, this, "RHSBGCR1H", name.c_str());
    RHSBGCR1L = new vpcl::re_register(0x000C, this, "RHSBGCR1L", name.c_str());
    RHSBGCRO1 = new vpcl::re_register(0x0024, this, "RHSBGCRO1", name.c_str());
    RHSBGCR2H = new vpcl::re_register(0x0010, this, "RHSBGCR2H", name.c_str());
    RHSBGCR2L = new vpcl::re_register(0x0014, this, "RHSBGCR2L", name.c_str());
    RHSBGCRO2 = new vpcl::re_register(0x0028, this, "RHSBGCRO2", name.c_str());
    RHSBGCR3H = new vpcl::re_register(0x0018, this, "RHSBGCR3H", name.c_str());
    RHSBGCR3L = new vpcl::re_register(0x001C, this, "RHSBGCR3L", name.c_str());
    RHSBGCRO3 = new vpcl::re_register(0x002C, this, "RHSBGCRO3", name.c_str());

    // Construct the register pointer list
    mCurReg = NULL;

    uint index = 0;
    mRegMap = new uint [1<<6];
    for (uint i = 0; i < (1<<6); i++) {
        mRegMap[i] = (1<<6);
    }

    mRegMap[0x0000]     = index;
    mRegMap[0x0000 + 1] = index;
    mRegMap[0x0000 + 2] = index;
    mRegMap[0x0000 + 3] = index++;
    mRegMap[0x0004]     = index;
    mRegMap[0x0004 + 1] = index;
    mRegMap[0x0004 + 2] = index;
    mRegMap[0x0004 + 3] = index++;
    mRegMap[0x0008]     = index;
    mRegMap[0x0008 + 1] = index;
    mRegMap[0x0008 + 2] = index;
    mRegMap[0x0008 + 3] = index++;
    mRegMap[0x000C]     = index;
    mRegMap[0x000C + 1] = index;
    mRegMap[0x000C + 2] = index;
    mRegMap[0x000C + 3] = index++;
    mRegMap[0x0010]     = index;
    mRegMap[0x0010 + 1] = index;
    mRegMap[0x0010 + 2] = index;
    mRegMap[0x0010 + 3] = index++;
    mRegMap[0x0014]     = index;
    mRegMap[0x0014 + 1] = index;
    mRegMap[0x0014 + 2] = index;
    mRegMap[0x0014 + 3] = index++;
    mRegMap[0x0018]     = index;
    mRegMap[0x0018 + 1] = index;
    mRegMap[0x0018 + 2] = index;
    mRegMap[0x0018 + 3] = index++;
    mRegMap[0x001C]     = index;
    mRegMap[0x001C + 1] = index;
    mRegMap[0x001C + 2] = index;
    mRegMap[0x001C + 3] = index++;
    mRegMap[0x0020]     = index;
    mRegMap[0x0020 + 1] = index;
    mRegMap[0x0020 + 2] = index;
    mRegMap[0x0020 + 3] = index++;
    mRegMap[0x0024]     = index;
    mRegMap[0x0024 + 1] = index;
    mRegMap[0x0024 + 2] = index;
    mRegMap[0x0024 + 3] = index++;
    mRegMap[0x0028]     = index;
    mRegMap[0x0028 + 1] = index;
    mRegMap[0x0028 + 2] = index;
    mRegMap[0x0028 + 3] = index++;
    mRegMap[0x002C]     = index;
    mRegMap[0x002C + 1] = index;
    mRegMap[0x002C + 2] = index;
    mRegMap[0x002C + 3] = index++;
    mTotalRegNum = index;
    mRegArray = new SRegList* [mTotalRegNum];
    index = 0;
    #ifdef CWR_SYSTEMC
    cw_instantiate_reg(CW_RHSBGCR0H  , RHSBGCR0H->name(), RHSBGCR0H->addr());
    cw_instantiate_reg(CW_RHSBGCR0L  , RHSBGCR0L->name(), RHSBGCR0L->addr());
    cw_instantiate_reg(CW_RHSBGCR1H  , RHSBGCR1H->name(), RHSBGCR1H->addr());
    cw_instantiate_reg(CW_RHSBGCR1L  , RHSBGCR1L->name(), RHSBGCR1L->addr());
    cw_instantiate_reg(CW_RHSBGCR2H  , RHSBGCR2H->name(), RHSBGCR2H->addr());
    cw_instantiate_reg(CW_RHSBGCR2L  , RHSBGCR2L->name(), RHSBGCR2L->addr());
    cw_instantiate_reg(CW_RHSBGCR3H  , RHSBGCR3H->name(), RHSBGCR3H->addr());
    cw_instantiate_reg(CW_RHSBGCR3L  , RHSBGCR3L->name(), RHSBGCR3L->addr());
    cw_instantiate_reg(CW_RHSBGCRO0  , RHSBGCRO0->name(), RHSBGCRO0->addr());
    cw_instantiate_reg(CW_RHSBGCRO1  , RHSBGCRO1->name(), RHSBGCRO1->addr());
    cw_instantiate_reg(CW_RHSBGCRO2  , RHSBGCRO2->name(), RHSBGCRO2->addr());
    cw_instantiate_reg(CW_RHSBGCRO3  , RHSBGCRO3->name(), RHSBGCRO3->addr());
    #endif
    mCurReg = mRegArray[index++] = new SRegList(RHSBGCR0H  , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(RHSBGCR0L  , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(RHSBGCR1H  , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(RHSBGCR1L  , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(RHSBGCR2H  , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(RHSBGCR2L  , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(RHSBGCR3H  , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(RHSBGCR3L  , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(RHSBGCRO0  , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(RHSBGCRO1  , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(RHSBGCRO2  , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(RHSBGCRO3  , mCurReg, 0,  4, "8|16|32", "8|16|32");

    mRegList = mCurReg;

    (*RHSBGCR0H  ) (31, 28, "MMD015"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR0H  ) (27, 24, "MMD014"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR0H  ) (23, 20, "MMD013"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR0H  ) (19, 16, "MMD012"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR0H  ) (15, 12, "MMD011"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR0H  ) (11,  8, "MMD010"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR0H  ) ( 7,  4, "MMD09"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR0H  ) ( 3,  0, "MMD08"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR0L  ) (31, 28, "MMD07"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR0L  ) (27, 24, "MMD06"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR0L  ) (23, 20, "MMD05"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR0L  ) (19, 16, "MMD04"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR0L  ) (15, 12, "MMD03"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR0L  ) (11,  8, "MMD02"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR0L  ) ( 7,  4, "MMD01"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR0L  ) ( 3,  0, "MMD00"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO0  ) (31, 30, "MMDO015" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO0  ) (29, 28, "MMDO014" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO0  ) (27, 26, "MMDO013" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO0  ) (25, 24, "MMDO012" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO0  ) (23, 22, "MMDO011" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO0  ) (21, 20, "MMDO010" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO0  ) (19, 18, "MMDO09"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO0  ) (17, 16, "MMDO08"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO0  ) (15, 14, "MMDO07"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO0  ) (13, 12, "MMDO06"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO0  ) (11, 10, "MMDO05"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO0  ) ( 9,  8, "MMDO04"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO0  ) ( 7,  6, "MMDO03"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO0  ) ( 5,  4, "MMDO02"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO0  ) ( 3,  2, "MMDO01"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO0  ) ( 1,  0, "MMDO00"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR1H  ) (31, 28, "MMD115"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR1H  ) (27, 24, "MMD114"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR1H  ) (23, 20, "MMD113"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR1H  ) (19, 16, "MMD112"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR1H  ) (15, 12, "MMD111"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR1H  ) (11,  8, "MMD110"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR1H  ) ( 7,  4, "MMD19"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR1H  ) ( 3,  0, "MMD18"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR1L  ) (31, 28, "MMD17"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR1L  ) (27, 24, "MMD16"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR1L  ) (23, 20, "MMD15"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR1L  ) (19, 16, "MMD14"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR1L  ) (15, 12, "MMD13"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR1L  ) (11,  8, "MMD12"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR1L  ) ( 7,  4, "MMD11"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR1L  ) ( 3,  0, "MMD10"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO1  ) (31, 30, "MMDO115" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO1  ) (29, 28, "MMDO114" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO1  ) (27, 26, "MMDO113" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO1  ) (25, 24, "MMDO112" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO1  ) (23, 22, "MMDO111" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO1  ) (21, 20, "MMDO110" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO1  ) (19, 18, "MMDO19"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO1  ) (17, 16, "MMDO18"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO1  ) (15, 14, "MMDO17"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO1  ) (13, 12, "MMDO16"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO1  ) (11, 10, "MMDO15"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO1  ) ( 9,  8, "MMDO14"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO1  ) ( 7,  6, "MMDO13"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO1  ) ( 5,  4, "MMDO12"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO1  ) ( 3,  2, "MMDO11"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO1  ) ( 1,  0, "MMDO10"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR2H  ) (31, 28, "MMD215"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR2H  ) (27, 24, "MMD214"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR2H  ) (23, 20, "MMD213"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR2H  ) (19, 16, "MMD212"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR2H  ) (15, 12, "MMD211"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR2H  ) (11,  8, "MMD210"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR2H  ) ( 7,  4, "MMD29"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR2H  ) ( 3,  0, "MMD28"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR2L  ) (31, 28, "MMD27"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR2L  ) (27, 24, "MMD26"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR2L  ) (23, 20, "MMD25"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR2L  ) (19, 16, "MMD24"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR2L  ) (15, 12, "MMD23"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR2L  ) (11,  8, "MMD22"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR2L  ) ( 7,  4, "MMD21"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR2L  ) ( 3,  0, "MMD20"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO2  ) (31, 30, "MMDO215" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO2  ) (29, 28, "MMDO214" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO2  ) (27, 26, "MMDO213" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO2  ) (25, 24, "MMDO212" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO2  ) (23, 22, "MMDO211" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO2  ) (21, 20, "MMDO210" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO2  ) (19, 18, "MMDO29"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO2  ) (17, 16, "MMDO28"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO2  ) (15, 14, "MMDO27"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO2  ) (13, 12, "MMDO26"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO2  ) (11, 10, "MMDO25"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO2  ) ( 9,  8, "MMDO24"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO2  ) ( 7,  6, "MMDO23"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO2  ) ( 5,  4, "MMDO22"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO2  ) ( 3,  2, "MMDO21"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO2  ) ( 1,  0, "MMDO20"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR3H  ) (31, 28, "MMD315"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR3H  ) (27, 24, "MMD314"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR3H  ) (23, 20, "MMD313"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR3H  ) (19, 16, "MMD312"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR3H  ) (15, 12, "MMD311"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR3H  ) (11,  8, "MMD310"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR3H  ) ( 7,  4, "MMD39"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR3H  ) ( 3,  0, "MMD38"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR3L  ) (31, 28, "MMD37"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR3L  ) (27, 24, "MMD36"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR3L  ) (23, 20, "MMD35"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR3L  ) (19, 16, "MMD34"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR3L  ) (15, 12, "MMD33"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR3L  ) (11,  8, "MMD32"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR3L  ) ( 7,  4, "MMD31"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCR3L  ) ( 3,  0, "MMD30"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO3  ) (31, 30, "MMDO315" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO3  ) (29, 28, "MMDO314" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO3  ) (27, 26, "MMDO313" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO3  ) (25, 24, "MMDO312" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO3  ) (23, 22, "MMDO311" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO3  ) (21, 20, "MMDO310" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO3  ) (19, 18, "MMDO39"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO3  ) (17, 16, "MMDO38"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO3  ) (15, 14, "MMDO37"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO3  ) (13, 12, "MMDO36"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO3  ) (11, 10, "MMDO35"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO3  ) ( 9,  8, "MMDO34"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO3  ) ( 7,  6, "MMDO33"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO3  ) ( 5,  4, "MMDO32"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO3  ) ( 3,  2, "MMDO31"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RHSBGCRO3  ) ( 1,  0, "MMDO30"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);

    mFileName = "";
    mInstName = name;
    mLineNum = 0;
    mBusWidth = buswidth;
    mBusByteWidth = mBusWidth/8;   // using in BIG ENDIAN
    mIsReset = false;

    // Constructor the callback function of each register
    for (uint i = 0; i < mTotalRegNum; i++) {
        mWrCbAPI[mRegArray[i]->my_p->name()][mRegArray[i]->my_p->name()] = NULL;
        mRdCbAPI[mRegArray[i]->my_p->name()][mRegArray[i]->my_p->name()] = NULL;
    }

    //Constructor the mWrCbAPI, mRdCbAPI variable of each register

    InitLocalVal();
}

/// Destructor: delete pointers
/// @return none
Crhsb_xbar_regif::~Crhsb_xbar_regif()
{
    // Delete registers' pointer
    for (uint i = 0 ; i < mTotalRegNum ; i++) {
        delete mRegArray[i]->my_p;
        mRegArray[i]->prev = NULL;
    }
    delete [] mRegMap;
    delete [] mRegArray;
    delete mRegList;
    mCurReg = NULL;
}

/// Mask unselected bit
/// @return selected value
Crhsb_xbar_regif::uint Crhsb_xbar_regif::bit_select(
                              cuint val,    ///< [in] Writting address
                              cuint start,  ///< [in] start bit position
                              cuint end)    ///< [in] end bit position
{
    uint ret_val = val;
    if (end - start + 1 < 32) {
        ret_val = (val>>start) & (uint)((1<<(end-start+1))-1);
    }
    return ret_val;
}

/// Write the value to requested module register
/// @return true if writing transaction is finished normally
bool Crhsb_xbar_regif::reg_wr(cuint addr,                    ///< [in] Writting address
                              const unsigned char *p_data,   ///< [in] Writing data
                              cuint size)                    ///< [in] Data size (byte)
{
    if(size == 0) return false;
    #ifdef IS_MODELED_ENDIAN_BIG
    if ((addr % mBusByteWidth) + size > mBusByteWidth) return false;
    #endif

    bool ret_val = false;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(p_data != NULL);
    #else
    sc_assert(p_data != NULL);
    #endif
    ret_val = reg_wr_process (addr, p_data, size, false);
    return ret_val;
}

/// Read the register value of requested module
/// @return true if reading transaction is finished normally
bool Crhsb_xbar_regif::reg_rd(cuint addr,              ///< [in]  Reading address
                              unsigned char *p_data,   ///< [out] Reading data
                              cuint size)              ///< [in]  Data size (byte)
{
    if(size == 0) return false;
    #ifdef IS_MODELED_ENDIAN_BIG
    if ((addr % mBusByteWidth) + size > mBusByteWidth) return false;
    #endif

    bool ret_val = false;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(p_data != NULL);
    #else
    sc_assert(p_data != NULL);
    #endif
    ret_val = reg_rd_process (addr, p_data, size, false);
    return ret_val;
}

/// Write the value to requested module register
/// @return true if writing transaction is finished normally
bool Crhsb_xbar_regif::reg_wr_dbg(cuint addr,                    ///< [in] Writting address
                                  const unsigned char *p_data,   ///< [in] Writing data
                                  cuint size)                    ///< [in] Data size (byte)
{
    if(size == 0) return false;
    #ifdef IS_MODELED_ENDIAN_BIG
    if ((addr % mBusByteWidth) + size > mBusByteWidth) return false;
    #endif

    bool ret_val = false;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(p_data != NULL);
    #else
    sc_assert(p_data != NULL);
    #endif
    ret_val = reg_wr_process (addr, p_data, size, true);
    return ret_val;
}

/// Read the register value of requested module
/// @return true if reading transaction is finished normally
bool Crhsb_xbar_regif::reg_rd_dbg(cuint addr,              ///< [in]  Reading address
                                  unsigned char *p_data,   ///< [out] Reading data
                                  cuint size)              ///< [in]  Data size (byte)
{
    if(size == 0) return false;
    #ifdef IS_MODELED_ENDIAN_BIG
    if ((addr % mBusByteWidth) + size > mBusByteWidth) return false;
    #endif

    bool ret_val = false;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(p_data != NULL);
    #else
    sc_assert(p_data != NULL);
    #endif
    ret_val = reg_rd_process (addr, p_data, size, true);
    return ret_val;
}

/// Write the value to requested module register
/// @return true if writing transaction is finished normally
bool Crhsb_xbar_regif::reg_wr_process(cuint addr,                   ///< [in] Writting address
                                      const unsigned char *p_data,  ///< [in] Writing data
                                      cuint size,                   ///< [in] Data size (byte)
                                      bool IsDbgFunc)               ///< [in] flag indicate reg_rd or reg_rd_dbg
{
    if (mIsReset == true) {
        re_printf("warning", "Cannot write during reset period\n");
        return true;
    }
    uint tmp_addr = addr;
    #ifdef IS_MODELED_ENDIAN_BIG
    if (size < mBusByteWidth) {
        tmp_addr = addr ^ (mBusByteWidth - size);
    }
    #endif
    bool ret_val = false;
    bool valid_addr = false;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(p_data != NULL);
    #else
    sc_assert(p_data != NULL);
    #endif
    std::list<uint> list_index;
    uint masked_addr = bit_select(tmp_addr, 0, 6-1);
    uint access_addr = masked_addr;
    while (masked_addr + size > access_addr) {
        int reg_index = get_reg_index(access_addr);
        if (reg_index != -1) {
            vpcl::re_register *reg_p = mRegArray[reg_index]->my_p; 
            if ((IsDbgFunc == true) || (valid_addr == true) || (ChkSize(mRegArray[reg_index]->wacc_size, size, tmp_addr))) {
                valid_addr = true;
                list_index.push_back(reg_index);
            }
            else {
                re_printf("error", "Writing access size to %s at address 0x%08X is wrong: %d byte(s).\n", reg_p->name().c_str(), tmp_addr, size);
                return false;
            }
            access_addr = reg_p->addr() + mRegArray[reg_index]->length;
        } else {
            access_addr += 1;
        }
    }
    if (valid_addr == true) {
        std::list<uint>::iterator it;
        for (it=list_index.begin() ; it!=list_index.end() ; it++) {
            access_addr = masked_addr;
            uint d_size = size;
            uint index = 0;
            if (masked_addr < mRegArray[(*it)]->my_p->addr()) { // adjust access address & index
                access_addr = mRegArray[(*it)]->my_p->addr();
                index = mRegArray[(*it)]->my_p->addr() - masked_addr;
            }
            if ((masked_addr + size) < (mRegArray[(*it)]->my_p->addr() + mRegArray[(*it)]->length)) { // adjust access size
                d_size = masked_addr + size - access_addr;
            } else { // adjust access size
                d_size = (mRegArray[(*it)]->my_p->addr() + mRegArray[(*it)]->length) - access_addr;
            }
            if (size > mRegArray[(*it)]->length) { // adjust index for big endianess
                #ifdef IS_MODELED_ENDIAN_BIG
                index = index ^ (size - mRegArray[(*it)]->length);
                #endif
            }
            ret_val = reg_wr_func(tmp_addr - masked_addr + access_addr, &(p_data[index]), d_size, (*it), IsDbgFunc);
        }
    } else {
        if (IsDbgFunc == false) {
            re_printf("error", "Invalid access address 0x%08X\n", tmp_addr);
        } else {
            ret_val = true;
        }
    }
    return ret_val;
}

/// Read the register value of requested module
/// @return true if reading transaction is finished normally
bool Crhsb_xbar_regif::reg_rd_process(cuint addr,              ///< [in]  Reading address
                                      unsigned char *p_data,   ///< [out] Reading data
                                      cuint size,              ///< [in]  Data size (byte)
                                      bool IsDbgFunc)          ///< [in] flag indicate reg_rd or reg_rd_dbg
{
    uint tmp_addr = addr;
    #ifdef IS_MODELED_ENDIAN_BIG
    if (size < mBusByteWidth) {
        tmp_addr = addr ^ (mBusByteWidth - size);
    }
    #endif
    bool ret_val = false;
    bool valid_addr = false;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(p_data != NULL);
    #else
    sc_assert(p_data != NULL);
    #endif
    std::list<uint> list_index;
    uint masked_addr = bit_select(tmp_addr, 0, 6-1);
    uint access_addr = masked_addr;
    while (masked_addr + size > access_addr) {
        int reg_index = get_reg_index(access_addr);
        if (reg_index != -1) {
            vpcl::re_register *reg_p = mRegArray[reg_index]->my_p; 
            if ((IsDbgFunc == true) || (valid_addr == true) || (ChkSize(mRegArray[reg_index]->racc_size, size, tmp_addr))) {
                valid_addr = true;
                list_index.push_back(reg_index);
            }
            else {
                re_printf("error", "Reading access size to %s at address 0x%08X is wrong: %d byte(s).\n", reg_p->name().c_str(), tmp_addr, size);
                return false;
            }
            access_addr = reg_p->addr() + mRegArray[reg_index]->length;
        } else {
            access_addr += 1;
        }
    }
    if (valid_addr == true) {
        std::list<uint>::iterator it;
        for (it=list_index.begin() ; it!=list_index.end() ; it++) {
            access_addr = masked_addr;
            uint d_size = size;
            uint index = 0;
            if (masked_addr < mRegArray[(*it)]->my_p->addr()) { // adjust access address & index
                access_addr = mRegArray[(*it)]->my_p->addr();
                index = mRegArray[(*it)]->my_p->addr() - masked_addr;
            }
            if ((masked_addr + size) < (mRegArray[(*it)]->my_p->addr() + mRegArray[(*it)]->length)) { // adjust access size
                d_size = masked_addr + size - access_addr;
            } else { // adjust access size
                d_size = (mRegArray[(*it)]->my_p->addr() + mRegArray[(*it)]->length) - access_addr;
            }
            if (size > mRegArray[(*it)]->length) { // adjust index for big endianess
                #ifdef IS_MODELED_ENDIAN_BIG
                index = index ^ (size - mRegArray[(*it)]->length);
                #endif
            }
            ret_val = reg_rd_func(tmp_addr - masked_addr + access_addr, &(p_data[index]), d_size, (*it), IsDbgFunc);
        }
    } else {
        if (IsDbgFunc == false) {
            re_printf("error", "Invalid access address 0x%08X\n", tmp_addr);
        } else {
            memset(p_data, 0, size);
            ret_val = true;
        }
    }
    return ret_val;
}

/// Process reading function
/// @return true if reading successfully
bool Crhsb_xbar_regif::reg_rd_func(cuint addr,                     ///< [in]  Reading address
                                   unsigned char *p_data,          ///< [out] Reading data
                                   cuint size,                     ///< [in]  Data size (byte)
                                   cuint reg_index,                ///< [in] Register index
                                   bool IsDbgFunc)                 ///< [in] flag indicate reg_rd or reg_rd_dbg
{
    vpcl::re_register* Register = mRegArray[reg_index]->my_p;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(Register != NULL);
    #else
    sc_assert(Register != NULL);
    #endif
    
    uint pst_data = 0;
    #if 1 // always 1 since any size can be accessed in debug mode 
    uint reg_length = mRegArray[reg_index]->length;
    uint start_pos = 0;
    uint mask_size = (1 << (reg_length/2)) - 1;
    if (size < reg_length) {
        #ifdef IS_MODELED_ENDIAN_BIG
        start_pos =  (reg_length - 1)*8 - (addr & mask_size)*8; // Start bit position
        #else
        start_pos =  (addr & mask_size)*8;  // Start bit position
        #endif
    }
    #endif
    if (IsDbgFunc == false) {
        if (mIsReset == true) {
            re_printf("warning", "Cannot launch call-back function during reset period\n");
        }else {
            #if 1 // always 1 since any size can be accessed in debug mode 
            if (size < reg_length) {
                re_printf("warning","Should read all bit in a register\n");
            }
            #endif
            
            pst_data = Register->read();
            
        }
    }
    pst_data = (uint)(*Register);
    #if 1 // always 1 since any size can be accessed in debug mode 
    if (size < reg_length) {
        uint read_data = 0;
        if (((reg_length%2 == 0) && (reg_length%size == 0) && ((addr&mask_size)%size == 0)) 
         || (IsDbgFunc == false)) {
            for (uint i = start_pos; i < (8*size + start_pos); i++) {
                read_data |= (pst_data & (1 << i)) >> start_pos;
            }
            pst_data = read_data;
        }
    }
    #endif

    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(p_data != NULL);
    #else
    sc_assert(p_data != NULL);
    #endif
    memcpy(p_data, &pst_data, size);
    DumpRegMsg("R", Register->name(), "", size, addr, 0, 0, pst_data, mRegArray[reg_index]->length*8);
    for (vpcl::bit_info *it=Register->mBitInfo ; it!=NULL ; it=it->next) {
        uint val = (uint)(*Register);
        val = bit_select(val, it->mStartAddr, it->mEndAddr);
        DumpRegMsg("R", Register->name(), it->name(), size, addr, 0, 0, val, it->mEndAddr - it->mStartAddr + 1);
    }
    return true;
}

/// Process writing function
/// @return true if writing successfully
bool Crhsb_xbar_regif::reg_wr_func(cuint addr,                       ///< [in] Writting address
                                   const unsigned char *p_data,      ///< [in] Writing data
                                   cuint size,                       ///< [in] Data size (byte)
                                   cuint reg_index,                  ///< [in] Register index
                                   bool IsDbgFunc)                   ///< [in] flag indicate reg_wr or reg_wr_dbg
{
    vpcl::re_register* Register = mRegArray[reg_index]->my_p;
    uint pre_data = 0;
    uint data = 0;
    #if 1 // always 1 since any size can be accessed in debug mode 
    uint reg_length = mRegArray[reg_index]->length;
    uint start_pos = 0;
    #endif
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert ((p_data != NULL) && (Register != NULL));
    #else
    sc_assert ((p_data != NULL) && (Register != NULL));
    #endif
    memcpy(&data, p_data, size);
    #if 1 // always 1 since any size can be accessed in debug mode 
    if (size < reg_length) {
        uint mask_size = (1 << (reg_length/2)) - 1;
        if (((reg_length%2 == 0) && (reg_length%size == 0) && ((addr&mask_size)%size == 0)) 
         || (IsDbgFunc == false)) {
            uint new_data = (uint)(*Register);  // For writing to register
            uint written_data = 0;         // For transferring to callback function
            #ifdef IS_MODELED_ENDIAN_BIG
            start_pos =  (reg_length - 1)*8 - (addr & mask_size)*8; // Start bit position
            #else
            start_pos =  (addr & mask_size)*8;  // Start bit position
            #endif
            for (uint i = start_pos; i < (8*size + start_pos); i++) {
                new_data = (new_data & (~(1 << i))) | ((data << start_pos) & (1 << i));
                written_data = (written_data & (~(1 << i))) | ((data << start_pos) & (1 << i));
            }
            data = new_data;
        }
    }
    #endif

    if ((mRegArray[reg_index]->block == false) || (IsDbgFunc == true)){
        pre_data = (uint)(*Register);
        if (IsDbgFunc == true) {
            bool backup_warning = Register->mMessageLevel["warning"];
            bool backup_error = Register->mMessageLevel["error"];
            Register->mMessageLevel["warning"]   = false;
            Register->mMessageLevel["error"]   = false;

            Register->write(data);

            Register->mMessageLevel["warning"]   = backup_warning;
            Register->mMessageLevel["error"]   = backup_error;
        } else {
            Register->write(data);
        }
        UpdateLocalVal(Register->addr());
        DumpRegMsg("W", Register->name(), "", size, addr, data, pre_data, (uint)(*Register), mRegArray[reg_index]->length*8);
        for (vpcl::bit_info *it=Register->mBitInfo ; it!=NULL ; it=it->next) {
            uint val = (uint)(*Register);
            val = bit_select(val, it->mStartAddr, it->mEndAddr);
            uint pre_val = pre_data;
            pre_val = bit_select(pre_val, it->mStartAddr, it->mEndAddr);
            DumpRegMsg("W", Register->name(), it->name(), size, addr, 0, pre_val, val, it->mEndAddr - it->mStartAddr + 1);
            
        }
    }
    else {
        re_printf("warning","%s is blocked writing from Bus I/F.\n", Register->name().c_str());
    }
    return true;
}

/// Check access size
/// @@return true if detect_size equal expect_size
bool Crhsb_xbar_regif::ChkSize(std::string expect_size, cuint detect_size, cuint addr)
{
    std::vector<std::string> arg_vec = Str2Vec(expect_size, '|');
    std::vector<std::string>::iterator it;
    char *err_p = NULL;
    uint size = 0;
    if (detect_size > mBusByteWidth) {
        re_printf("error", "Invalid access size: %d bytes\n", detect_size);
        return false;
    }
    if(addr%detect_size != 0) {
        re_printf("error", "Invalid access address 0x%08X with access size %d bytes\n", addr, detect_size);
        return false;
    }
    for (it = arg_vec.begin(); it != arg_vec.end(); it++) {
        errno = 0; size = (uint) strtoul((*it).c_str(), &err_p, 0);
        #ifdef REGIF_NOT_USE_SYSTEMC
        assert(err_p != NULL);
        #else
        sc_assert(err_p != NULL);
        #endif
        if (errno != ERANGE && *err_p == '\0') {
            if ((size/8) == detect_size) {
                return true;
            }
        }
    }
    return false;
}

/// Initialize reg_handle_command variables
/// @return none
void Crhsb_xbar_regif::CommandInit()
{
    mDumpRegisterRW = false;
    mMessageLevel["fatal"]   = true;
    mMessageLevel["error"]   = true;
    mMessageLevel["warning"] = false;
    mMessageLevel["info"]    = false;
}

/// Process reg_handle_command command
/// @return string
std::string Crhsb_xbar_regif::reg_handle_command(const std::vector<std::string>& args)
{
    std::string ret = "";
    std::string err_msg = "Error ("   + mInstName + ") ";   // error message
    if (args[0] == "reg") {
        if (args[1] == "help") {
            ret += "    --- reg ---\n";
            ret += "    reg MessageLevel <fatal|error|warning|info> Select debug message level (Default: fatal,error)\n";
            ret += "    reg DumpRegisterRW <true/false>             Select dump register access information  (Default: false)\n";
            ret += "    reg <register_name> MessageLevel <fatal|error|warning|info> Select debug message level for register (Default: fatal,error)\n";
            ret += "    reg <register_name> force <value>           Force register with setting value\n";
            ret += "    reg <register_name> release                 Release register from force value\n";
            ret += "    reg <register_name> <value>                 Write a value into register\n";
            ret += "    reg <register_name>                         Read value of register\n";
            ret += "    reg help                                    Show a direction\n";
        }
        else if (args[1] == "DumpRegisterRW") {
            if (args.size() == 2) {
                ret = (mDumpRegisterRW)? "true" : "false";
            }
            else if (args.size() == 3) {
                if (args[2] == "true") {
                    mDumpRegisterRW = true;
                }
                else if (args[2] == "false") {
                    mDumpRegisterRW = false;
                } else {
                    ret = err_msg + "DumpRegisterRW command needs an argument [true/false]\n";
                }
            } else {
                ret = err_msg + "DumpRegisterRW has too much arguments\n";
            }
        }
        else if (args[1] == "MessageLevel") {
            // read mode
            if (args.size() == 2) {
                std::map<std::string, bool>::iterator it;
                for (it = mMessageLevel.begin(); it != mMessageLevel.end(); it++) {
                    if ( it->second == true ) {
                        ret += " " + it->first;
                    }
                }
            // write mode
            } else if (args.size() == 3) {
                std::vector<std::string> arg_vec = Str2Vec(args[2], '|');
                std::map<std::string, bool>::iterator msgit;
                for (msgit =mMessageLevel.begin(); msgit != mMessageLevel.end(); msgit++) {
                    msgit->second = false;
                }
                std::vector<std::string>::iterator it;
                for (it = arg_vec.begin(); it != arg_vec.end(); it++) {
                    mMessageLevel[*it] = true;
                }
            } else {
                ret = err_msg + "MessageLevel has too much arguments\n";
            }
        } else {
            bool matched = false;
            for (uint i = 0; i < mTotalRegNum; i++) {
                if (args[1] == mRegArray[i]->my_p->name()) {
                    ret = AccessRegCommand(args, mRegArray[i]->my_p, mRegArray[i]->block);
                    matched = true;
                    break;
                }
            }
            if (!matched) {
                ret = err_msg + "Register name " + (std::string)args[1] + " is invalid\n";
            }
        }
    }
    return ret;
}

/// process reg_handle_command of "reg" parameter
/// @return string
std::string Crhsb_xbar_regif::AccessRegCommand(const std::vector<std::string>& args, vpcl::re_register *Register, bool &BlockReg)
{
    std::string ret = "";
    char *err_p = NULL;
    std::string err_msg = "Error ("   + mInstName + ") ";   // error message
    uint data = 0;
    std::ostringstream str_tmp;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(Register != NULL);
    #else
    sc_assert(Register != NULL);
    #endif
    if (args.size() == 2) {
        data = (uint)(*Register);
        str_tmp<<std::setw(14)<<std::left<<(Register->name());
        str_tmp<<"0x"<<std::setw(8)<<std::hex<<std::uppercase<<std::left<<data<<"\n";
        ret = str_tmp.str();
    } else if ((args.size() == 3) && (args[2] == "release")) {
        BlockReg = false;
    } else if ((args.size() == 4) && (args[2] == "force")) {
        errno = 0; data = (uint) strtoul(args[3].c_str(), &err_p, 0);
        #ifdef REGIF_NOT_USE_SYSTEMC
        assert(err_p != NULL);
        #else
        sc_assert(err_p != NULL);
        #endif
        if (errno != ERANGE && *err_p == '\0') {
            *Register = data;
            BlockReg = true;
            UpdateLocalVal(Register->addr());
        } else {
            ret = err_msg + "[" + Register->name() + "] Invalid force value\n";
        }
    } else if ((args.size() >= 3) && (args[2] == "MessageLevel")) {
        if (args.size() == 3) {
            ret = Register->name() + " ";
            ret += Register->GetMessageLevel();
        } else if (args.size() == 4) {
            std::map<std::string, bool> MessageLevel;
            std::vector<std::string> arg_vec = Str2Vec(args[3], '|');
            std::vector<std::string>::iterator it;
            for (it = arg_vec.begin(); it != arg_vec.end(); it++) {
                MessageLevel[*it] = true;
            }
            Register->SetMessageLevel(MessageLevel);
        } else {
            ret = err_msg + "[" + Register->name() + "] MessageLevel has too much arguments\n";
        }
    } else if ((args.size() == 3) && (args[2] != "release")) {
        errno = 0; data = (uint) strtoul(args[2].c_str(), &err_p, 0);
        if (errno != ERANGE && *err_p == '\0') {
            *Register = data;
            UpdateLocalVal(Register->addr());
        } else {
            ret = err_msg + "[" + Register->name() + "] Invalid write value\n";
        }
    } else {
        ret = err_msg + "Wrong command : ";
        for (uint index = 0; index < args.size(); index ++) {
            ret += args[index] + " ";
        }
    }
    return ret;
}

/// Initialize local variables
/// @return none
void Crhsb_xbar_regif::InitLocalVal()
{
    // Initialize local variables
    RHSBGCR0H_MMD015 = 0x0;
    RHSBGCR0H_MMD014 = 0x0;
    RHSBGCR0H_MMD013 = 0x0;
    RHSBGCR0H_MMD012 = 0x0;
    RHSBGCR0H_MMD011 = 0x0;
    RHSBGCR0H_MMD010 = 0x0;
    RHSBGCR0H_MMD09 = 0x0;
    RHSBGCR0H_MMD08 = 0x0;
    RHSBGCR0L_MMD07 = 0x0;
    RHSBGCR0L_MMD06 = 0x0;
    RHSBGCR0L_MMD05 = 0x0;
    RHSBGCR0L_MMD04 = 0x0;
    RHSBGCR0L_MMD03 = 0x0;
    RHSBGCR0L_MMD02 = 0x0;
    RHSBGCR0L_MMD01 = 0x0;
    RHSBGCR0L_MMD00 = 0x0;
    RHSBGCRO0_MMDO015 = 0x0;
    RHSBGCRO0_MMDO014 = 0x0;
    RHSBGCRO0_MMDO013 = 0x0;
    RHSBGCRO0_MMDO012 = 0x0;
    RHSBGCRO0_MMDO011 = 0x0;
    RHSBGCRO0_MMDO010 = 0x0;
    RHSBGCRO0_MMDO09 = 0x0;
    RHSBGCRO0_MMDO08 = 0x0;
    RHSBGCRO0_MMDO07 = 0x0;
    RHSBGCRO0_MMDO06 = 0x0;
    RHSBGCRO0_MMDO05 = 0x0;
    RHSBGCRO0_MMDO04 = 0x0;
    RHSBGCRO0_MMDO03 = 0x0;
    RHSBGCRO0_MMDO02 = 0x0;
    RHSBGCRO0_MMDO01 = 0x0;
    RHSBGCRO0_MMDO00 = 0x0;
    RHSBGCR1H_MMD115 = 0x0;
    RHSBGCR1H_MMD114 = 0x0;
    RHSBGCR1H_MMD113 = 0x0;
    RHSBGCR1H_MMD112 = 0x0;
    RHSBGCR1H_MMD111 = 0x0;
    RHSBGCR1H_MMD110 = 0x0;
    RHSBGCR1H_MMD19 = 0x0;
    RHSBGCR1H_MMD18 = 0x0;
    RHSBGCR1L_MMD17 = 0x0;
    RHSBGCR1L_MMD16 = 0x0;
    RHSBGCR1L_MMD15 = 0x0;
    RHSBGCR1L_MMD14 = 0x0;
    RHSBGCR1L_MMD13 = 0x0;
    RHSBGCR1L_MMD12 = 0x0;
    RHSBGCR1L_MMD11 = 0x0;
    RHSBGCR1L_MMD10 = 0x0;
    RHSBGCRO1_MMDO115 = 0x0;
    RHSBGCRO1_MMDO114 = 0x0;
    RHSBGCRO1_MMDO113 = 0x0;
    RHSBGCRO1_MMDO112 = 0x0;
    RHSBGCRO1_MMDO111 = 0x0;
    RHSBGCRO1_MMDO110 = 0x0;
    RHSBGCRO1_MMDO19 = 0x0;
    RHSBGCRO1_MMDO18 = 0x0;
    RHSBGCRO1_MMDO17 = 0x0;
    RHSBGCRO1_MMDO16 = 0x0;
    RHSBGCRO1_MMDO15 = 0x0;
    RHSBGCRO1_MMDO14 = 0x0;
    RHSBGCRO1_MMDO13 = 0x0;
    RHSBGCRO1_MMDO12 = 0x0;
    RHSBGCRO1_MMDO11 = 0x0;
    RHSBGCRO1_MMDO10 = 0x0;
    RHSBGCR2H_MMD215 = 0x0;
    RHSBGCR2H_MMD214 = 0x0;
    RHSBGCR2H_MMD213 = 0x0;
    RHSBGCR2H_MMD212 = 0x0;
    RHSBGCR2H_MMD211 = 0x0;
    RHSBGCR2H_MMD210 = 0x0;
    RHSBGCR2H_MMD29 = 0x0;
    RHSBGCR2H_MMD28 = 0x0;
    RHSBGCR2L_MMD27 = 0x0;
    RHSBGCR2L_MMD26 = 0x0;
    RHSBGCR2L_MMD25 = 0x0;
    RHSBGCR2L_MMD24 = 0x0;
    RHSBGCR2L_MMD23 = 0x0;
    RHSBGCR2L_MMD22 = 0x0;
    RHSBGCR2L_MMD21 = 0x0;
    RHSBGCR2L_MMD20 = 0x0;
    RHSBGCRO2_MMDO215 = 0x0;
    RHSBGCRO2_MMDO214 = 0x0;
    RHSBGCRO2_MMDO213 = 0x0;
    RHSBGCRO2_MMDO212 = 0x0;
    RHSBGCRO2_MMDO211 = 0x0;
    RHSBGCRO2_MMDO210 = 0x0;
    RHSBGCRO2_MMDO29 = 0x0;
    RHSBGCRO2_MMDO28 = 0x0;
    RHSBGCRO2_MMDO27 = 0x0;
    RHSBGCRO2_MMDO26 = 0x0;
    RHSBGCRO2_MMDO25 = 0x0;
    RHSBGCRO2_MMDO24 = 0x0;
    RHSBGCRO2_MMDO23 = 0x0;
    RHSBGCRO2_MMDO22 = 0x0;
    RHSBGCRO2_MMDO21 = 0x0;
    RHSBGCRO2_MMDO20 = 0x0;
    RHSBGCR3H_MMD315 = 0x0;
    RHSBGCR3H_MMD314 = 0x0;
    RHSBGCR3H_MMD313 = 0x0;
    RHSBGCR3H_MMD312 = 0x0;
    RHSBGCR3H_MMD311 = 0x0;
    RHSBGCR3H_MMD310 = 0x0;
    RHSBGCR3H_MMD39 = 0x0;
    RHSBGCR3H_MMD38 = 0x0;
    RHSBGCR3L_MMD37 = 0x0;
    RHSBGCR3L_MMD36 = 0x0;
    RHSBGCR3L_MMD35 = 0x0;
    RHSBGCR3L_MMD34 = 0x0;
    RHSBGCR3L_MMD33 = 0x0;
    RHSBGCR3L_MMD32 = 0x0;
    RHSBGCR3L_MMD31 = 0x0;
    RHSBGCR3L_MMD30 = 0x0;
    RHSBGCRO3_MMDO315 = 0x0;
    RHSBGCRO3_MMDO314 = 0x0;
    RHSBGCRO3_MMDO313 = 0x0;
    RHSBGCRO3_MMDO312 = 0x0;
    RHSBGCRO3_MMDO311 = 0x0;
    RHSBGCRO3_MMDO310 = 0x0;
    RHSBGCRO3_MMDO39 = 0x0;
    RHSBGCRO3_MMDO38 = 0x0;
    RHSBGCRO3_MMDO37 = 0x0;
    RHSBGCRO3_MMDO36 = 0x0;
    RHSBGCRO3_MMDO35 = 0x0;
    RHSBGCRO3_MMDO34 = 0x0;
    RHSBGCRO3_MMDO33 = 0x0;
    RHSBGCRO3_MMDO32 = 0x0;
    RHSBGCRO3_MMDO31 = 0x0;
    RHSBGCRO3_MMDO30 = 0x0;
}

/// Update bit value to local value
/// @return None
void Crhsb_xbar_regif::UpdateLocalVal(cuint addr)
{
    if (addr == 0x0000) {
        RHSBGCR0H_MMD015              = (*RHSBGCR0H)["MMD015"   ];
        RHSBGCR0H_MMD014              = (*RHSBGCR0H)["MMD014"   ];
        RHSBGCR0H_MMD013              = (*RHSBGCR0H)["MMD013"   ];
        RHSBGCR0H_MMD012              = (*RHSBGCR0H)["MMD012"   ];
        RHSBGCR0H_MMD011              = (*RHSBGCR0H)["MMD011"   ];
        RHSBGCR0H_MMD010              = (*RHSBGCR0H)["MMD010"   ];
        RHSBGCR0H_MMD09               = (*RHSBGCR0H)["MMD09"    ];
        RHSBGCR0H_MMD08               = (*RHSBGCR0H)["MMD08"    ];
        return;
    }
    if (addr == 0x0004) {
        RHSBGCR0L_MMD07               = (*RHSBGCR0L)["MMD07"    ];
        RHSBGCR0L_MMD06               = (*RHSBGCR0L)["MMD06"    ];
        RHSBGCR0L_MMD05               = (*RHSBGCR0L)["MMD05"    ];
        RHSBGCR0L_MMD04               = (*RHSBGCR0L)["MMD04"    ];
        RHSBGCR0L_MMD03               = (*RHSBGCR0L)["MMD03"    ];
        RHSBGCR0L_MMD02               = (*RHSBGCR0L)["MMD02"    ];
        RHSBGCR0L_MMD01               = (*RHSBGCR0L)["MMD01"    ];
        RHSBGCR0L_MMD00               = (*RHSBGCR0L)["MMD00"    ];
        return;
    }
    if (addr == 0x0020) {
        RHSBGCRO0_MMDO015             = (*RHSBGCRO0)["MMDO015"  ];
        RHSBGCRO0_MMDO014             = (*RHSBGCRO0)["MMDO014"  ];
        RHSBGCRO0_MMDO013             = (*RHSBGCRO0)["MMDO013"  ];
        RHSBGCRO0_MMDO012             = (*RHSBGCRO0)["MMDO012"  ];
        RHSBGCRO0_MMDO011             = (*RHSBGCRO0)["MMDO011"  ];
        RHSBGCRO0_MMDO010             = (*RHSBGCRO0)["MMDO010"  ];
        RHSBGCRO0_MMDO09              = (*RHSBGCRO0)["MMDO09"   ];
        RHSBGCRO0_MMDO08              = (*RHSBGCRO0)["MMDO08"   ];
        RHSBGCRO0_MMDO07              = (*RHSBGCRO0)["MMDO07"   ];
        RHSBGCRO0_MMDO06              = (*RHSBGCRO0)["MMDO06"   ];
        RHSBGCRO0_MMDO05              = (*RHSBGCRO0)["MMDO05"   ];
        RHSBGCRO0_MMDO04              = (*RHSBGCRO0)["MMDO04"   ];
        RHSBGCRO0_MMDO03              = (*RHSBGCRO0)["MMDO03"   ];
        RHSBGCRO0_MMDO02              = (*RHSBGCRO0)["MMDO02"   ];
        RHSBGCRO0_MMDO01              = (*RHSBGCRO0)["MMDO01"   ];
        RHSBGCRO0_MMDO00              = (*RHSBGCRO0)["MMDO00"   ];
        return;
    }
    if (addr == 0x0008) {
        RHSBGCR1H_MMD115              = (*RHSBGCR1H)["MMD115"   ];
        RHSBGCR1H_MMD114              = (*RHSBGCR1H)["MMD114"   ];
        RHSBGCR1H_MMD113              = (*RHSBGCR1H)["MMD113"   ];
        RHSBGCR1H_MMD112              = (*RHSBGCR1H)["MMD112"   ];
        RHSBGCR1H_MMD111              = (*RHSBGCR1H)["MMD111"   ];
        RHSBGCR1H_MMD110              = (*RHSBGCR1H)["MMD110"   ];
        RHSBGCR1H_MMD19               = (*RHSBGCR1H)["MMD19"    ];
        RHSBGCR1H_MMD18               = (*RHSBGCR1H)["MMD18"    ];
        return;
    }
    if (addr == 0x000C) {
        RHSBGCR1L_MMD17               = (*RHSBGCR1L)["MMD17"    ];
        RHSBGCR1L_MMD16               = (*RHSBGCR1L)["MMD16"    ];
        RHSBGCR1L_MMD15               = (*RHSBGCR1L)["MMD15"    ];
        RHSBGCR1L_MMD14               = (*RHSBGCR1L)["MMD14"    ];
        RHSBGCR1L_MMD13               = (*RHSBGCR1L)["MMD13"    ];
        RHSBGCR1L_MMD12               = (*RHSBGCR1L)["MMD12"    ];
        RHSBGCR1L_MMD11               = (*RHSBGCR1L)["MMD11"    ];
        RHSBGCR1L_MMD10               = (*RHSBGCR1L)["MMD10"    ];
        return;
    }
    if (addr == 0x0024) {
        RHSBGCRO1_MMDO115             = (*RHSBGCRO1)["MMDO115"  ];
        RHSBGCRO1_MMDO114             = (*RHSBGCRO1)["MMDO114"  ];
        RHSBGCRO1_MMDO113             = (*RHSBGCRO1)["MMDO113"  ];
        RHSBGCRO1_MMDO112             = (*RHSBGCRO1)["MMDO112"  ];
        RHSBGCRO1_MMDO111             = (*RHSBGCRO1)["MMDO111"  ];
        RHSBGCRO1_MMDO110             = (*RHSBGCRO1)["MMDO110"  ];
        RHSBGCRO1_MMDO19              = (*RHSBGCRO1)["MMDO19"   ];
        RHSBGCRO1_MMDO18              = (*RHSBGCRO1)["MMDO18"   ];
        RHSBGCRO1_MMDO17              = (*RHSBGCRO1)["MMDO17"   ];
        RHSBGCRO1_MMDO16              = (*RHSBGCRO1)["MMDO16"   ];
        RHSBGCRO1_MMDO15              = (*RHSBGCRO1)["MMDO15"   ];
        RHSBGCRO1_MMDO14              = (*RHSBGCRO1)["MMDO14"   ];
        RHSBGCRO1_MMDO13              = (*RHSBGCRO1)["MMDO13"   ];
        RHSBGCRO1_MMDO12              = (*RHSBGCRO1)["MMDO12"   ];
        RHSBGCRO1_MMDO11              = (*RHSBGCRO1)["MMDO11"   ];
        RHSBGCRO1_MMDO10              = (*RHSBGCRO1)["MMDO10"   ];
        return;
    }
    if (addr == 0x0010) {
        RHSBGCR2H_MMD215              = (*RHSBGCR2H)["MMD215"   ];
        RHSBGCR2H_MMD214              = (*RHSBGCR2H)["MMD214"   ];
        RHSBGCR2H_MMD213              = (*RHSBGCR2H)["MMD213"   ];
        RHSBGCR2H_MMD212              = (*RHSBGCR2H)["MMD212"   ];
        RHSBGCR2H_MMD211              = (*RHSBGCR2H)["MMD211"   ];
        RHSBGCR2H_MMD210              = (*RHSBGCR2H)["MMD210"   ];
        RHSBGCR2H_MMD29               = (*RHSBGCR2H)["MMD29"    ];
        RHSBGCR2H_MMD28               = (*RHSBGCR2H)["MMD28"    ];
        return;
    }
    if (addr == 0x0014) {
        RHSBGCR2L_MMD27               = (*RHSBGCR2L)["MMD27"    ];
        RHSBGCR2L_MMD26               = (*RHSBGCR2L)["MMD26"    ];
        RHSBGCR2L_MMD25               = (*RHSBGCR2L)["MMD25"    ];
        RHSBGCR2L_MMD24               = (*RHSBGCR2L)["MMD24"    ];
        RHSBGCR2L_MMD23               = (*RHSBGCR2L)["MMD23"    ];
        RHSBGCR2L_MMD22               = (*RHSBGCR2L)["MMD22"    ];
        RHSBGCR2L_MMD21               = (*RHSBGCR2L)["MMD21"    ];
        RHSBGCR2L_MMD20               = (*RHSBGCR2L)["MMD20"    ];
        return;
    }
    if (addr == 0x0028) {
        RHSBGCRO2_MMDO215             = (*RHSBGCRO2)["MMDO215"  ];
        RHSBGCRO2_MMDO214             = (*RHSBGCRO2)["MMDO214"  ];
        RHSBGCRO2_MMDO213             = (*RHSBGCRO2)["MMDO213"  ];
        RHSBGCRO2_MMDO212             = (*RHSBGCRO2)["MMDO212"  ];
        RHSBGCRO2_MMDO211             = (*RHSBGCRO2)["MMDO211"  ];
        RHSBGCRO2_MMDO210             = (*RHSBGCRO2)["MMDO210"  ];
        RHSBGCRO2_MMDO29              = (*RHSBGCRO2)["MMDO29"   ];
        RHSBGCRO2_MMDO28              = (*RHSBGCRO2)["MMDO28"   ];
        RHSBGCRO2_MMDO27              = (*RHSBGCRO2)["MMDO27"   ];
        RHSBGCRO2_MMDO26              = (*RHSBGCRO2)["MMDO26"   ];
        RHSBGCRO2_MMDO25              = (*RHSBGCRO2)["MMDO25"   ];
        RHSBGCRO2_MMDO24              = (*RHSBGCRO2)["MMDO24"   ];
        RHSBGCRO2_MMDO23              = (*RHSBGCRO2)["MMDO23"   ];
        RHSBGCRO2_MMDO22              = (*RHSBGCRO2)["MMDO22"   ];
        RHSBGCRO2_MMDO21              = (*RHSBGCRO2)["MMDO21"   ];
        RHSBGCRO2_MMDO20              = (*RHSBGCRO2)["MMDO20"   ];
        return;
    }
    if (addr == 0x0018) {
        RHSBGCR3H_MMD315              = (*RHSBGCR3H)["MMD315"   ];
        RHSBGCR3H_MMD314              = (*RHSBGCR3H)["MMD314"   ];
        RHSBGCR3H_MMD313              = (*RHSBGCR3H)["MMD313"   ];
        RHSBGCR3H_MMD312              = (*RHSBGCR3H)["MMD312"   ];
        RHSBGCR3H_MMD311              = (*RHSBGCR3H)["MMD311"   ];
        RHSBGCR3H_MMD310              = (*RHSBGCR3H)["MMD310"   ];
        RHSBGCR3H_MMD39               = (*RHSBGCR3H)["MMD39"    ];
        RHSBGCR3H_MMD38               = (*RHSBGCR3H)["MMD38"    ];
        return;
    }
    if (addr == 0x001C) {
        RHSBGCR3L_MMD37               = (*RHSBGCR3L)["MMD37"    ];
        RHSBGCR3L_MMD36               = (*RHSBGCR3L)["MMD36"    ];
        RHSBGCR3L_MMD35               = (*RHSBGCR3L)["MMD35"    ];
        RHSBGCR3L_MMD34               = (*RHSBGCR3L)["MMD34"    ];
        RHSBGCR3L_MMD33               = (*RHSBGCR3L)["MMD33"    ];
        RHSBGCR3L_MMD32               = (*RHSBGCR3L)["MMD32"    ];
        RHSBGCR3L_MMD31               = (*RHSBGCR3L)["MMD31"    ];
        RHSBGCR3L_MMD30               = (*RHSBGCR3L)["MMD30"    ];
        return;
    }
    if (addr == 0x002C) {
        RHSBGCRO3_MMDO315             = (*RHSBGCRO3)["MMDO315"  ];
        RHSBGCRO3_MMDO314             = (*RHSBGCRO3)["MMDO314"  ];
        RHSBGCRO3_MMDO313             = (*RHSBGCRO3)["MMDO313"  ];
        RHSBGCRO3_MMDO312             = (*RHSBGCRO3)["MMDO312"  ];
        RHSBGCRO3_MMDO311             = (*RHSBGCRO3)["MMDO311"  ];
        RHSBGCRO3_MMDO310             = (*RHSBGCRO3)["MMDO310"  ];
        RHSBGCRO3_MMDO39              = (*RHSBGCRO3)["MMDO39"   ];
        RHSBGCRO3_MMDO38              = (*RHSBGCRO3)["MMDO38"   ];
        RHSBGCRO3_MMDO37              = (*RHSBGCRO3)["MMDO37"   ];
        RHSBGCRO3_MMDO36              = (*RHSBGCRO3)["MMDO36"   ];
        RHSBGCRO3_MMDO35              = (*RHSBGCRO3)["MMDO35"   ];
        RHSBGCRO3_MMDO34              = (*RHSBGCRO3)["MMDO34"   ];
        RHSBGCRO3_MMDO33              = (*RHSBGCRO3)["MMDO33"   ];
        RHSBGCRO3_MMDO32              = (*RHSBGCRO3)["MMDO32"   ];
        RHSBGCRO3_MMDO31              = (*RHSBGCRO3)["MMDO31"   ];
        RHSBGCRO3_MMDO30              = (*RHSBGCRO3)["MMDO30"   ];
        return;
    }
}

/// Update local value to bit value
/// @return None
void Crhsb_xbar_regif::UpdateRegVal(cuint addr)
{
    if (addr == 0x0000) {
        (*RHSBGCR0H)["MMD015"   ] = RHSBGCR0H_MMD015;
        (*RHSBGCR0H)["MMD014"   ] = RHSBGCR0H_MMD014;
        (*RHSBGCR0H)["MMD013"   ] = RHSBGCR0H_MMD013;
        (*RHSBGCR0H)["MMD012"   ] = RHSBGCR0H_MMD012;
        (*RHSBGCR0H)["MMD011"   ] = RHSBGCR0H_MMD011;
        (*RHSBGCR0H)["MMD010"   ] = RHSBGCR0H_MMD010;
        (*RHSBGCR0H)["MMD09"    ] = RHSBGCR0H_MMD09;
        (*RHSBGCR0H)["MMD08"    ] = RHSBGCR0H_MMD08;
        return;
    }
    if (addr == 0x0004) {
        (*RHSBGCR0L)["MMD07"    ] = RHSBGCR0L_MMD07;
        (*RHSBGCR0L)["MMD06"    ] = RHSBGCR0L_MMD06;
        (*RHSBGCR0L)["MMD05"    ] = RHSBGCR0L_MMD05;
        (*RHSBGCR0L)["MMD04"    ] = RHSBGCR0L_MMD04;
        (*RHSBGCR0L)["MMD03"    ] = RHSBGCR0L_MMD03;
        (*RHSBGCR0L)["MMD02"    ] = RHSBGCR0L_MMD02;
        (*RHSBGCR0L)["MMD01"    ] = RHSBGCR0L_MMD01;
        (*RHSBGCR0L)["MMD00"    ] = RHSBGCR0L_MMD00;
        return;
    }
    if (addr == 0x0020) {
        (*RHSBGCRO0)["MMDO015"  ] = RHSBGCRO0_MMDO015;
        (*RHSBGCRO0)["MMDO014"  ] = RHSBGCRO0_MMDO014;
        (*RHSBGCRO0)["MMDO013"  ] = RHSBGCRO0_MMDO013;
        (*RHSBGCRO0)["MMDO012"  ] = RHSBGCRO0_MMDO012;
        (*RHSBGCRO0)["MMDO011"  ] = RHSBGCRO0_MMDO011;
        (*RHSBGCRO0)["MMDO010"  ] = RHSBGCRO0_MMDO010;
        (*RHSBGCRO0)["MMDO09"   ] = RHSBGCRO0_MMDO09;
        (*RHSBGCRO0)["MMDO08"   ] = RHSBGCRO0_MMDO08;
        (*RHSBGCRO0)["MMDO07"   ] = RHSBGCRO0_MMDO07;
        (*RHSBGCRO0)["MMDO06"   ] = RHSBGCRO0_MMDO06;
        (*RHSBGCRO0)["MMDO05"   ] = RHSBGCRO0_MMDO05;
        (*RHSBGCRO0)["MMDO04"   ] = RHSBGCRO0_MMDO04;
        (*RHSBGCRO0)["MMDO03"   ] = RHSBGCRO0_MMDO03;
        (*RHSBGCRO0)["MMDO02"   ] = RHSBGCRO0_MMDO02;
        (*RHSBGCRO0)["MMDO01"   ] = RHSBGCRO0_MMDO01;
        (*RHSBGCRO0)["MMDO00"   ] = RHSBGCRO0_MMDO00;
        return;
    }
    if (addr == 0x0008) {
        (*RHSBGCR1H)["MMD115"   ] = RHSBGCR1H_MMD115;
        (*RHSBGCR1H)["MMD114"   ] = RHSBGCR1H_MMD114;
        (*RHSBGCR1H)["MMD113"   ] = RHSBGCR1H_MMD113;
        (*RHSBGCR1H)["MMD112"   ] = RHSBGCR1H_MMD112;
        (*RHSBGCR1H)["MMD111"   ] = RHSBGCR1H_MMD111;
        (*RHSBGCR1H)["MMD110"   ] = RHSBGCR1H_MMD110;
        (*RHSBGCR1H)["MMD19"    ] = RHSBGCR1H_MMD19;
        (*RHSBGCR1H)["MMD18"    ] = RHSBGCR1H_MMD18;
        return;
    }
    if (addr == 0x000C) {
        (*RHSBGCR1L)["MMD17"    ] = RHSBGCR1L_MMD17;
        (*RHSBGCR1L)["MMD16"    ] = RHSBGCR1L_MMD16;
        (*RHSBGCR1L)["MMD15"    ] = RHSBGCR1L_MMD15;
        (*RHSBGCR1L)["MMD14"    ] = RHSBGCR1L_MMD14;
        (*RHSBGCR1L)["MMD13"    ] = RHSBGCR1L_MMD13;
        (*RHSBGCR1L)["MMD12"    ] = RHSBGCR1L_MMD12;
        (*RHSBGCR1L)["MMD11"    ] = RHSBGCR1L_MMD11;
        (*RHSBGCR1L)["MMD10"    ] = RHSBGCR1L_MMD10;
        return;
    }
    if (addr == 0x0024) {
        (*RHSBGCRO1)["MMDO115"  ] = RHSBGCRO1_MMDO115;
        (*RHSBGCRO1)["MMDO114"  ] = RHSBGCRO1_MMDO114;
        (*RHSBGCRO1)["MMDO113"  ] = RHSBGCRO1_MMDO113;
        (*RHSBGCRO1)["MMDO112"  ] = RHSBGCRO1_MMDO112;
        (*RHSBGCRO1)["MMDO111"  ] = RHSBGCRO1_MMDO111;
        (*RHSBGCRO1)["MMDO110"  ] = RHSBGCRO1_MMDO110;
        (*RHSBGCRO1)["MMDO19"   ] = RHSBGCRO1_MMDO19;
        (*RHSBGCRO1)["MMDO18"   ] = RHSBGCRO1_MMDO18;
        (*RHSBGCRO1)["MMDO17"   ] = RHSBGCRO1_MMDO17;
        (*RHSBGCRO1)["MMDO16"   ] = RHSBGCRO1_MMDO16;
        (*RHSBGCRO1)["MMDO15"   ] = RHSBGCRO1_MMDO15;
        (*RHSBGCRO1)["MMDO14"   ] = RHSBGCRO1_MMDO14;
        (*RHSBGCRO1)["MMDO13"   ] = RHSBGCRO1_MMDO13;
        (*RHSBGCRO1)["MMDO12"   ] = RHSBGCRO1_MMDO12;
        (*RHSBGCRO1)["MMDO11"   ] = RHSBGCRO1_MMDO11;
        (*RHSBGCRO1)["MMDO10"   ] = RHSBGCRO1_MMDO10;
        return;
    }
    if (addr == 0x0010) {
        (*RHSBGCR2H)["MMD215"   ] = RHSBGCR2H_MMD215;
        (*RHSBGCR2H)["MMD214"   ] = RHSBGCR2H_MMD214;
        (*RHSBGCR2H)["MMD213"   ] = RHSBGCR2H_MMD213;
        (*RHSBGCR2H)["MMD212"   ] = RHSBGCR2H_MMD212;
        (*RHSBGCR2H)["MMD211"   ] = RHSBGCR2H_MMD211;
        (*RHSBGCR2H)["MMD210"   ] = RHSBGCR2H_MMD210;
        (*RHSBGCR2H)["MMD29"    ] = RHSBGCR2H_MMD29;
        (*RHSBGCR2H)["MMD28"    ] = RHSBGCR2H_MMD28;
        return;
    }
    if (addr == 0x0014) {
        (*RHSBGCR2L)["MMD27"    ] = RHSBGCR2L_MMD27;
        (*RHSBGCR2L)["MMD26"    ] = RHSBGCR2L_MMD26;
        (*RHSBGCR2L)["MMD25"    ] = RHSBGCR2L_MMD25;
        (*RHSBGCR2L)["MMD24"    ] = RHSBGCR2L_MMD24;
        (*RHSBGCR2L)["MMD23"    ] = RHSBGCR2L_MMD23;
        (*RHSBGCR2L)["MMD22"    ] = RHSBGCR2L_MMD22;
        (*RHSBGCR2L)["MMD21"    ] = RHSBGCR2L_MMD21;
        (*RHSBGCR2L)["MMD20"    ] = RHSBGCR2L_MMD20;
        return;
    }
    if (addr == 0x0028) {
        (*RHSBGCRO2)["MMDO215"  ] = RHSBGCRO2_MMDO215;
        (*RHSBGCRO2)["MMDO214"  ] = RHSBGCRO2_MMDO214;
        (*RHSBGCRO2)["MMDO213"  ] = RHSBGCRO2_MMDO213;
        (*RHSBGCRO2)["MMDO212"  ] = RHSBGCRO2_MMDO212;
        (*RHSBGCRO2)["MMDO211"  ] = RHSBGCRO2_MMDO211;
        (*RHSBGCRO2)["MMDO210"  ] = RHSBGCRO2_MMDO210;
        (*RHSBGCRO2)["MMDO29"   ] = RHSBGCRO2_MMDO29;
        (*RHSBGCRO2)["MMDO28"   ] = RHSBGCRO2_MMDO28;
        (*RHSBGCRO2)["MMDO27"   ] = RHSBGCRO2_MMDO27;
        (*RHSBGCRO2)["MMDO26"   ] = RHSBGCRO2_MMDO26;
        (*RHSBGCRO2)["MMDO25"   ] = RHSBGCRO2_MMDO25;
        (*RHSBGCRO2)["MMDO24"   ] = RHSBGCRO2_MMDO24;
        (*RHSBGCRO2)["MMDO23"   ] = RHSBGCRO2_MMDO23;
        (*RHSBGCRO2)["MMDO22"   ] = RHSBGCRO2_MMDO22;
        (*RHSBGCRO2)["MMDO21"   ] = RHSBGCRO2_MMDO21;
        (*RHSBGCRO2)["MMDO20"   ] = RHSBGCRO2_MMDO20;
        return;
    }
    if (addr == 0x0018) {
        (*RHSBGCR3H)["MMD315"   ] = RHSBGCR3H_MMD315;
        (*RHSBGCR3H)["MMD314"   ] = RHSBGCR3H_MMD314;
        (*RHSBGCR3H)["MMD313"   ] = RHSBGCR3H_MMD313;
        (*RHSBGCR3H)["MMD312"   ] = RHSBGCR3H_MMD312;
        (*RHSBGCR3H)["MMD311"   ] = RHSBGCR3H_MMD311;
        (*RHSBGCR3H)["MMD310"   ] = RHSBGCR3H_MMD310;
        (*RHSBGCR3H)["MMD39"    ] = RHSBGCR3H_MMD39;
        (*RHSBGCR3H)["MMD38"    ] = RHSBGCR3H_MMD38;
        return;
    }
    if (addr == 0x001C) {
        (*RHSBGCR3L)["MMD37"    ] = RHSBGCR3L_MMD37;
        (*RHSBGCR3L)["MMD36"    ] = RHSBGCR3L_MMD36;
        (*RHSBGCR3L)["MMD35"    ] = RHSBGCR3L_MMD35;
        (*RHSBGCR3L)["MMD34"    ] = RHSBGCR3L_MMD34;
        (*RHSBGCR3L)["MMD33"    ] = RHSBGCR3L_MMD33;
        (*RHSBGCR3L)["MMD32"    ] = RHSBGCR3L_MMD32;
        (*RHSBGCR3L)["MMD31"    ] = RHSBGCR3L_MMD31;
        (*RHSBGCR3L)["MMD30"    ] = RHSBGCR3L_MMD30;
        return;
    }
    if (addr == 0x002C) {
        (*RHSBGCRO3)["MMDO315"  ] = RHSBGCRO3_MMDO315;
        (*RHSBGCRO3)["MMDO314"  ] = RHSBGCRO3_MMDO314;
        (*RHSBGCRO3)["MMDO313"  ] = RHSBGCRO3_MMDO313;
        (*RHSBGCRO3)["MMDO312"  ] = RHSBGCRO3_MMDO312;
        (*RHSBGCRO3)["MMDO311"  ] = RHSBGCRO3_MMDO311;
        (*RHSBGCRO3)["MMDO310"  ] = RHSBGCRO3_MMDO310;
        (*RHSBGCRO3)["MMDO39"   ] = RHSBGCRO3_MMDO39;
        (*RHSBGCRO3)["MMDO38"   ] = RHSBGCRO3_MMDO38;
        (*RHSBGCRO3)["MMDO37"   ] = RHSBGCRO3_MMDO37;
        (*RHSBGCRO3)["MMDO36"   ] = RHSBGCRO3_MMDO36;
        (*RHSBGCRO3)["MMDO35"   ] = RHSBGCRO3_MMDO35;
        (*RHSBGCRO3)["MMDO34"   ] = RHSBGCRO3_MMDO34;
        (*RHSBGCRO3)["MMDO33"   ] = RHSBGCRO3_MMDO33;
        (*RHSBGCRO3)["MMDO32"   ] = RHSBGCRO3_MMDO32;
        (*RHSBGCRO3)["MMDO31"   ] = RHSBGCRO3_MMDO31;
        (*RHSBGCRO3)["MMDO30"   ] = RHSBGCRO3_MMDO30;
        return;
    }
}

/// convert string to vector
/// @return vector
std::vector<std::string> Crhsb_xbar_regif::Str2Vec(std::string str, const char sep)
{
    std::vector<std::string> buf;
    std::string::size_type index = 0;
    for (uint i=0 ; i<str.size() ; i++) {
        if (str[i] == sep) {
            buf.push_back(str.substr(index, i-index));
            index = i+1;
        }
    }
    buf.push_back(str.substr(index));
    return buf;
}

/// Align nuber to hexadecimal format
/// @return aligned number
std::string Crhsb_xbar_regif::Num2HexStr(cuint num, cuint num_length, bool space_strip)
{
    std::ostringstream str_tmp;
    #ifdef MSG_WO_WR_DATA
    str_tmp<<"0x"<<std::hex<<std::uppercase<<std::right<<num;
    str_tmp<<std::setfill(' ')<<std::setw(10-str_tmp.str().length())<<"";
    #else
    uint total_length = (num_length + 3)/4; // Calculate number of hexadecimal number
    str_tmp<<"0x"<<std::setfill('0')<<std::setw(total_length)<<std::hex<<std::uppercase<<std::right<<num;
    if (!space_strip) {
        str_tmp<<std::setfill(' ')<<std::setw(10-str_tmp.str().length())<<"";   
    }
    #endif
    return str_tmp.str();
}

/// Dump register access information
/// @return none
void Crhsb_xbar_regif::DumpRegMsg(const std::string operation, const std::string RegName, const std::string BitName, cuint size, cuint addr, cuint wr_data, cuint pre_data, cuint data, cuint reg_length)
{
    if(mDumpRegisterRW == true) {
        std::string reg_name = RegName;
        std::ostringstream str_tmp;
        if (BitName != "") {
            reg_name += ":" + BitName;
        }
        str_tmp<<"REG ["<<std::setw(15)<<std::left<<reg_name<<"] ";
        str_tmp<<operation;
        str_tmp<<" Size= "<<size;
        str_tmp<<" Addr= "<<Num2HexStr(addr,6, false);
        if (operation == "R") {
            str_tmp<<" Data= "<<Num2HexStr(data    , reg_length, true);
        } else {
            #ifdef MSG_WO_WR_DATA
            str_tmp<<" Data= "<<Num2HexStr(pre_data, reg_length, false);
            #else
            str_tmp<<" Data= "<<Num2HexStr(wr_data , reg_length, false);
            str_tmp<<" : "    <<Num2HexStr(pre_data, reg_length, false);
            #endif
            str_tmp<<" => "   <<Num2HexStr(data    , reg_length, true);
        }
        re_printf("DumpRegMsg", "%s\n", str_tmp.str().c_str());
    }
}

/// find register pointer based on accessed address
/// @return accessed register pointer
int Crhsb_xbar_regif::get_reg_index(cuint access_addr)
{
    if (mRegMap[access_addr] != (1<<6)) {
        return mRegMap[access_addr];
    } else {
        return -1;
    }
}

/// find first register pointer
/// @return first register pointer
vpcl::re_register *Crhsb_xbar_regif::first_reg_object()
{
    mCurReg = mRegList;
    return mCurReg->my_p;
}

/// find next register pointer
/// @return next register pointer
vpcl::re_register *Crhsb_xbar_regif::next_reg_object()
{
    if (mCurReg != NULL) {
        mCurReg = mCurReg->prev;
        if (mCurReg != NULL) {
            return mCurReg->my_p;
        }
    }
    return NULL;
}

/// write callback function of CoWare
/// @return none
void Crhsb_xbar_regif::wr_cb(cuint addr, uint data)
{
    #ifdef CWR_SYSTEMC
    cwmem.put(data, addr&0xFFFF);
    #else
    array[addr&0xFFFF] = data;
    #endif
}

/// read callback function of CoWare
/// @return read data
Crhsb_xbar_regif::uint Crhsb_xbar_regif::rd_cb(cuint addr)
{
    #ifdef CWR_SYSTEMC
    return cwmem.get(addr&0xFFFF);
    #else
    return array[addr&0xFFFF];
    #endif
}

/// print message function
/// @return none
void Crhsb_xbar_regif::_re_printf(std::string group, const char *message, ...)
{
    // message group check
    if (group == "DumpRegMsg") {
        group = "info";
    } else {
        #ifndef REGIF_SC_REPORT
        if (mMessageLevel[group] == false) return;
        #endif//REGIF_SC_REPORT
    }

    if (message == NULL) return;

    // print header
    #ifndef REGIF_NOT_USE_SYSTEMC
    std::stringstream t_stream;
    std::string cur_time;

    double tu_value = 0;
    std::string tu_name = "";
    if (sc_get_time_resolution() < sc_time(1, SC_PS)) {
        tu_value = 1000000000000000LL;
        tu_name = " fs";
    }
    else if (sc_get_time_resolution() < sc_time(1, SC_NS)) {
        tu_value = 1000000000000LL;
        tu_name = " ps";
    }
    else if (sc_get_time_resolution() < sc_time(1, SC_US)) {
        tu_value = 1000000000;
        tu_name = " ns";
    }
    else if (sc_get_time_resolution() < sc_time(1, SC_MS)) {
        tu_value = 1000000;
        tu_name = " us";
    }
    else if (sc_get_time_resolution() < sc_time(1, SC_SEC)) {
        tu_value = 1000;
        tu_name = " ms";
    }
    else {
        tu_value = 1;
        tu_name = " s";
    }
    t_stream << sc_time_stamp().value() * (uint64) (sc_get_time_resolution().to_seconds() * tu_value) << tu_name;

    cur_time = t_stream.str();
    #else
    std::string cur_time = "";
    #endif

    #ifndef REGIF_SC_REPORT
    #ifdef MSG_COLOR
    // color setting
    //
    // severity color       color Linux       Windows
    // fatal    RED         RED   \033[0;31m  FOREGROUND_RED
    // error    RED         BLUE  \033[0;34m  FOREGROUND_BLUE
    // warning  RED
    // info     BLUE
    #ifdef _WIN32
    HANDLE hStdout;
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    if (group == "fatal" || group == "error" || group == "warning") {
        SetConsoleTextAttribute(hStdout, FOREGROUND_RED);
    }
    else if (group == "info" ){
        SetConsoleTextAttribute(hStdout, FOREGROUND_BLUE);
    }
    #else
    if (group == "fatal" || group == "error" || group == "warning") {
        printf("\033[0;31m");
    }
    else if (group == "info" ){
        printf("\033[0;34m");
    }
    #endif
    #endif //MSG_COLOR
    printf("%8s [%20s] (%10s) ", group.c_str(), cur_time.c_str(), mInstName.c_str());
    #endif//REGIF_SC_REPORT

    // print body
    va_list argptr;
    va_start(argptr, message);
    if (argptr == NULL) return;
    #ifdef REGIF_SC_REPORT
    char str[1024];
    sprintf(str, "[%20s] ", cur_time.c_str());
    vsprintf(str+23, message, argptr);
    if (group == "fatal") {
        SC_REPORT_FATAL(mInstName.c_str(), str);
    }
    else if (group == "error") {
        SC_REPORT_ERROR(mInstName.c_str(), str);
    }
    else if (group == "warning") {
        SC_REPORT_WARNING(mInstName.c_str(), str);
    }
    else if (group == "info") {
        SC_REPORT_INFO(mInstName.c_str(), str);
    }
    #else //REGIF_SC_REPORT
    vprintf(message, argptr);
    #endif//REGIF_SC_REPORT

    #ifndef REGIF_SC_REPORT
    #ifdef DumpFileNameLineNum
    // print footer
    if (group == "fatal" || group == "error") {
        printf(" [%s:%d]\n", mFileName.c_str(), mLineNum);
    }
    #endif//DumpFileNameLineNum
    #endif//REGIF_SC_REPORT
    va_end(argptr);

    #ifndef REGIF_SC_REPORT
    #ifdef MSG_COLOR
    #ifdef _WIN32
    SetConsoleTextAttribute(hStdout, csbi.wAttributes);
    #else
    printf("\033[m");
    #endif
    #endif //MSG_COLOR
    #endif//REGIF_SC_REPORT

    fflush(stdout);
    fflush(stderr);

    if (group == "fatal") {
        exit(1);
    }
}

/// Get file name and line number
/// @return none
void Crhsb_xbar_regif::get_fileline(std::string filename, int line_number)
{
    mFileName = filename;
    mLineNum  = line_number;
}

/// API for instance registration
/// @return none
void Crhsb_xbar_regif::set_instance_name(std::string InstName)
{
    mInstName = InstName;
}

/// Method to change value of mIsReset
/// @return none
void Crhsb_xbar_regif::EnableReset(const bool is_active)
{
    // update register IF class's reset status
    mIsReset = is_active;

    // update re_register's reset status
    for (uint i = 0; i < mTotalRegNum; i++) {
        mRegArray[i]->my_p->EnableReset(is_active);
        if (is_active) {
            re_printf("info", "Initialize %s (%08x)\n", mRegArray[i]->my_p->name().c_str(), (uint)(*mRegArray[i]->my_p));
        }
    }

    if(is_active) {
        InitLocalVal(); // Initialize local variable
    }
}

#ifdef CWR_SYSTEMC
uint Crhsb_xbar_regif::cw_rd_cb(tlm::tlm_generic_payload& trans, int tag)
{
    unsigned char* ptr = (unsigned char*)trans.get_data_ptr();
    memset(ptr,0,sizeof(uint));
    reg_rd_dbg((cuint)tag, ptr, sizeof(uint));
    return sizeof(uint);
}

uint Crhsb_xbar_regif::cw_wr_cb(tlm::tlm_generic_payload& trans, int tag)
{
    unsigned char* ptr = (unsigned char*)trans.get_data_ptr();
    reg_wr_dbg((cuint)tag, ptr, sizeof(uint));
    return sizeof(uint);
}
void Crhsb_xbar_regif::cw_instantiate_reg(scml2::reg<uint> * reg, std::string reg_name, int offset)
{
    reg = new scml2::reg<uint>(reg_name, cwmem, offset/sizeof(uint));
    scml2::set_debug_write_callback(*reg,SCML2_CALLBACK(cw_wr_cb),offset);
    scml2::set_debug_read_callback(*reg,SCML2_CALLBACK(cw_rd_cb),offset);
}
#endif
