// -----------------------------------------------------------------------------
// $Id$
//
// Copyright(c) 2010-2014 Renesas Electronics Corporation
// Copyright(c) 2010-2014 Renesas Design Vietnam Co., Ltd.
// RENESAS ELECTRONICS CONFIDENTIAL AND PROPRIETARY.
// This program must be used solely for the purpose for which
// it was furnished by Renesas Electronics Corporation. No part of this
// program may be reproduced or disclosed to others, in any
// form, without the prior written permission of Renesas Electronics
// Corporation.
// -----------------------------------------------------------------------------
// This file is generated by Register I/F generator
//    gen_regif.py
//    gen_regif_class.py
//    regif_cpp.skl
//
// Input file : Input/adc_info.txt
////////////////////////////////////////////////////////////////////////////////
// # -----------------------------------------------------------------------------
// # $Id$
// #
// # Copyright(c) 2012-2015 Renesas System Design Co., Ltd.
// # Copyright(c) 2012-2015 Renesas Design Vietnam Co., Ltd.
// # RENESAS ELECTRONICS CONFIDENTIAL AND PROPRIETARY.
// # This program must be used solely for the purpose for which
// # it was furnished by Renesas Electronics Corporation. No part of this
// # program may be reproduced or disclosed to others, in any
// # form, without the prior written permission of Renesas Electronics
// # Corporation.
// # -----------------------------------------------------------------------------
// 
// %MODULE adc
//     #              name     offset_size  
//     %%REG_INSTANCE reg_def  11           
// 
// %REG_CHANNEL   reg_def
//   %%TITLE name         reg_name     wsize     rsize     length  offset  factor_start  factor_end  factor_index  factor_step  init         access  support  callback
// 
//   %%REG   VCR          VCR          8|16|32   8|16|32   32      0x000      0            47            -            0x4        0           W|R      TRUE      -
//   %%REG   DR           DR           8|16|32   8|16|32   32      0x100      0            23            -            0x4        0           R        TRUE      -
//   %%REG   DIR          DIR          8|16|32   8|16|32   32      0x200      0            47            -            0x4        0           R        TRUE      -
//   %%REG   ADHALTR      ADHALTR      8|16|32   8|16|32   8       0x380      -            -             -            -          0           W|R      TRUE      -
//   %%REG   ADCR1        ADCR1        8|16|32   8|16|32   8       0x384      -            -             -            -          0           D        TRUE      -
//   %%REG   MPXCURCR     MPXCURCR     8|16      8|16      8       0x388      -            -             -            -          0           W|R      TRUE      -
//   %%REG   MPXINTER     MPXINTER     8|16      8|16      8       0x38A      -            -             -            -          0           D        TRUE      -
//   %%REG   MPXCURR      MPXCURR      8|16|32   8|16|32   32      0x38C      -            -             -            -          0           R        TRUE      -
//   %%REG   MPXOWR       MPXOWR       8|16|32   8|16|32   8       0x390      -            -             -            -          0           D        TRUE      -
//   %%REG   MPXCMDR      MPXCMDR      8|16|32   8|16|32   8       0x394      -            -             -            -          0           W|R      TRUE      -
//   %%REG   ADCR2        ADCR2        8|16|32   8|16|32   8       0x398      -            -             -            -          0           D        TRUE      -
//   %%REG   DFASENTSGER  DFASENTSGER  8|16|32   8|16|32   16      0x39C      -            -             -            -          0           D        TRUE      -
//   %%REG   ADENDP       ADENDP       8|16|32   8|16|32   8       0x3A0      0            4             -            0x4        0           D        TRUE      -
// 
//   %%REG   THSMPSTCR    THSMPSTCR    8|16|32   8|16|32   8       0x400      -            -             -            -          0           D        TRUE      -
//   %%REG   THSTPCR      THSTPCR      8|16|32   8|16|32   8       0x404      -            -             -            -          0           D        TRUE      -
//   %%REG   THCR         THCR         8|16|32   8|16|32   8       0x408      -            -             -            -          0           D        TRUE      -
//   %%REG   THAHLDSTCR   THAHLDSTCR   8|16|32   8|16|32   8       0x410      -            -             -            -          0           D        TRUE      -
//   %%REG   THBHLDSTCR   THBHLDSTCR   8|16|32   8|16|32   8       0x414      -            -             -            -          0           D        TRUE      -
//   %%REG   THACR        THACR        8|16|32   8|16|32   8       0x420      -            -             -            -          0           D        TRUE      -
//   %%REG   THBCR        THBCR        8|16|32   8|16|32   8       0x424      -            -             -            -          0           D        TRUE      -
//   %%REG   THER         THER         8|16|32   8|16|32   8       0x430      -            -             -            -          0           D        TRUE      -
//   %%REG   THGSR        THGSR        8|16|32   8|16|32   16      0x434      -            -             -            -          0           D        TRUE      -
//   %%REG   THOMSR       THOMSR       32        8|16|32   32      0x440      -            -             -            -          0           D        FALSE     -
// 
//   %%REG   SFTCR        SFTCR        8|16|32   8|16|32   8       0x3C0      -            -             -            -          0           D        TRUE      -
//   %%REG   TDCR         TDCR         8|16|32   8|16|32   8       0x3C4      -            -             -            -          0           D        TRUE      -
//   %%REG   ODCR         ODCR         8|16|32   8|16|32   32      0x3C8      -            -             -            -          0           D        TRUE      -
//   %%REG   ULLMTBR      ULLMTBR      8|16|32   8|16|32   32      0x3CC      0            2             -            0x4        0x7FFE0000  D        TRUE      -
//   %%REG   ECR          ECR          8|16|32   8|16|32   8       0x3D8      -            -             -            -          0           W|R      TRUE      -
//   %%REG   ULER         ULER         8|16|32   8|16|32   8       0x3DC      -            -             -            -          0           D        TRUE      -
//   %%REG   OWER         OWER         8|16|32   8|16|32   8       0x3E0      -            -             -            -          0           R        TRUE      -
//   %%REG   PER          PER          8|16|32   8|16|32   8       0x3E4      -            -             -            -          0           R        TRUE      -
//   %%REG   IDER         IDER         8|16|32   8|16|32   8       0x3E8      -            -             -            -          0           R        TRUE      -
//   %%REG   SYNCER       SYNCER       8|16|32   8|16|32   8       0x3EC      -            -             -            -          0           R        FALSE     -
// 
//   %%REG   SMPCR        SMPCR        8|16|32   8|16|32   16      0x340      -            -             -            -          0           D        TRUE      - 
//   %%REG   TRMCR        TRMCR        8|16|32   8|16|32   16      0x360      -            -             -            -          0           W|R      FALSE     - 
//   %%REG   ADTSTRA      ADTSTRA      8|16|32   8|16|32   16      0x364      -            -             -            -          0           W|R      FALSE     - 
//   %%REG   ADTSTRB      ADTSTRB      8|16|32   8|16|32   16      0x368      -            -             -            -          0           W|R      FALSE     - 
//   %%REG   ADTSTRC      ADTSTRC      8|16|32   8|16|32   16      0x36C      -            -             -            -          0           W|R      FALSE     - 
// 
//   %%REG   SGSTCR       SGSTCR       8|16|32   8|16|32   8       0x480      0            4             -           0x80        0           W|R      TRUE      -
//   %%REG   SGSTPCR      SGSTPCR      8|16|32   8|16|32   8       0x484      0            4             -           0x80        0           D        TRUE      -
//   %%REG   ADTSTCR      ADTSTCR      8|16|32   8|16|32   8       0x608      3            4             -           0x80        0           W|R      TRUE      -
//   %%REG   ADTENDCR     ADTENDCR     8|16|32   8|16|32   8       0x60C      3            4             -           0x80        0           W|R      TRUE      -
//   %%REG   SGCR         SGCR         8|16|32   8|16|32   8       0x490      0            4             -           0x80        0           W|R      TRUE      -
//   %%REG   SGVCSP       SGVCSP       8|16|32   8|16|32   8       0x494      0            4             -           0x80        0           W|R      TRUE      -
//   %%REG   SGVCEP       SGVCEP       8|16|32   8|16|32   8       0x498      0            4             -           0x80        0           W|R      TRUE      -
//   %%REG   SGMCYCR      SGMCYCR      8|16|32   8|16|32   8       0x49C      0            4             -           0x80        0           W|R      TRUE      -
//   %%REG   SGVCPR       SGVCPR       8|16      8|16      16      0x4A0      0            4             -           0x80        0           D        TRUE      -
//   %%REG   SGVCOWR      SGVCOWR      8|16      8|16      16      0x4B4      0            4             -           0x80        0           D        TRUE      -
//   %%REG   SGSR         SGSR         8|16|32   8|16|32   8       0x4A4      0            4             -           0x80        0           R        TRUE      -
//   %%REG   ADTIPR       ADTIPR       8|16|32   8|16|32   32      0x628      3            4             -           0x80        0           W|R      TRUE      -
//   %%REG   ADTPRR       ADTPRR       8|16|32   8|16|32   32      0x62C      3            4             -           0x80        0x001FFFFF  W|R      TRUE      -
//   %%REG   ULLMSR       ULLMSR       8|16|32   8|16|32   8       0x4B0      0            4             -           0x80        0           D        TRUE      -
//   %%REG   VCULLMTBR    VCULLMTBR    32        8|16|32   32      0x700      0            6             -            0x4        0           D        TRUE      -
//   %%REG   VCLMINTER1   VCLMINTER1   8|16|32   8|16|32   32      0x730      -            -             -            -          0           D        TRUE      -
//   %%REG   VCLMINTER2   VCLMINTER2   8|16|32   8|16|32   32      0x734      -            -             -            -          0           D        TRUE      -
//   %%REG   VCLMSR1      VCLMSR1      8|16|32   8|16|32   32      0x738      -            -             -            -          0           D        TRUE      -
//   %%REG   VCLMSR2      VCLMSR2      8|16|32   8|16|32   32      0x73C      -            -             -            -          0           D        TRUE      -
//   %%REG   VCLMSCR1     VCLMSCR1     8|16|32   8|16|32   32      0x740      -            -             -            -          0           D        TRUE      -
//   %%REG   VCLMSCR2     VCLMSCR2     8|16|32   8|16|32   32      0x744      -            -             -            -          0           D        TRUE      -
//   %%REG   ADOPDIG      ADOPDIG      8|16|32   8|16|32   32      0x748      -            -             -            -          0           W|R      TRUE      -
// 
// %REG_NAME  VCR
//    %%TITLE     name       upper   lower     init    access      support     callback    value    
//    %%BIT       VCULME     31      31        0       W|R          -            -           -
//    %%BIT       VCLLME     30      30        0       W|R          -            -           -
//    %%BIT       VCULLMTBS  26      24        0       W|R          -            -           -
//    %%BIT       PUE        17      17        0       W|R          -            -           -
//    %%BIT       PDE        16      16        0       W|R          -            -           -  
//    %%BIT       CNVCLS     15      13        0       W|R          -            -           "b000,b001,b011,b100,b101,b110"
//    %%BIT       DFENT      12      12        0       W|R          -            -           - 
//    %%BIT       DFTAG      11      8         0       W|R          -            -           - 
//    %%BIT       ADIE       7       7         0       W|R          -            -           - 
//    %%BIT       GCTRL      5       0         0       W|R          -            W           - 
// 
// %REG_NAME  DR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       DR1        31      16        0       R           -           -
//    %%BIT       DR0        15      0         0       R           -           -
// 
// %REG_NAME  DIR       
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       IDEF        26      26       0       R           -           -         
//    %%BIT       WFLG        25      25       0       R           -           -         
//    %%BIT       PRTY        24      24       0       R           -           -
//    %%BIT       ID          20      16       0       R           -           -
//    %%BIT       DRn         15      0        0       R           -           -
// 
// %REG_NAME  ADHALTR
//    %%TITLE     name       upper   lower     init    access      support     callback   
//    %%BIT       HALT        0        0        0      W|R         -            W
// 
// %REG_NAME  ADCR1
//    %%TITLE     name       upper   lower     init    access      support     callback    value    
//    %%BIT       SUSMTD      1        0        0      D          -            W              "b00,b01,b10"
// 
// %REG_NAME  MPXCURCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       MSKCFMT     3        0        0      W|R         -           W
// 
// %REG_NAME  MPXINTER
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       ADMPXIE     0        0        0      D           -           W
// 
// %REG_NAME  MPXCURR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       MSKC       31      16        0       R           -           -
//    %%BIT       MPXCMD     15      8         0       R           -           -
//    %%BIT       MPXCUR     4       0         0       R           -           -
// 
// %REG_NAME  MPXOWR
//    %%TITLE     name       upper   lower     init    access      support     callback    value
//    %%BIT       MPXOW      3       0         0       D           -           W           "b0000,b0001,b0010,b0011,b0100,b0101,b0110,b0111,b1000,b1001,b1010"
// 
// %REG_NAME  MPXCMDR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       MPXCMD     7       0         0       W|R         -           W
// 
// %REG_NAME  ADCR2
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       DFMT       5       4         0       D           -           W
//    %%BIT       ADDNT      0       0         0       D           -           -
// 
// %REG_NAME  DFASENTSGER
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       DFENTSG4E  12      12        0       D           FALSE       W
//    %%BIT       DFENTSG3E  11      11        0       D           FALSE       -
//    %%BIT       DFENTSG2E  10      10        0       D           FALSE       -
//    %%BIT       DFENTSG1E  9       9         0       D           FALSE       -
//    %%BIT       DFENTSG0E  8       8         0       D           FALSE       -
//    %%BIT       ASENTSG4E  4       4         0       D           TRUE        -
//    %%BIT       ASENTSG3E  3       3         0       D           TRUE        -
//    %%BIT       ASENTSG2E  2       2         0       D           TRUE        -
//    %%BIT       ASENTSG1E  1       1         0       D           TRUE        -
//    %%BIT       ASENTSG0E  0       0         0       D           TRUE        -
// 
// %REG_NAME  ADENDP
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       ENDP       5       0         0       D           -           W
// 
// %REG_NAME  THSMPSTCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       SMPST       0       0        0       D           TRUE        W
// 
// %REG_NAME  THSTPCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       THSTP        0       0        0      D           TRUE        W
// 
// %REG_NAME  THCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       ASMPMSK      0       0        0      D           TRUE        W
// 
// %REG_NAME  THAHLDSTCR  
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       HLDST      0       0        0        D           TRUE        W
// 
// %REG_NAME  THBHLDSTCR  
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       HLDST      0       0        0        D           TRUE        W
// 
// %REG_NAME  THACR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       HLDCTE     5       5         0       D           TRUE        -
//    %%BIT       HLDTE      4       4         0       D           TRUE        -
//    %%BIT       SGS        1       0         0       D           TRUE        W
// 
// %REG_NAME  THBCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       HLDCTE     5       5         0       D           TRUE        -
//    %%BIT       HLDTE      4       4         0       D           TRUE        -
//    %%BIT       SGS        1       0         0       D           TRUE        W
// 
// %REG_NAME  THER
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       TH5E       5       5         0       D           TRUE        -
//    %%BIT       TH4E       4       4         0       D           TRUE        -
//    %%BIT       TH3E       3       3         0       D           TRUE        -
//    %%BIT       TH2E       2       2         0       D           TRUE        -
//    %%BIT       TH1E       1       1         0       D           TRUE        -
//    %%BIT       TH0E       0       0         0       D           TRUE        W
// 
// %REG_NAME  THGSR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       TH5GS       10      10        0      D           TRUE        -
//    %%BIT       TH4GS       8       8         0      D           TRUE        -
//    %%BIT       TH3GS       6       6         0      D           TRUE        -
//    %%BIT       TH2GS       4       4         0      D           TRUE        -
//    %%BIT       TH1GS       2       2         0      D           TRUE        -
//    %%BIT       TH0GS       0       0         0      D           TRUE        W
// 
// %REG_NAME  THOMSR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       KEY         31      16        0      D           FALSE       -
//    %%BIT       THOMS       0       0         0      D           FALSE       -
// 
// %REG_NAME  SFTCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       SYNCEIE    5       5         0       D           FALSE       -
//    %%BIT       RDCLRE     4       4         0       D           -           -
//    %%BIT       ULEIE      3       3         0       D           -           W
//    %%BIT       OWEIE      2       2         0       D           -           -
//    %%BIT       PEIE       1       1         0       D           -           -
//    %%BIT       IDEIE      0       0         0       D           -           -
// 
// %REG_NAME  TDCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       TDE        7        7        0       D           -           W
//    %%BIT       TDLV       1        0        0       D           -           - 
// 
// %REG_NAME  ODCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       ODDE       31      31        0       D           -           W
//    %%BIT       DSCE       15      15        0       D           FALSE       -
//    %%BIT       ODE        7       7         0       D           FALSE       -
//    %%BIT       ODPW       5       0         0       D           FALSE       -
// 
// %REG_NAME  ULLMTBR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       ULMTB      31      16        32766   D           -           W
//    %%BIT       LLMTB      15      0         0       D           -           -
// 
// %REG_NAME  ECR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       SYNCEC     5        5        0       W|R         FALSE       -
//    %%BIT       ULEC       3        3        0       W|R         -           W
//    %%BIT       OWEC       2        2        0       W|R         -           -
//    %%BIT       PEC        1        1        0       W|R         -           -
//    %%BIT       IDEC       0        0        0       W|R         -           -
// 
// %REG_NAME  ULER      
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       ULE        7       7         0       D           -           -
//    %%BIT       ULECAP     5       0         0       D           -           -
// 
// %REG_NAME  OWER      
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       OWE        7       7         0       R           -           -
//    %%BIT       OWECAP     5       0         0       R           -           -
// 
// %REG_NAME  PER       
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT        PE        7       7         0       R           -           -
//    %%BIT        PECAP     5       0         0       R           -           -
// 
// %REG_NAME  IDER      
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       IDE         7       7        0       R           -           -
//    %%BIT       IDECAP      5       0        0       R           -           -
// 
// %REG_NAME  SYNCER
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       SYNCE       7       7        0       R           FALSE        -
// 
// %REG_NAME SMPCR   
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       BUFAMPD    15      15        0       D            FALSE       -
//    %%BIT       SMPT13_14  14      13        0       D            -           -
//    %%BIT       SMPTS      12      12        0       D            -           -
//    %%BIT       SMPT8_11   11      8         0       D            -           -
//    %%BIT       SMPT       7       0         0       D            -           W
// 
// %REG_NAME TRMCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       TRMS       15      15        0       W|R            FALSE         -
//    %%BIT       TRMTTUNE   13      12        0       W|R            FALSE         -
//    %%BIT       TRMBTUNE   11      10        0       W|R            FALSE         -
//    %%BIT       TRMATUNE   9       8         0       W|R            FALSE         -
//    %%BIT       TRMT       5       4         0       R              FALSE         -
//    %%BIT       TRMB       3       2         0       R              FALSE         -
//    %%BIT       TRMA       1       0         0       R              FALSE         -
// 
// %REG_NAME ADTSTRA 
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       ADTST      8       0        0        W|R            FALSE         -
//    
// %REG_NAME ADTSTRB 
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       ADVAL      13      0        0        W|R            FALSE         -
// 
// %REG_NAME ADTSTRC 
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       CKSTP      13      13        0       W|R           FALSE         -
//    %%BIT       ADMD       8       0         0       W|R           FALSE         -
// 
// %REG_NAME SGSTCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       SGST       0       0         0       W|R         -           W
// 
// %REG_NAME SGSTPCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       SGSTP       0       0         0      D           -           W
// 
// %REG_NAME  ADTSTCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       ADTST      0       0         0       W|R         -           W
// 
// %REG_NAME  ADTENDCR  
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       ADTEND     0       0         0       W|R         -           W
// 
// %REG_NAME  SGCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT      ADTSTARTE   7        7          0       W|R           -           -
//    %%BIT      ADSTARTE    6        6          0       W|R           -           -
//    %%BIT      SCANMD      5        5          0       W|R           -           -
//    %%BIT      ADIE        4        4          0       W|R           -           W
//    %%BIT      TRGMD       1        0          0       W|R           -           -
// 
// %REG_NAME  SGVCSP
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       VCSP       5       0           0       W|R           -           W
// 
// %REG_NAME  SGVCEP
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT      VCEP        5       0           0       W|R           -           W
// 
// %REG_NAME  SGMCYCR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       MCYC       7       0           0       W|R          -           W
// 
// %REG_NAME  SGVCPR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       VCEP       13      8           0       D            -           -
//    %%BIT       VCSP       5       0           0       D            -           W
// 
// %REG_NAME  SGVCOWR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT       VCOW       11      0           0       D            -           W
// 
// %REG_NAME  SGSR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT      ADTACT      2       2           0       R           -           -
//    %%BIT      SGACT       1       1           0       R           -           -
// 
// %REG_NAME  ADTIPR
//    %%TITLE     name       upper   lower     init    access      support     callback    
//    %%BIT      ADTIP       20      0           0       W|R           -           W
// 
// %REG_NAME  ADTPRR
//     %%TITLE     name       upper   lower     init    access      support     callback    
//     %%BIT      ADTPR        20     0         2097151  W|R           -           W
// 
// %REG_NAME  ULLMSR
//     %%TITLE     name       upper   lower     init    access      support     callback    
//     %%BIT      ULS          1       0         0       D             -           W
// 
// %REG_NAME  VCULLMTBR
//    %%TITLE     name       upper   lower      init    access      support     callback    
//    %%BIT       VCULMTB    31      16         32766   D           -           W
//    %%BIT       VCLLMTB    15      0          0       D           -           -
// 
// %REG_NAME  VCLMINTER1
//    %%TITLE     name       upper   lower      init    access      support     callback    
//    %%BIT       ADUL31IE   31      31         0       W|R         -           -       
//    %%BIT       ADUL30IE   30      30         0       W|R         -           -
//    %%BIT       ADUL29IE   29      29         0       W|R         -           -
//    %%BIT       ADUL28IE   28      28         0       W|R         -           -
//    %%BIT       ADUL27IE   27      27         0       W|R         -           -
//    %%BIT       ADUL26IE   26      26         0       W|R         -           -
//    %%BIT       ADUL25IE   25      25         0       W|R         -           -
//    %%BIT       ADUL24IE   24      24         0       W|R         -           -
//    %%BIT       ADUL23IE   23      23         0       W|R         -           -
//    %%BIT       ADUL22IE   22      22         0       W|R         -           -
//    %%BIT       ADUL21IE   21      21         0       W|R         -           -
//    %%BIT       ADUL20IE   20      20         0       W|R         -           -
//    %%BIT       ADUL19IE   19      19         0       W|R         -           -
//    %%BIT       ADUL18IE   18      18         0       W|R         -           -
//    %%BIT       ADUL17IE   17      17         0       W|R         -           -
//    %%BIT       ADUL16IE   16      16         0       W|R         -           -
//    %%BIT       ADUL15IE   15      15         0       W|R         -           -
//    %%BIT       ADUL14IE   14      14         0       W|R         -           -
//    %%BIT       ADUL13IE   13      13         0       W|R         -           -
//    %%BIT       ADUL12IE   12      12         0       W|R         -           -
//    %%BIT       ADUL11IE   11      11         0       W|R         -           -
//    %%BIT       ADUL10IE   10      10         0       W|R         -           -
//    %%BIT       ADUL09IE   9       9          0       W|R         -           -
//    %%BIT       ADUL08IE   8       8          0       W|R         -           -
//    %%BIT       ADUL07IE   7       7          0       W|R         -           -
//    %%BIT       ADUL06IE   6       6          0       W|R         -           -
//    %%BIT       ADUL05IE   5       5          0       W|R         -           -
//    %%BIT       ADUL04IE   4       4          0       W|R         -           -
//    %%BIT       ADUL03IE   3       3          0       W|R         -           -
//    %%BIT       ADUL02IE   2       2          0       W|R         -           -
//    %%BIT       ADUL01IE   1       1          0       W|R         -           -
//    %%BIT       ADUL00IE   0       0          0       W|R         -           W
// 
// %REG_NAME  VCLMINTER2
//    %%TITLE     name       upper   lower      init    access      support     callback    
//    %%BIT       ADUL47IE   15      15         0       W|R         -           -
//    %%BIT       ADUL46IE   14      14         0       W|R         -           -
//    %%BIT       ADUL45IE   13      13         0       W|R         -           -
//    %%BIT       ADUL44IE   12      12         0       W|R         -           -
//    %%BIT       ADUL43IE   11      11         0       W|R         -           -
//    %%BIT       ADUL42IE   10      10         0       W|R         -           -
//    %%BIT       ADUL41IE   9       9          0       W|R         -           -
//    %%BIT       ADUL40IE   8       8          0       W|R         -           -
//    %%BIT       ADUL39IE   7       7          0       W|R         -           -
//    %%BIT       ADUL38IE   6       6          0       W|R         -           -
//    %%BIT       ADUL37IE   5       5          0       W|R         -           -
//    %%BIT       ADUL36IE   4       4          0       W|R         -           -
//    %%BIT       ADUL35IE   3       3          0       W|R         -           -
//    %%BIT       ADUL34IE   2       2          0       W|R         -           -
//    %%BIT       ADUL33IE   1       1          0       W|R         -           -
//    %%BIT       ADUL32IE   0       0          0       W|R         -           W
// 
// %REG_NAME  VCLMSR1
//    %%TITLE     name       upper   lower      init    access      support     callback    
//    %%BIT       VC31LMS    31      31         0       D           -           -       
//    %%BIT       VC30LMS    30      30         0       D           -           -
//    %%BIT       VC29LMS    29      29         0       D           -           -
//    %%BIT       VC28LMS    28      28         0       D           -           -
//    %%BIT       VC27LMS    27      27         0       D           -           -
//    %%BIT       VC26LMS    26      26         0       D           -           -
//    %%BIT       VC25LMS    25      25         0       D           -           -
//    %%BIT       VC24LMS    24      24         0       D           -           -
//    %%BIT       VC23LMS    23      23         0       D           -           -
//    %%BIT       VC22LMS    22      22         0       D           -           -
//    %%BIT       VC21LMS    21      21         0       D           -           -
//    %%BIT       VC20LMS    20      20         0       D           -           -
//    %%BIT       VC19LMS    19      19         0       D           -           -
//    %%BIT       VC18LMS    18      18         0       D           -           -
//    %%BIT       VC17LMS    17      17         0       D           -           -
//    %%BIT       VC16LMS    16      16         0       D           -           -
//    %%BIT       VC15LMS    15      15         0       D           -           -
//    %%BIT       VC14LMS    14      14         0       D           -           -
//    %%BIT       VC13LMS    13      13         0       D           -           -
//    %%BIT       VC12LMS    12      12         0       D           -           -
//    %%BIT       VC11LMS    11      11         0       D           -           -
//    %%BIT       VC10LMS    10      10         0       D           -           -
//    %%BIT       VC09LMS    9       9          0       D           -           -
//    %%BIT       VC08LMS    8       8          0       D           -           -
//    %%BIT       VC07LMS    7       7          0       D           -           -
//    %%BIT       VC06LMS    6       6          0       D           -           -
//    %%BIT       VC05LMS    5       5          0       D           -           -
//    %%BIT       VC04LMS    4       4          0       D           -           -
//    %%BIT       VC03LMS    3       3          0       D           -           -
//    %%BIT       VC02LMS    2       2          0       D           -           -
//    %%BIT       VC01LMS    1       1          0       D           -           -
//    %%BIT       VC00LMS    0       0          0       D           -           -
// 
// %REG_NAME  VCLMSR2
//    %%TITLE     name       upper   lower      init    access      support     callback    
//    %%BIT       VC47LMS    15      15         0       D           -           -
//    %%BIT       VC46LMS    14      14         0       D           -           -
//    %%BIT       VC45LMS    13      13         0       D           -           -
//    %%BIT       VC44LMS    12      12         0       D           -           -
//    %%BIT       VC43LMS    11      11         0       D           -           -
//    %%BIT       VC42LMS    10      10         0       D           -           -
//    %%BIT       VC41LMS    9       9          0       D           -           -
//    %%BIT       VC40LMS    8       8          0       D           -           -
//    %%BIT       VC39LMS    7       7          0       D           -           -
//    %%BIT       VC38LMS    6       6          0       D           -           -
//    %%BIT       VC37LMS    5       5          0       D           -           -
//    %%BIT       VC36LMS    4       4          0       D           -           -
//    %%BIT       VC35LMS    3       3          0       D           -           -
//    %%BIT       VC34LMS    2       2          0       D           -           -
//    %%BIT       VC33LMS    1       1          0       D           -           -
//    %%BIT       VC32LMS    0       0          0       D           -           -
// 
// %REG_NAME  VCLMSCR1
//    %%TITLE     name       upper   lower      init    access      support     callback    
//    %%BIT       VC31LMSC   31      31         0       D           -           -       
//    %%BIT       VC30LMSC   30      30         0       D           -           -
//    %%BIT       VC29LMSC   29      29         0       D           -           -
//    %%BIT       VC28LMSC   28      28         0       D           -           -
//    %%BIT       VC27LMSC   27      27         0       D           -           -
//    %%BIT       VC26LMSC   26      26         0       D           -           -
//    %%BIT       VC25LMSC   25      25         0       D           -           -
//    %%BIT       VC24LMSC   24      24         0       D           -           -
//    %%BIT       VC23LMSC   23      23         0       D           -           -
//    %%BIT       VC22LMSC   22      22         0       D           -           -
//    %%BIT       VC21LMSC   21      21         0       D           -           -
//    %%BIT       VC20LMSC   20      20         0       D           -           -
//    %%BIT       VC19LMSC   19      19         0       D           -           -
//    %%BIT       VC18LMSC   18      18         0       D           -           -
//    %%BIT       VC17LMSC   17      17         0       D           -           -
//    %%BIT       VC16LMSC   16      16         0       D           -           -
//    %%BIT       VC15LMSC   15      15         0       D           -           -
//    %%BIT       VC14LMSC   14      14         0       D           -           -
//    %%BIT       VC13LMSC   13      13         0       D           -           -
//    %%BIT       VC12LMSC   12      12         0       D           -           -
//    %%BIT       VC11LMSC   11      11         0       D           -           -
//    %%BIT       VC10LMSC   10      10         0       D           -           -
//    %%BIT       VC09LMSC   9       9          0       D           -           -
//    %%BIT       VC08LMSC   8       8          0       D           -           -
//    %%BIT       VC07LMSC   7       7          0       D           -           -
//    %%BIT       VC06LMSC   6       6          0       D           -           -
//    %%BIT       VC05LMSC   5       5          0       D           -           -
//    %%BIT       VC04LMSC   4       4          0       D           -           -
//    %%BIT       VC03LMSC   3       3          0       D           -           -
//    %%BIT       VC02LMSC   2       2          0       D           -           -
//    %%BIT       VC01LMSC   1       1          0       D           -           -
//    %%BIT       VC00LMSC   0       0          0       D           -           W
// 
// %REG_NAME  VCLMSCR2
//    %%TITLE     name       upper   lower      init    access      support     callback    
//    %%BIT       VC47LMSC   15      15         0       D           -           -
//    %%BIT       VC46LMSC   14      14         0       D           -           -
//    %%BIT       VC45LMSC   13      13         0       D           -           -
//    %%BIT       VC44LMSC   12      12         0       D           -           -
//    %%BIT       VC43LMSC   11      11         0       D           -           -
//    %%BIT       VC42LMSC   10      10         0       D           -           -
//    %%BIT       VC41LMSC   9       9          0       D           -           -
//    %%BIT       VC40LMSC   8       8          0       D           -           -
//    %%BIT       VC39LMSC   7       7          0       D           -           -
//    %%BIT       VC38LMSC   6       6          0       D           -           -
//    %%BIT       VC37LMSC   5       5          0       D           -           -
//    %%BIT       VC36LMSC   4       4          0       D           -           -
//    %%BIT       VC35LMSC   3       3          0       D           -           -
//    %%BIT       VC34LMSC   2       2          0       D           -           -
//    %%BIT       VC33LMSC   1       1          0       D           -           -
//    %%BIT       VC32LMSC   0       0          0       D           -           W
// 
// %REG_NAME  ADOPDIG
//     %%TITLE     name       upper   lower     init    access      support     callback    
//     %%BIT       ADOPDIGn0   0       0         0       W|R           -           W
//     %%BIT       ADOPDIGn1   1       1         0       W|R           -           -
//     %%BIT       ADOPDIGn2   2       2         0       W|R           -           -
//     %%BIT       ADOPDIGn3   3       3         0       W|R           -           -
//     %%BIT       ADOPDIGn4   4       4         0       W|R           -           -
//     %%BIT       ADOPDIGn5   5       5         0       W|R           -           -
//     %%BIT       ADOPDIGn6   6       6         0       W|R           -           -
//     %%BIT       ADOPDIGn7   7       7         0       W|R           -           -
//     %%BIT       ADOPDIGn8   8       8         0       W|R           -           -
//     %%BIT       ADOPDIGn9   9       9         0       W|R           -           -
//     %%BIT       ADOPDIGn10  10      10        0       W|R           -           -
//     %%BIT       ADOPDIGn11  11      11        0       W|R           -           -
// 
// 
// %CMD_BASEID  reg
// %CMD_NODUMP_API EnableInsertInput EnableDumpResult CommandCB AssertReset DumpProfile ClearProfile
////////////////////////////////////////////////////////////////////////////////
/// @file adc_regif.cpp
/// @brief Register IF class of model ADC
/// $Id$
/// $Date$
/// $Revison$
/// $Author$
////////////////////////////////////////////////////////////////////////////////
#include "adc_regif.h"
#ifndef re_printf
#define re_printf get_fileline(__FILE__, __LINE__); _re_printf
#endif//re_printf

/// Constructor of Register IF class: define registers and bits
/// @return none
Cadc_regif::Cadc_regif(std::string name, uint buswidth)
    :vpcl::reg_super()
    #ifdef CWR_SYSTEMC
    , cwmem("register", 0x74C)
    #endif
{
    uint FactorIndex_ADTSTCR_tmp[emNUM_ADTSTCR] = {   3,   4};
    uint FactorIndex_ADTENDCR_tmp[emNUM_ADTENDCR] = {   3,   4};
    uint FactorIndex_ADTIPR_tmp[emNUM_ADTIPR] = {   3,   4};
    uint FactorIndex_ADTPRR_tmp[emNUM_ADTPRR] = {   3,   4};
    for(uint i = 0; i < emNUM_ADTSTCR; i++) {
        mFactorIndexADTSTCR[i] = FactorIndex_ADTSTCR_tmp[i];
    }
    for(uint i = 0; i < emNUM_ADTENDCR; i++) {
        mFactorIndexADTENDCR[i] = FactorIndex_ADTENDCR_tmp[i];
    }
    for(uint i = 0; i < emNUM_ADTIPR; i++) {
        mFactorIndexADTIPR[i] = FactorIndex_ADTIPR_tmp[i];
    }
    for(uint i = 0; i < emNUM_ADTPRR; i++) {
        mFactorIndexADTPRR[i] = FactorIndex_ADTPRR_tmp[i];
    }

    CommandInit();
    ADHALTR     = new vpcl::re_register(0x0380, this, "ADHALTR"    , name.c_str());
    ADCR1       = new vpcl::re_register(0x0384, this, "ADCR1"      , name.c_str());
    MPXCURCR    = new vpcl::re_register(0x0388, this, "MPXCURCR"   , name.c_str());
    MPXINTER    = new vpcl::re_register(0x038A, this, "MPXINTER"   , name.c_str());
    MPXCURR     = new vpcl::re_register(0x038C, this, "MPXCURR"    , name.c_str());
    MPXOWR      = new vpcl::re_register(0x0390, this, "MPXOWR"     , name.c_str());
    MPXCMDR     = new vpcl::re_register(0x0394, this, "MPXCMDR"    , name.c_str());
    ADCR2       = new vpcl::re_register(0x0398, this, "ADCR2"      , name.c_str());
    DFASENTSGER = new vpcl::re_register(0x039C, this, "DFASENTSGER", name.c_str());
    THSMPSTCR   = new vpcl::re_register(0x0400, this, "THSMPSTCR"  , name.c_str());
    THSTPCR     = new vpcl::re_register(0x0404, this, "THSTPCR"    , name.c_str());
    THCR        = new vpcl::re_register(0x0408, this, "THCR"       , name.c_str());
    THAHLDSTCR  = new vpcl::re_register(0x0410, this, "THAHLDSTCR" , name.c_str());
    THBHLDSTCR  = new vpcl::re_register(0x0414, this, "THBHLDSTCR" , name.c_str());
    THACR       = new vpcl::re_register(0x0420, this, "THACR"      , name.c_str());
    THBCR       = new vpcl::re_register(0x0424, this, "THBCR"      , name.c_str());
    THER        = new vpcl::re_register(0x0430, this, "THER"       , name.c_str());
    THGSR       = new vpcl::re_register(0x0434, this, "THGSR"      , name.c_str());
    THOMSR      = new vpcl::re_register(0x0440, this, "THOMSR"     , name.c_str());
    SFTCR       = new vpcl::re_register(0x03C0, this, "SFTCR"      , name.c_str());
    TDCR        = new vpcl::re_register(0x03C4, this, "TDCR"       , name.c_str());
    ODCR        = new vpcl::re_register(0x03C8, this, "ODCR"       , name.c_str());
    ECR         = new vpcl::re_register(0x03D8, this, "ECR"        , name.c_str());
    ULER        = new vpcl::re_register(0x03DC, this, "ULER"       , name.c_str());
    OWER        = new vpcl::re_register(0x03E0, this, "OWER"       , name.c_str());
    PER         = new vpcl::re_register(0x03E4, this, "PER"        , name.c_str());
    IDER        = new vpcl::re_register(0x03E8, this, "IDER"       , name.c_str());
    SYNCER      = new vpcl::re_register(0x03EC, this, "SYNCER"     , name.c_str());
    SMPCR       = new vpcl::re_register(0x0340, this, "SMPCR"      , name.c_str());
    TRMCR       = new vpcl::re_register(0x0360, this, "TRMCR"      , name.c_str());
    ADTSTRA     = new vpcl::re_register(0x0364, this, "ADTSTRA"    , name.c_str());
    ADTSTRB     = new vpcl::re_register(0x0368, this, "ADTSTRB"    , name.c_str());
    ADTSTRC     = new vpcl::re_register(0x036C, this, "ADTSTRC"    , name.c_str());
    VCLMINTER1  = new vpcl::re_register(0x0730, this, "VCLMINTER1" , name.c_str());
    VCLMINTER2  = new vpcl::re_register(0x0734, this, "VCLMINTER2" , name.c_str());
    VCLMSR1     = new vpcl::re_register(0x0738, this, "VCLMSR1"    , name.c_str());
    VCLMSR2     = new vpcl::re_register(0x073C, this, "VCLMSR2"    , name.c_str());
    VCLMSCR1    = new vpcl::re_register(0x0740, this, "VCLMSCR1"   , name.c_str());
    VCLMSCR2    = new vpcl::re_register(0x0744, this, "VCLMSCR2"   , name.c_str());
    ADOPDIG     = new vpcl::re_register(0x0748, this, "ADOPDIG"    , name.c_str());
    std::ostringstream str_tmp;
    for(uint i = 0; i < emNUM_VCR; i++) {
        str_tmp.str("");
        str_tmp<<"VCR"<< i;
        VCR        [i] = new vpcl::re_register((0x0000) + 4*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_DR; i++) {
        str_tmp.str("");
        str_tmp<<"DR"<< i;
        DR         [i] = new vpcl::re_register((0x0100) + 4*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_DIR; i++) {
        str_tmp.str("");
        str_tmp<<"DIR"<< i;
        DIR        [i] = new vpcl::re_register((0x0200) + 4*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_ADENDP; i++) {
        str_tmp.str("");
        str_tmp<<"ADENDP"<< i;
        ADENDP     [i] = new vpcl::re_register((0x03A0) + 4*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_ULLMTBR; i++) {
        str_tmp.str("");
        str_tmp<<"ULLMTBR"<< i;
        ULLMTBR    [i] = new vpcl::re_register((0x03CC) + 4*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_SGSTCR; i++) {
        str_tmp.str("");
        str_tmp<<"SGSTCR"<< i;
        SGSTCR     [i] = new vpcl::re_register((0x0480) + 128*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_SGSTPCR; i++) {
        str_tmp.str("");
        str_tmp<<"SGSTPCR"<< i;
        SGSTPCR    [i] = new vpcl::re_register((0x0484) + 128*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_ADTSTCR; i++) {
        str_tmp.str("");
        str_tmp<<"ADTSTCR"<< mFactorIndexADTSTCR[i];
        ADTSTCR    [mFactorIndexADTSTCR[i]] = new vpcl::re_register((0x0608) + 128*(mFactorIndexADTSTCR[i]-3), this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_ADTENDCR; i++) {
        str_tmp.str("");
        str_tmp<<"ADTENDCR"<< mFactorIndexADTENDCR[i];
        ADTENDCR   [mFactorIndexADTENDCR[i]] = new vpcl::re_register((0x060C) + 128*(mFactorIndexADTENDCR[i]-3), this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_SGCR; i++) {
        str_tmp.str("");
        str_tmp<<"SGCR"<< i;
        SGCR       [i] = new vpcl::re_register((0x0490) + 128*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_SGVCSP; i++) {
        str_tmp.str("");
        str_tmp<<"SGVCSP"<< i;
        SGVCSP     [i] = new vpcl::re_register((0x0494) + 128*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_SGVCEP; i++) {
        str_tmp.str("");
        str_tmp<<"SGVCEP"<< i;
        SGVCEP     [i] = new vpcl::re_register((0x0498) + 128*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_SGMCYCR; i++) {
        str_tmp.str("");
        str_tmp<<"SGMCYCR"<< i;
        SGMCYCR    [i] = new vpcl::re_register((0x049C) + 128*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_SGVCPR; i++) {
        str_tmp.str("");
        str_tmp<<"SGVCPR"<< i;
        SGVCPR     [i] = new vpcl::re_register((0x04A0) + 128*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_SGVCOWR; i++) {
        str_tmp.str("");
        str_tmp<<"SGVCOWR"<< i;
        SGVCOWR    [i] = new vpcl::re_register((0x04B4) + 128*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_SGSR; i++) {
        str_tmp.str("");
        str_tmp<<"SGSR"<< i;
        SGSR       [i] = new vpcl::re_register((0x04A4) + 128*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_ADTIPR; i++) {
        str_tmp.str("");
        str_tmp<<"ADTIPR"<< mFactorIndexADTIPR[i];
        ADTIPR     [mFactorIndexADTIPR[i]] = new vpcl::re_register((0x0628) + 128*(mFactorIndexADTIPR[i]-3), this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_ADTPRR; i++) {
        str_tmp.str("");
        str_tmp<<"ADTPRR"<< mFactorIndexADTPRR[i];
        ADTPRR     [mFactorIndexADTPRR[i]] = new vpcl::re_register((0x062C) + 128*(mFactorIndexADTPRR[i]-3), this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_ULLMSR; i++) {
        str_tmp.str("");
        str_tmp<<"ULLMSR"<< i;
        ULLMSR     [i] = new vpcl::re_register((0x04B0) + 128*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_VCULLMTBR; i++) {
        str_tmp.str("");
        str_tmp<<"VCULLMTBR"<< i;
        VCULLMTBR  [i] = new vpcl::re_register((0x0700) + 4*i, this, str_tmp.str(), name.c_str());
    }

    // Construct the register pointer list
    mCurReg = NULL;

    uint index = 0;
    mRegMap = new uint [1<<11];
    for (uint i = 0; i < (1<<11); i++) {
        mRegMap[i] = (1<<11);
    }

    for(uint i = 0; i < emNUM_VCR;        i++) {
        mRegMap[(0x0000)     + i*4 ] = index;
        mRegMap[(0x0000 + 1) + i*4 ] = index;
        mRegMap[(0x0000 + 2) + i*4 ] = index;
        mRegMap[(0x0000 + 3) + i*4 ] = index++;
    }
    for(uint i = 0; i < emNUM_DR;         i++) {
        mRegMap[(0x0100)     + i*4 ] = index;
        mRegMap[(0x0100 + 1) + i*4 ] = index;
        mRegMap[(0x0100 + 2) + i*4 ] = index;
        mRegMap[(0x0100 + 3) + i*4 ] = index++;
    }
    for(uint i = 0; i < emNUM_DIR;        i++) {
        mRegMap[(0x0200)     + i*4 ] = index;
        mRegMap[(0x0200 + 1) + i*4 ] = index;
        mRegMap[(0x0200 + 2) + i*4 ] = index;
        mRegMap[(0x0200 + 3) + i*4 ] = index++;
    }
    mRegMap[0x0340]     = index;
    mRegMap[0x0340 + 1] = index++;
    mRegMap[0x0360]     = index;
    mRegMap[0x0360 + 1] = index++;
    mRegMap[0x0364]     = index;
    mRegMap[0x0364 + 1] = index++;
    mRegMap[0x0368]     = index;
    mRegMap[0x0368 + 1] = index++;
    mRegMap[0x036C]     = index;
    mRegMap[0x036C + 1] = index++;
    mRegMap[0x0380]     = index++;
    mRegMap[0x0384]     = index++;
    mRegMap[0x0388]     = index++;
    mRegMap[0x038A]     = index++;
    mRegMap[0x038C]     = index;
    mRegMap[0x038C + 1] = index;
    mRegMap[0x038C + 2] = index;
    mRegMap[0x038C + 3] = index++;
    mRegMap[0x0390]     = index++;
    mRegMap[0x0394]     = index++;
    mRegMap[0x0398]     = index++;
    mRegMap[0x039C]     = index;
    mRegMap[0x039C + 1] = index++;
    for(uint i = 0; i < emNUM_ADENDP;     i++) {
        mRegMap[(0x03A0)     + i*4 ] = index++;
    }
    mRegMap[0x03C0]     = index++;
    mRegMap[0x03C4]     = index++;
    mRegMap[0x03C8]     = index;
    mRegMap[0x03C8 + 1] = index;
    mRegMap[0x03C8 + 2] = index;
    mRegMap[0x03C8 + 3] = index++;
    for(uint i = 0; i < emNUM_ULLMTBR;    i++) {
        mRegMap[(0x03CC)     + i*4 ] = index;
        mRegMap[(0x03CC + 1) + i*4 ] = index;
        mRegMap[(0x03CC + 2) + i*4 ] = index;
        mRegMap[(0x03CC + 3) + i*4 ] = index++;
    }
    mRegMap[0x03D8]     = index++;
    mRegMap[0x03DC]     = index++;
    mRegMap[0x03E0]     = index++;
    mRegMap[0x03E4]     = index++;
    mRegMap[0x03E8]     = index++;
    mRegMap[0x03EC]     = index++;
    mRegMap[0x0400]     = index++;
    mRegMap[0x0404]     = index++;
    mRegMap[0x0408]     = index++;
    mRegMap[0x0410]     = index++;
    mRegMap[0x0414]     = index++;
    mRegMap[0x0420]     = index++;
    mRegMap[0x0424]     = index++;
    mRegMap[0x0430]     = index++;
    mRegMap[0x0434]     = index;
    mRegMap[0x0434 + 1] = index++;
    mRegMap[0x0440]     = index;
    mRegMap[0x0440 + 1] = index;
    mRegMap[0x0440 + 2] = index;
    mRegMap[0x0440 + 3] = index++;
    for(uint i = 0; i < emNUM_SGSTCR;     i++) {
        mRegMap[(0x0480)     + i*128] = index++;
    }
    for(uint i = 0; i < emNUM_SGSTPCR;    i++) {
        mRegMap[(0x0484)     + i*128] = index++;
    }
    for(uint i = 0; i < emNUM_SGCR;       i++) {
        mRegMap[(0x0490)     + i*128] = index++;
    }
    for(uint i = 0; i < emNUM_SGVCSP;     i++) {
        mRegMap[(0x0494)     + i*128] = index++;
    }
    for(uint i = 0; i < emNUM_SGVCEP;     i++) {
        mRegMap[(0x0498)     + i*128] = index++;
    }
    for(uint i = 0; i < emNUM_SGMCYCR;    i++) {
        mRegMap[(0x049C)     + i*128] = index++;
    }
    for(uint i = 0; i < emNUM_SGVCPR;     i++) {
        mRegMap[(0x04A0)     + i*128] = index;
        mRegMap[(0x04A0 + 1) + i*128] = index++;
    }
    for(uint i = 0; i < emNUM_SGSR;       i++) {
        mRegMap[(0x04A4)     + i*128] = index++;
    }
    for(uint i = 0; i < emNUM_ULLMSR;     i++) {
        mRegMap[(0x04B0)     + i*128] = index++;
    }
    for(uint i = 0; i < emNUM_SGVCOWR;    i++) {
        mRegMap[(0x04B4)     + i*128] = index;
        mRegMap[(0x04B4 + 1) + i*128] = index++;
    }
    for(uint i = 0; i < emNUM_ADTSTCR;    i++) {
        mRegMap[(0x0608)     + (mFactorIndexADTSTCR[i]-3)*128] = index++;
    }
    for(uint i = 0; i < emNUM_ADTENDCR;   i++) {
        mRegMap[(0x060C)     + (mFactorIndexADTENDCR[i]-3)*128] = index++;
    }
    for(uint i = 0; i < emNUM_ADTIPR;     i++) {
        mRegMap[(0x0628)     + (mFactorIndexADTIPR[i]-3)*128] = index;
        mRegMap[(0x0628 + 1) + (mFactorIndexADTIPR[i]-3)*128] = index;
        mRegMap[(0x0628 + 2) + (mFactorIndexADTIPR[i]-3)*128] = index;
        mRegMap[(0x0628 + 3) + (mFactorIndexADTIPR[i]-3)*128] = index++;
    }
    for(uint i = 0; i < emNUM_ADTPRR;     i++) {
        mRegMap[(0x062C)     + (mFactorIndexADTPRR[i]-3)*128] = index;
        mRegMap[(0x062C + 1) + (mFactorIndexADTPRR[i]-3)*128] = index;
        mRegMap[(0x062C + 2) + (mFactorIndexADTPRR[i]-3)*128] = index;
        mRegMap[(0x062C + 3) + (mFactorIndexADTPRR[i]-3)*128] = index++;
    }
    for(uint i = 0; i < emNUM_VCULLMTBR;  i++) {
        mRegMap[(0x0700)     + i*4 ] = index;
        mRegMap[(0x0700 + 1) + i*4 ] = index;
        mRegMap[(0x0700 + 2) + i*4 ] = index;
        mRegMap[(0x0700 + 3) + i*4 ] = index++;
    }
    mRegMap[0x0730]     = index;
    mRegMap[0x0730 + 1] = index;
    mRegMap[0x0730 + 2] = index;
    mRegMap[0x0730 + 3] = index++;
    mRegMap[0x0734]     = index;
    mRegMap[0x0734 + 1] = index;
    mRegMap[0x0734 + 2] = index;
    mRegMap[0x0734 + 3] = index++;
    mRegMap[0x0738]     = index;
    mRegMap[0x0738 + 1] = index;
    mRegMap[0x0738 + 2] = index;
    mRegMap[0x0738 + 3] = index++;
    mRegMap[0x073C]     = index;
    mRegMap[0x073C + 1] = index;
    mRegMap[0x073C + 2] = index;
    mRegMap[0x073C + 3] = index++;
    mRegMap[0x0740]     = index;
    mRegMap[0x0740 + 1] = index;
    mRegMap[0x0740 + 2] = index;
    mRegMap[0x0740 + 3] = index++;
    mRegMap[0x0744]     = index;
    mRegMap[0x0744 + 1] = index;
    mRegMap[0x0744 + 2] = index;
    mRegMap[0x0744 + 3] = index++;
    mRegMap[0x0748]     = index;
    mRegMap[0x0748 + 1] = index;
    mRegMap[0x0748 + 2] = index;
    mRegMap[0x0748 + 3] = index++;
    mTotalRegNum = index;
    mRegArray = new SRegList* [mTotalRegNum];
    index = 0;
#ifdef CWR_SYSTEMC
    for(uint i = 0; i < emNUM_VCR        ; i++) mCurReg = mRegArray[index++] = new SRegList(VCR          [i], mCurReg, i,  4, "8|16|32", "8|16|32", false, &cwmem);
#else
    for(uint i = 0; i < emNUM_VCR        ; i++) mCurReg = mRegArray[index++] = new SRegList(VCR          [i], mCurReg, i,  4, "8|16|32", "8|16|32");
#endif
    for(uint i = 0; i < emNUM_DR         ; i++) mCurReg = mRegArray[index++] = new SRegList(DR           [i], mCurReg, i,  4, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_DIR        ; i++) mCurReg = mRegArray[index++] = new SRegList(DIR          [i], mCurReg, i,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(SMPCR        , mCurReg, 0,  2, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TRMCR        , mCurReg, 0,  2, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(ADTSTRA      , mCurReg, 0,  2, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(ADTSTRB      , mCurReg, 0,  2, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(ADTSTRC      , mCurReg, 0,  2, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(ADHALTR      , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(ADCR1        , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(MPXCURCR     , mCurReg, 0,  1,    "8|16",    "8|16");
    mCurReg = mRegArray[index++] = new SRegList(MPXINTER     , mCurReg, 0,  1,    "8|16",    "8|16");
    mCurReg = mRegArray[index++] = new SRegList(MPXCURR      , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(MPXOWR       , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(MPXCMDR      , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(ADCR2        , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(DFASENTSGER  , mCurReg, 0,  2, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_ADENDP     ; i++) mCurReg = mRegArray[index++] = new SRegList(ADENDP       [i], mCurReg, i,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(SFTCR        , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TDCR         , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(ODCR         , mCurReg, 0,  4, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_ULLMTBR    ; i++) mCurReg = mRegArray[index++] = new SRegList(ULLMTBR      [i], mCurReg, i,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(ECR          , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(ULER         , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(OWER         , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(PER          , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(IDER         , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(SYNCER       , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(THSMPSTCR    , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(THSTPCR      , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(THCR         , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(THAHLDSTCR   , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(THBHLDSTCR   , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(THACR        , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(THBCR        , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(THER         , mCurReg, 0,  1, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(THGSR        , mCurReg, 0,  2, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(THOMSR       , mCurReg, 0,  4,      "32", "8|16|32");
    for(uint i = 0; i < emNUM_SGSTCR     ; i++) mCurReg = mRegArray[index++] = new SRegList(SGSTCR       [i], mCurReg, i,  1, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_SGSTPCR    ; i++) mCurReg = mRegArray[index++] = new SRegList(SGSTPCR      [i], mCurReg, i,  1, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_SGCR       ; i++) mCurReg = mRegArray[index++] = new SRegList(SGCR         [i], mCurReg, i,  1, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_SGVCSP     ; i++) mCurReg = mRegArray[index++] = new SRegList(SGVCSP       [i], mCurReg, i,  1, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_SGVCEP     ; i++) mCurReg = mRegArray[index++] = new SRegList(SGVCEP       [i], mCurReg, i,  1, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_SGMCYCR    ; i++) mCurReg = mRegArray[index++] = new SRegList(SGMCYCR      [i], mCurReg, i,  1, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_SGVCPR     ; i++) mCurReg = mRegArray[index++] = new SRegList(SGVCPR       [i], mCurReg, i,  2,    "8|16",    "8|16");
    for(uint i = 0; i < emNUM_SGSR       ; i++) mCurReg = mRegArray[index++] = new SRegList(SGSR         [i], mCurReg, i,  1, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_ULLMSR     ; i++) mCurReg = mRegArray[index++] = new SRegList(ULLMSR       [i], mCurReg, i,  1, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_SGVCOWR    ; i++) mCurReg = mRegArray[index++] = new SRegList(SGVCOWR      [i], mCurReg, i,  2,    "8|16",    "8|16");
    for(uint i = 0; i < emNUM_ADTSTCR    ; i++) mCurReg = mRegArray[index++] = new SRegList(ADTSTCR      [mFactorIndexADTSTCR    [i]], mCurReg, mFactorIndexADTSTCR    [i],  1, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_ADTENDCR   ; i++) mCurReg = mRegArray[index++] = new SRegList(ADTENDCR     [mFactorIndexADTENDCR   [i]], mCurReg, mFactorIndexADTENDCR   [i],  1, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_ADTIPR     ; i++) mCurReg = mRegArray[index++] = new SRegList(ADTIPR       [mFactorIndexADTIPR     [i]], mCurReg, mFactorIndexADTIPR     [i],  4, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_ADTPRR     ; i++) mCurReg = mRegArray[index++] = new SRegList(ADTPRR       [mFactorIndexADTPRR     [i]], mCurReg, mFactorIndexADTPRR     [i],  4, "8|16|32", "8|16|32");
    for(uint i = 0; i < emNUM_VCULLMTBR  ; i++) mCurReg = mRegArray[index++] = new SRegList(VCULLMTBR    [i], mCurReg, i,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(VCLMINTER1   , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(VCLMINTER2   , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(VCLMSR1      , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(VCLMSR2      , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(VCLMSCR1     , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(VCLMSCR2     , mCurReg, 0,  4, "8|16|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(ADOPDIG      , mCurReg, 0,  4, "8|16|32", "8|16|32");

    mRegList = mCurReg;

    (*ADHALTR      ) ( 0,  0, "HALT"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*ADCR1        ) ( 1,  0, "SUSMTD"  , 0x0       , "D"     , vpcl::SPP_ENABLE, "b00,b01,b10");
    (*MPXCURCR     ) ( 3,  0, "MSKCFMT" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*MPXINTER     ) ( 0,  0, "ADMPXIE" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*MPXCURR      ) (31, 16, "MSKC"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*MPXCURR      ) (15,  8, "MPXCMD"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*MPXCURR      ) ( 4,  0, "MPXCUR"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*MPXOWR       ) ( 3,  0, "MPXOW"   , 0x0       , "D"     , vpcl::SPP_ENABLE, "b0000,b0001,b0010,b0011,b0100,b0101,b0110,b0111,b1000,b1001,b1010");
    (*MPXCMDR      ) ( 7,  0, "MPXCMD"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*ADCR2        ) ( 5,  4, "DFMT"    , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*ADCR2        ) ( 0,  0, "ADDNT"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*DFASENTSGER  ) (12, 12, "DFENTSG4E", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*DFASENTSGER  ) (11, 11, "DFENTSG3E", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*DFASENTSGER  ) (10, 10, "DFENTSG2E", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*DFASENTSGER  ) ( 9,  9, "DFENTSG1E", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*DFASENTSGER  ) ( 8,  8, "DFENTSG0E", 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*DFASENTSGER  ) ( 4,  4, "ASENTSG4E", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*DFASENTSGER  ) ( 3,  3, "ASENTSG3E", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*DFASENTSGER  ) ( 2,  2, "ASENTSG2E", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*DFASENTSGER  ) ( 1,  1, "ASENTSG1E", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*DFASENTSGER  ) ( 0,  0, "ASENTSG0E", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THSMPSTCR    ) ( 0,  0, "SMPST"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THSTPCR      ) ( 0,  0, "THSTP"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THCR         ) ( 0,  0, "ASMPMSK" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THAHLDSTCR   ) ( 0,  0, "HLDST"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THBHLDSTCR   ) ( 0,  0, "HLDST"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THACR        ) ( 5,  5, "HLDCTE"  , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THACR        ) ( 4,  4, "HLDTE"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THACR        ) ( 1,  0, "SGS"     , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THBCR        ) ( 5,  5, "HLDCTE"  , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THBCR        ) ( 4,  4, "HLDTE"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THBCR        ) ( 1,  0, "SGS"     , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THER         ) ( 5,  5, "TH5E"    , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THER         ) ( 4,  4, "TH4E"    , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THER         ) ( 3,  3, "TH3E"    , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THER         ) ( 2,  2, "TH2E"    , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THER         ) ( 1,  1, "TH1E"    , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THER         ) ( 0,  0, "TH0E"    , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THGSR        ) (10, 10, "TH5GS"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THGSR        ) ( 8,  8, "TH4GS"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THGSR        ) ( 6,  6, "TH3GS"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THGSR        ) ( 4,  4, "TH2GS"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THGSR        ) ( 2,  2, "TH1GS"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THGSR        ) ( 0,  0, "TH0GS"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*THOMSR       ) (31, 16, "KEY"     , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*THOMSR       ) ( 0,  0, "THOMS"   , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*SFTCR        ) ( 5,  5, "SYNCEIE" , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*SFTCR        ) ( 4,  4, "RDCLRE"  , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*SFTCR        ) ( 3,  3, "ULEIE"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*SFTCR        ) ( 2,  2, "OWEIE"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*SFTCR        ) ( 1,  1, "PEIE"    , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*SFTCR        ) ( 0,  0, "IDEIE"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*TDCR         ) ( 7,  7, "TDE"     , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*TDCR         ) ( 1,  0, "TDLV"    , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*ODCR         ) (31, 31, "ODDE"    , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*ODCR         ) (15, 15, "DSCE"    , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*ODCR         ) ( 7,  7, "ODE"     , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*ODCR         ) ( 5,  0, "ODPW"    , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*ECR          ) ( 5,  5, "SYNCEC"  , 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*ECR          ) ( 3,  3, "ULEC"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*ECR          ) ( 2,  2, "OWEC"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*ECR          ) ( 1,  1, "PEC"     , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*ECR          ) ( 0,  0, "IDEC"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*ULER         ) ( 7,  7, "ULE"     , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*ULER         ) ( 5,  0, "ULECAP"  , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*OWER         ) ( 7,  7, "OWE"     , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*OWER         ) ( 5,  0, "OWECAP"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*PER          ) ( 7,  7, "PE"      , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*PER          ) ( 5,  0, "PECAP"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*IDER         ) ( 7,  7, "IDE"     , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*IDER         ) ( 5,  0, "IDECAP"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*SYNCER       ) ( 7,  7, "SYNCE"   , 0x0       , "R"     , vpcl::SPP_DISABLE);
    (*SMPCR        ) (15, 15, "BUFAMPD" , 0x0       , "D"     , vpcl::SPP_DISABLE);
    (*SMPCR        ) (14, 13, "SMPT13_14", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*SMPCR        ) (12, 12, "SMPTS"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*SMPCR        ) (11,  8, "SMPT8_11", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*SMPCR        ) ( 7,  0, "SMPT"    , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*TRMCR        ) (15, 15, "TRMS"    , 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*TRMCR        ) (13, 12, "TRMTTUNE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*TRMCR        ) (11, 10, "TRMBTUNE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*TRMCR        ) ( 9,  8, "TRMATUNE", 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*TRMCR        ) ( 5,  4, "TRMT"    , 0x0       , "R"     , vpcl::SPP_DISABLE);
    (*TRMCR        ) ( 3,  2, "TRMB"    , 0x0       , "R"     , vpcl::SPP_DISABLE);
    (*TRMCR        ) ( 1,  0, "TRMA"    , 0x0       , "R"     , vpcl::SPP_DISABLE);
    (*ADTSTRA      ) ( 8,  0, "ADTST"   , 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*ADTSTRB      ) (13,  0, "ADVAL"   , 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*ADTSTRC      ) (13, 13, "CKSTP"   , 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*ADTSTRC      ) ( 8,  0, "ADMD"    , 0x0       , "W|R"   , vpcl::SPP_DISABLE);
    (*VCLMINTER1   ) (31, 31, "ADUL31IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (30, 30, "ADUL30IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (29, 29, "ADUL29IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (28, 28, "ADUL28IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (27, 27, "ADUL27IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (26, 26, "ADUL26IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (25, 25, "ADUL25IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (24, 24, "ADUL24IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (23, 23, "ADUL23IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (22, 22, "ADUL22IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (21, 21, "ADUL21IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (20, 20, "ADUL20IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (19, 19, "ADUL19IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (18, 18, "ADUL18IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (17, 17, "ADUL17IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (16, 16, "ADUL16IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (15, 15, "ADUL15IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (14, 14, "ADUL14IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (13, 13, "ADUL13IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (12, 12, "ADUL12IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (11, 11, "ADUL11IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) (10, 10, "ADUL10IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) ( 9,  9, "ADUL09IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) ( 8,  8, "ADUL08IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) ( 7,  7, "ADUL07IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) ( 6,  6, "ADUL06IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) ( 5,  5, "ADUL05IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) ( 4,  4, "ADUL04IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) ( 3,  3, "ADUL03IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) ( 2,  2, "ADUL02IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) ( 1,  1, "ADUL01IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER1   ) ( 0,  0, "ADUL00IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) (15, 15, "ADUL47IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) (14, 14, "ADUL46IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) (13, 13, "ADUL45IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) (12, 12, "ADUL44IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) (11, 11, "ADUL43IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) (10, 10, "ADUL42IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) ( 9,  9, "ADUL41IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) ( 8,  8, "ADUL40IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) ( 7,  7, "ADUL39IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) ( 6,  6, "ADUL38IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) ( 5,  5, "ADUL37IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) ( 4,  4, "ADUL36IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) ( 3,  3, "ADUL35IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) ( 2,  2, "ADUL34IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) ( 1,  1, "ADUL33IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMINTER2   ) ( 0,  0, "ADUL32IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (31, 31, "VC31LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (30, 30, "VC30LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (29, 29, "VC29LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (28, 28, "VC28LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (27, 27, "VC27LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (26, 26, "VC26LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (25, 25, "VC25LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (24, 24, "VC24LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (23, 23, "VC23LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (22, 22, "VC22LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (21, 21, "VC21LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (20, 20, "VC20LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (19, 19, "VC19LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (18, 18, "VC18LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (17, 17, "VC17LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (16, 16, "VC16LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (15, 15, "VC15LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (14, 14, "VC14LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (13, 13, "VC13LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (12, 12, "VC12LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (11, 11, "VC11LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) (10, 10, "VC10LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) ( 9,  9, "VC09LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) ( 8,  8, "VC08LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) ( 7,  7, "VC07LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) ( 6,  6, "VC06LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) ( 5,  5, "VC05LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) ( 4,  4, "VC04LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) ( 3,  3, "VC03LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) ( 2,  2, "VC02LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) ( 1,  1, "VC01LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR1      ) ( 0,  0, "VC00LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) (15, 15, "VC47LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) (14, 14, "VC46LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) (13, 13, "VC45LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) (12, 12, "VC44LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) (11, 11, "VC43LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) (10, 10, "VC42LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) ( 9,  9, "VC41LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) ( 8,  8, "VC40LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) ( 7,  7, "VC39LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) ( 6,  6, "VC38LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) ( 5,  5, "VC37LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) ( 4,  4, "VC36LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) ( 3,  3, "VC35LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) ( 2,  2, "VC34LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) ( 1,  1, "VC33LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSR2      ) ( 0,  0, "VC32LMS" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (31, 31, "VC31LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (30, 30, "VC30LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (29, 29, "VC29LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (28, 28, "VC28LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (27, 27, "VC27LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (26, 26, "VC26LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (25, 25, "VC25LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (24, 24, "VC24LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (23, 23, "VC23LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (22, 22, "VC22LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (21, 21, "VC21LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (20, 20, "VC20LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (19, 19, "VC19LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (18, 18, "VC18LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (17, 17, "VC17LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (16, 16, "VC16LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (15, 15, "VC15LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (14, 14, "VC14LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (13, 13, "VC13LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (12, 12, "VC12LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (11, 11, "VC11LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) (10, 10, "VC10LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) ( 9,  9, "VC09LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) ( 8,  8, "VC08LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) ( 7,  7, "VC07LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) ( 6,  6, "VC06LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) ( 5,  5, "VC05LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) ( 4,  4, "VC04LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) ( 3,  3, "VC03LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) ( 2,  2, "VC02LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) ( 1,  1, "VC01LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR1     ) ( 0,  0, "VC00LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) (15, 15, "VC47LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) (14, 14, "VC46LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) (13, 13, "VC45LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) (12, 12, "VC44LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) (11, 11, "VC43LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) (10, 10, "VC42LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) ( 9,  9, "VC41LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) ( 8,  8, "VC40LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) ( 7,  7, "VC39LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) ( 6,  6, "VC38LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) ( 5,  5, "VC37LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) ( 4,  4, "VC36LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) ( 3,  3, "VC35LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) ( 2,  2, "VC34LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) ( 1,  1, "VC33LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*VCLMSCR2     ) ( 0,  0, "VC32LMSC", 0x0       , "D"     , vpcl::SPP_ENABLE);
    (*ADOPDIG      ) ( 0,  0, "ADOPDIGn0", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*ADOPDIG      ) ( 1,  1, "ADOPDIGn1", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*ADOPDIG      ) ( 2,  2, "ADOPDIGn2", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*ADOPDIG      ) ( 3,  3, "ADOPDIGn3", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*ADOPDIG      ) ( 4,  4, "ADOPDIGn4", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*ADOPDIG      ) ( 5,  5, "ADOPDIGn5", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*ADOPDIG      ) ( 6,  6, "ADOPDIGn6", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*ADOPDIG      ) ( 7,  7, "ADOPDIGn7", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*ADOPDIG      ) ( 8,  8, "ADOPDIGn8", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*ADOPDIG      ) ( 9,  9, "ADOPDIGn9", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*ADOPDIG      ) (10, 10, "ADOPDIGn10", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*ADOPDIG      ) (11, 11, "ADOPDIGn11", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    for(uint i = 0; i < emNUM_ULLMSR; i++) {
        (*ULLMSR       [i]) ( 1,  0, "ULS"     , 0x0       , "D"     , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_ADTENDCR; i++) {
        (*ADTENDCR     [mFactorIndexADTENDCR[i]]) ( 0,  0, "ADTEND"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_SGVCSP; i++) {
        (*SGVCSP       [i]) ( 5,  0, "VCSP"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_SGVCEP; i++) {
        (*SGVCEP       [i]) ( 5,  0, "VCEP"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_SGSTPCR; i++) {
        (*SGSTPCR      [i]) ( 0,  0, "SGSTP"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_ADENDP; i++) {
        (*ADENDP       [i]) ( 5,  0, "ENDP"    , 0x0       , "D"     , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_SGSR; i++) {
        (*SGSR         [i]) ( 2,  2, "ADTACT"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
        (*SGSR         [i]) ( 1,  1, "SGACT"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_VCULLMTBR; i++) {
        (*VCULLMTBR    [i]) (31, 16, "VCULMTB" , 0x7FFE    , "D"     , vpcl::SPP_ENABLE);
        (*VCULLMTBR    [i]) (15,  0, "VCLLMTB" , 0x0       , "D"     , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_ADTIPR; i++) {
        (*ADTIPR       [mFactorIndexADTIPR[i]]) (20,  0, "ADTIP"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_VCR; i++) {
        (*VCR          [i]) (31, 31, "VCULME"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*VCR          [i]) (30, 30, "VCLLME"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*VCR          [i]) (26, 24, "VCULLMTBS", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*VCR          [i]) (17, 17, "PUE"     , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*VCR          [i]) (16, 16, "PDE"     , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*VCR          [i]) (15, 13, "CNVCLS"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE, "b000,b001,b011,b100,b101,b110");
        (*VCR          [i]) (12, 12, "DFENT"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*VCR          [i]) (11,  8, "DFTAG"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*VCR          [i]) ( 7,  7, "ADIE"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*VCR          [i]) ( 5,  0, "GCTRL"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_SGMCYCR; i++) {
        (*SGMCYCR      [i]) ( 7,  0, "MCYC"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_DIR; i++) {
        (*DIR          [i]) (26, 26, "IDEF"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
        (*DIR          [i]) (25, 25, "WFLG"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
        (*DIR          [i]) (24, 24, "PRTY"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
        (*DIR          [i]) (20, 16, "ID"      , 0x0       , "R"     , vpcl::SPP_ENABLE);
        (*DIR          [i]) (15,  0, "DRn"     , 0x0       , "R"     , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_ADTSTCR; i++) {
        (*ADTSTCR      [mFactorIndexADTSTCR[i]]) ( 0,  0, "ADTST"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_ULLMTBR; i++) {
        (*ULLMTBR      [i]) (31, 16, "ULMTB"   , 0x7FFE    , "D"     , vpcl::SPP_ENABLE);
        (*ULLMTBR      [i]) (15,  0, "LLMTB"   , 0x0       , "D"     , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_SGVCOWR; i++) {
        (*SGVCOWR      [i]) (11,  0, "VCOW"    , 0x0       , "D"     , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_SGVCPR; i++) {
        (*SGVCPR       [i]) (13,  8, "VCEP"    , 0x0       , "D"     , vpcl::SPP_ENABLE);
        (*SGVCPR       [i]) ( 5,  0, "VCSP"    , 0x0       , "D"     , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_DR; i++) {
        (*DR           [i]) (31, 16, "DR1"     , 0x0       , "R"     , vpcl::SPP_ENABLE);
        (*DR           [i]) (15,  0, "DR0"     , 0x0       , "R"     , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_SGCR; i++) {
        (*SGCR         [i]) ( 7,  7, "ADTSTARTE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*SGCR         [i]) ( 6,  6, "ADSTARTE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*SGCR         [i]) ( 5,  5, "SCANMD"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*SGCR         [i]) ( 4,  4, "ADIE"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*SGCR         [i]) ( 1,  0, "TRGMD"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_SGSTCR; i++) {
        (*SGSTCR       [i]) ( 0,  0, "SGST"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_ADTPRR; i++) {
        (*ADTPRR       [mFactorIndexADTPRR[i]]) (20,  0, "ADTPR"   , 0x1FFFFF  , "W|R"   , vpcl::SPP_ENABLE);
    }

    mFileName = "";
    mInstName = name;
    mLineNum = 0;
    mBusWidth = buswidth;
    mBusByteWidth = mBusWidth/8;   // using in BIG ENDIAN
    mIsReset = false;

    // Constructor the callback function of each register
    for (uint i = 0; i < mTotalRegNum; i++) {
        mWrCbAPI[mRegArray[i]->my_p->name()][mRegArray[i]->my_p->name()] = NULL;
        mRdCbAPI[mRegArray[i]->my_p->name()][mRegArray[i]->my_p->name()] = NULL;
    }

    //Constructor the mWrCbAPI, mRdCbAPI variable of each register
    mWrCbAPI["ADHALTR"  ]["HALT"     ] = &Cadc_regif::cb_ADHALTR_HALT;
    mWrCbAPI["ADCR1"    ]["SUSMTD"   ] = &Cadc_regif::cb_ADCR1_SUSMTD;
    mWrCbAPI["MPXCURCR" ]["MSKCFMT"  ] = &Cadc_regif::cb_MPXCURCR_MSKCFMT;
    mWrCbAPI["MPXINTER" ]["ADMPXIE"  ] = &Cadc_regif::cb_MPXINTER_ADMPXIE;
    mWrCbAPI["MPXOWR"   ]["MPXOW"    ] = &Cadc_regif::cb_MPXOWR_MPXOW;
    mWrCbAPI["MPXCMDR"  ]["MPXCMD"   ] = &Cadc_regif::cb_MPXCMDR_MPXCMD;
    mWrCbAPI["ADCR2"    ]["DFMT"     ] = &Cadc_regif::cb_ADCR2_DFMT;
    mWrCbAPI["DFASENTSGER"]["DFENTSG4E"] = &Cadc_regif::cb_DFASENTSGER_DFENTSG4E;
    mWrCbAPI["THSMPSTCR"]["SMPST"    ] = &Cadc_regif::cb_THSMPSTCR_SMPST;
    mWrCbAPI["THSTPCR"  ]["THSTP"    ] = &Cadc_regif::cb_THSTPCR_THSTP;
    mWrCbAPI["THCR"     ]["ASMPMSK"  ] = &Cadc_regif::cb_THCR_ASMPMSK;
    mWrCbAPI["THAHLDSTCR"]["HLDST"    ] = &Cadc_regif::cb_THAHLDSTCR_HLDST;
    mWrCbAPI["THBHLDSTCR"]["HLDST"    ] = &Cadc_regif::cb_THBHLDSTCR_HLDST;
    mWrCbAPI["THACR"    ]["SGS"      ] = &Cadc_regif::cb_THACR_SGS;
    mWrCbAPI["THBCR"    ]["SGS"      ] = &Cadc_regif::cb_THBCR_SGS;
    mWrCbAPI["THER"     ]["TH0E"     ] = &Cadc_regif::cb_THER_TH0E;
    mWrCbAPI["THGSR"    ]["TH0GS"    ] = &Cadc_regif::cb_THGSR_TH0GS;
    mWrCbAPI["SFTCR"    ]["ULEIE"    ] = &Cadc_regif::cb_SFTCR_ULEIE;
    mWrCbAPI["TDCR"     ]["TDE"      ] = &Cadc_regif::cb_TDCR_TDE;
    mWrCbAPI["ODCR"     ]["ODDE"     ] = &Cadc_regif::cb_ODCR_ODDE;
    mWrCbAPI["ECR"      ]["ULEC"     ] = &Cadc_regif::cb_ECR_ULEC;
    mWrCbAPI["SMPCR"    ]["SMPT"     ] = &Cadc_regif::cb_SMPCR_SMPT;
    mWrCbAPI["VCLMINTER1"]["ADUL00IE" ] = &Cadc_regif::cb_VCLMINTER1_ADUL00IE;
    mWrCbAPI["VCLMINTER2"]["ADUL32IE" ] = &Cadc_regif::cb_VCLMINTER2_ADUL32IE;
    mWrCbAPI["VCLMSCR1" ]["VC00LMSC" ] = &Cadc_regif::cb_VCLMSCR1_VC00LMSC;
    mWrCbAPI["VCLMSCR2" ]["VC32LMSC" ] = &Cadc_regif::cb_VCLMSCR2_VC32LMSC;
    mWrCbAPI["ADOPDIG"  ]["ADOPDIGn0"] = &Cadc_regif::cb_ADOPDIG_ADOPDIGn0;

    for(uint i = 0; i < emNUM_VCR; i++) {
        str_tmp.str("");
        str_tmp<<"VCR"<< i;
        mWrCbAPI[str_tmp.str()]["GCTRL"] = &Cadc_regif::cb_VCR_GCTRL;
    }
    for(uint i = 0; i < emNUM_ADENDP; i++) {
        str_tmp.str("");
        str_tmp<<"ADENDP"<< i;
        mWrCbAPI[str_tmp.str()]["ENDP"] = &Cadc_regif::cb_ADENDP_ENDP;
    }
    for(uint i = 0; i < emNUM_ULLMTBR; i++) {
        str_tmp.str("");
        str_tmp<<"ULLMTBR"<< i;
        mWrCbAPI[str_tmp.str()]["ULMTB"] = &Cadc_regif::cb_ULLMTBR_ULMTB;
    }
    for(uint i = 0; i < emNUM_SGSTCR; i++) {
        str_tmp.str("");
        str_tmp<<"SGSTCR"<< i;
        mWrCbAPI[str_tmp.str()]["SGST"] = &Cadc_regif::cb_SGSTCR_SGST;
    }
    for(uint i = 0; i < emNUM_SGSTPCR; i++) {
        str_tmp.str("");
        str_tmp<<"SGSTPCR"<< i;
        mWrCbAPI[str_tmp.str()]["SGSTP"] = &Cadc_regif::cb_SGSTPCR_SGSTP;
    }
    for(uint i = 0; i < emNUM_ADTSTCR; i++) {
        str_tmp.str("");
        str_tmp<<"ADTSTCR"<< mFactorIndexADTSTCR[i];
        mWrCbAPI[str_tmp.str()]["ADTST"] = &Cadc_regif::cb_ADTSTCR_ADTST;
    }
    for(uint i = 0; i < emNUM_ADTENDCR; i++) {
        str_tmp.str("");
        str_tmp<<"ADTENDCR"<< mFactorIndexADTENDCR[i];
        mWrCbAPI[str_tmp.str()]["ADTEND"] = &Cadc_regif::cb_ADTENDCR_ADTEND;
    }
    for(uint i = 0; i < emNUM_SGCR; i++) {
        str_tmp.str("");
        str_tmp<<"SGCR"<< i;
        mWrCbAPI[str_tmp.str()]["ADIE"] = &Cadc_regif::cb_SGCR_ADIE;
    }
    for(uint i = 0; i < emNUM_SGVCSP; i++) {
        str_tmp.str("");
        str_tmp<<"SGVCSP"<< i;
        mWrCbAPI[str_tmp.str()]["VCSP"] = &Cadc_regif::cb_SGVCSP_VCSP;
    }
    for(uint i = 0; i < emNUM_SGVCEP; i++) {
        str_tmp.str("");
        str_tmp<<"SGVCEP"<< i;
        mWrCbAPI[str_tmp.str()]["VCEP"] = &Cadc_regif::cb_SGVCEP_VCEP;
    }
    for(uint i = 0; i < emNUM_SGMCYCR; i++) {
        str_tmp.str("");
        str_tmp<<"SGMCYCR"<< i;
        mWrCbAPI[str_tmp.str()]["MCYC"] = &Cadc_regif::cb_SGMCYCR_MCYC;
    }
    for(uint i = 0; i < emNUM_SGVCPR; i++) {
        str_tmp.str("");
        str_tmp<<"SGVCPR"<< i;
        mWrCbAPI[str_tmp.str()]["VCSP"] = &Cadc_regif::cb_SGVCPR_VCSP;
    }
    for(uint i = 0; i < emNUM_SGVCOWR; i++) {
        str_tmp.str("");
        str_tmp<<"SGVCOWR"<< i;
        mWrCbAPI[str_tmp.str()]["VCOW"] = &Cadc_regif::cb_SGVCOWR_VCOW;
    }
    for(uint i = 0; i < emNUM_ADTIPR; i++) {
        str_tmp.str("");
        str_tmp<<"ADTIPR"<< mFactorIndexADTIPR[i];
        mWrCbAPI[str_tmp.str()]["ADTIP"] = &Cadc_regif::cb_ADTIPR_ADTIP;
    }
    for(uint i = 0; i < emNUM_ADTPRR; i++) {
        str_tmp.str("");
        str_tmp<<"ADTPRR"<< mFactorIndexADTPRR[i];
        mWrCbAPI[str_tmp.str()]["ADTPR"] = &Cadc_regif::cb_ADTPRR_ADTPR;
    }
    for(uint i = 0; i < emNUM_ULLMSR; i++) {
        str_tmp.str("");
        str_tmp<<"ULLMSR"<< i;
        mWrCbAPI[str_tmp.str()]["ULS"] = &Cadc_regif::cb_ULLMSR_ULS;
    }
    for(uint i = 0; i < emNUM_VCULLMTBR; i++) {
        str_tmp.str("");
        str_tmp<<"VCULLMTBR"<< i;
        mWrCbAPI[str_tmp.str()]["VCULMTB"] = &Cadc_regif::cb_VCULLMTBR_VCULMTB;
    }
    InitLocalVal();
    #ifdef USE_WEB_SIM
    InitializeRegValueID();
    mNotifyRegValueIDAPI = &Cadc_regif::NotifyRegValueID;
    #endif
}

/// Destructor: delete pointers
/// @return none
Cadc_regif::~Cadc_regif()
{
    // Delete registers' pointer
    for (uint i = 0 ; i < mTotalRegNum ; i++) {
        delete mRegArray[i]->my_p;
        mRegArray[i]->prev = NULL;
        delete mRegArray[i];
    }
    delete [] mRegMap;
    delete [] mRegArray;
}

/// Mask unselected bit
/// @return selected value
Cadc_regif::uint Cadc_regif::bit_select(cuint val,    ///< [in] Writting address
                                        cuint start,  ///< [in] start bit position
                                        cuint end)    ///< [in] end bit position
{
    uint ret_val = val;
    if (end - start + 1 < 32) {
        ret_val = (val>>start) & (uint)((1<<(end-start+1))-1);
    }
    return ret_val;
}

/// Write the value to requested module register
/// @return true if writing transaction is finished normally
bool Cadc_regif::reg_wr(cuint addr,                    ///< [in] Writting address
                        const unsigned char *p_data,   ///< [in] Writing data
                        cuint size)                    ///< [in] Data size (byte)
{
    if (size == 0) {
        re_printf("error", "Invalid access size: 0 byte\n");
        return false;
    }
    #ifdef IS_MODELED_ENDIAN_BIG
    if ((addr % mBusByteWidth) + size > mBusByteWidth) {
        re_printf("error", "Invalid access address 0x%08X with access size %d bytes\n", addr, size);
        return false;
    }
    #endif

    bool ret_val = false;
    assert(p_data != NULL);
    ret_val = reg_wr_process (addr, p_data, size, false);
    return ret_val;
}

/// Read the register value of requested module
/// @return true if reading transaction is finished normally
bool Cadc_regif::reg_rd(cuint addr,              ///< [in]  Reading address
                        unsigned char *p_data,   ///< [out] Reading data
                        cuint size)              ///< [in]  Data size (byte)
{
    if (size == 0) {
        re_printf("error", "Invalid access size: 0 byte\n");
        return false;
    }
    #ifdef IS_MODELED_ENDIAN_BIG
    if ((addr % mBusByteWidth) + size > mBusByteWidth) {
        re_printf("error", "Invalid access address 0x%08X with access size %d bytes\n", addr, size);
        return false;
    }
    #endif

    bool ret_val = false;
    assert(p_data != NULL);
    ret_val = reg_rd_process (addr, p_data, size, false);
    return ret_val;
}

/// Write the value to requested module register
/// @return true if writing transaction is finished normally
bool Cadc_regif::reg_wr_dbg(cuint addr,                    ///< [in] Writting address
                            const unsigned char *p_data,   ///< [in] Writing data
                            cuint size)                    ///< [in] Data size (byte)
{
    if (size == 0) {
        re_printf("error", "Invalid access size: 0 byte\n");
        return false;
    }
    #ifdef IS_MODELED_ENDIAN_BIG
    if ((addr % mBusByteWidth) + size > mBusByteWidth) {
        re_printf("error", "Invalid access address 0x%08X with access size %d bytes\n", addr, size);
        return false;
    }
    #endif

    bool ret_val = false;
    assert(p_data != NULL);
    ret_val = reg_wr_process (addr, p_data, size, true);
    return ret_val;
}

/// Read the register value of requested module
/// @return true if reading transaction is finished normally
bool Cadc_regif::reg_rd_dbg(cuint addr,              ///< [in]  Reading address
                            unsigned char *p_data,   ///< [out] Reading data
                            cuint size)              ///< [in]  Data size (byte)
{
    if (size == 0) {
        re_printf("error", "Invalid access size: 0 byte\n");
        return false;
    }
    #ifdef IS_MODELED_ENDIAN_BIG
    if ((addr % mBusByteWidth) + size > mBusByteWidth) {
        re_printf("error", "Invalid access address 0x%08X with access size %d bytes\n", addr, size);
        return false;
    }
    #endif

    bool ret_val = false;
    assert(p_data != NULL);
    ret_val = reg_rd_process (addr, p_data, size, true);
    return ret_val;
}

/// Write the value to requested module register
/// @return true if writing transaction is finished normally
bool Cadc_regif::reg_wr_process(cuint addr,                   ///< [in] Writting address
                                const unsigned char *p_data,  ///< [in] Writing data
                                cuint size,                   ///< [in] Data size (byte)
                                bool IsDbgFunc)               ///< [in] Flag indicate reg_rd or reg_rd_dbg
{
    if (mIsReset) {
        re_printf("warning", "Cannot write during reset period\n");
        return true;
    }
    uint tmp_addr = addr;
    #ifdef IS_MODELED_ENDIAN_BIG
    if (size < mBusByteWidth) {
        tmp_addr = addr ^ (mBusByteWidth - size);
    }
    #endif
    bool ret_val = false;
    bool valid_addr = false;
    assert(p_data != NULL);
    std::list<uint> list_index;
    uint masked_addr = bit_select(tmp_addr, 0, 11-1);
    uint access_addr = masked_addr;
    while (masked_addr + size > access_addr) {
        int reg_index = get_reg_index(access_addr);
        if (reg_index != -1) {
            vpcl::re_register *reg_p = mRegArray[reg_index]->my_p; 
            if (IsDbgFunc || valid_addr || ChkSize(mRegArray[reg_index]->wacc_size, size, tmp_addr, true)) {
                valid_addr = true;
                list_index.push_back(reg_index);
            } else {
                re_printf("error", "Writing access size to %s at address 0x%08X is wrong: %d byte(s).\n", reg_p->name().c_str(), tmp_addr, size);
                return false;
            }
            access_addr = reg_p->addr() + mRegArray[reg_index]->length;
        } else {
            if (IsDbgFunc || valid_addr) {
                access_addr += 1;
            } else {
                access_addr += size; // To break out while loop
            }
        }
    }
    if (valid_addr) {
        std::list<uint>::iterator it;
        for (it=list_index.begin() ; it!=list_index.end() ; it++) {
            access_addr = masked_addr;
            uint d_size = size;
            uint index = 0;
            if (masked_addr < mRegArray[(*it)]->my_p->addr()) { // adjust access address & index
                access_addr = mRegArray[(*it)]->my_p->addr();
                index = mRegArray[(*it)]->my_p->addr() - masked_addr;
            }
            if ((masked_addr + size) < (mRegArray[(*it)]->my_p->addr() + mRegArray[(*it)]->length)) { // adjust access size
                d_size = masked_addr + size - access_addr;
            } else { // adjust access size
                d_size = (mRegArray[(*it)]->my_p->addr() + mRegArray[(*it)]->length) - access_addr;
            }
            if (size > mRegArray[(*it)]->length) { // adjust index for big endianess
                #ifdef IS_MODELED_ENDIAN_BIG
                index = index ^ (size - mRegArray[(*it)]->length);
                #endif
            }
            ret_val = reg_wr_func(tmp_addr - masked_addr + access_addr, &(p_data[index]), d_size, (*it), IsDbgFunc);
        }
    } else {
        if (!IsDbgFunc) {
            re_printf("error", "Invalid access address 0x%08X\n", tmp_addr);
        } else {
            ret_val = true;
        }
    }
    return ret_val;
}

/// Read the register value of requested module
/// @return true if reading transaction is finished normally
bool Cadc_regif::reg_rd_process(cuint addr,              ///< [in]  Reading address
                                unsigned char *p_data,   ///< [out] Reading data
                                cuint size,              ///< [in]  Data size (byte)
                                bool IsDbgFunc)          ///< [in]  Flag indicate reg_rd or reg_rd_dbg
{
    uint tmp_addr = addr;
    #ifdef IS_MODELED_ENDIAN_BIG
    if (size < mBusByteWidth) {
        tmp_addr = addr ^ (mBusByteWidth - size);
    }
    #endif
    bool ret_val = false;
    bool valid_addr = false;
    assert(p_data != NULL);
    std::list<uint> list_index;
    uint masked_addr = bit_select(tmp_addr, 0, 11-1);
    uint access_addr = masked_addr;
    while (masked_addr + size > access_addr) {
        int reg_index = get_reg_index(access_addr);
        if (reg_index != -1) {
            vpcl::re_register *reg_p = mRegArray[reg_index]->my_p; 
            if (IsDbgFunc || valid_addr || ChkSize(mRegArray[reg_index]->racc_size, size, tmp_addr, false)) {
                valid_addr = true;
                list_index.push_back(reg_index);
            } else {
                re_printf("error", "Reading access size to %s at address 0x%08X is wrong: %d byte(s).\n", reg_p->name().c_str(), tmp_addr, size);
                return false;
            }
            access_addr = reg_p->addr() + mRegArray[reg_index]->length;
        } else {
            if (mAPBAccessMode || IsDbgFunc || valid_addr) {
                access_addr += 1;
            } else {
                access_addr += size;  // To break out while loop
            }
        }
    }
    if (valid_addr) {
        std::list<uint>::iterator it;
        for (it=list_index.begin() ; it!=list_index.end() ; it++) {
            access_addr = masked_addr;
            uint d_size = size;
            uint index = 0;
            if (masked_addr < mRegArray[(*it)]->my_p->addr()) { // adjust access address & index
                access_addr = mRegArray[(*it)]->my_p->addr();
                index = mRegArray[(*it)]->my_p->addr() - masked_addr;
            }
            if ((masked_addr + size) < (mRegArray[(*it)]->my_p->addr() + mRegArray[(*it)]->length)) { // adjust access size
                d_size = masked_addr + size - access_addr;
            } else { // adjust access size
                d_size = (mRegArray[(*it)]->my_p->addr() + mRegArray[(*it)]->length) - access_addr;
            }
            if (size > mRegArray[(*it)]->length) { // adjust index for big endianess
                #ifdef IS_MODELED_ENDIAN_BIG
                index = index ^ (size - mRegArray[(*it)]->length);
                #endif
            }
            ret_val = reg_rd_func(tmp_addr - masked_addr + access_addr, &(p_data[index]), d_size, (*it), IsDbgFunc);
        }
    } else {
        if (!(IsDbgFunc || mAPBAccessMode)) {
            memset(p_data, 0, size);
            re_printf("error", "Invalid access address 0x%08X\n", tmp_addr);
        } else {
            memset(p_data, 0, size);
            ret_val = true;
        }
    }
    return ret_val;
}

/// Process reading function
/// @return true if reading successfully
bool Cadc_regif::reg_rd_func(cuint addr,                     ///< [in]  Reading address
                             unsigned char *p_data,          ///< [out] Reading data
                             cuint size,                     ///< [in]  Data size (byte)
                             cuint reg_index,                ///< [in]  Register index
                             bool IsDbgFunc)                 ///< [in]  Flag indicate reg_rd or reg_rd_dbg
{
    vpcl::re_register* Register = mRegArray[reg_index]->my_p;
    assert(Register != NULL);
    
    uint pst_data = 0;
    uint reg_length = mRegArray[reg_index]->length;
    uint start_pos = 0;
    uint mask_size = (1 << (reg_length/2)) - 1;
    if (size < reg_length) {
        #ifdef IS_MODELED_ENDIAN_BIG
        start_pos =  (reg_length - size)*8 - (addr & mask_size)*8; // Start bit position
        #else
        start_pos =  (addr & mask_size)*8;  // Start bit position
        #endif
    }
    if (!IsDbgFunc) {
        if (mIsReset) {
            re_printf("warning", "Cannot launch call-back function during reset period\n");
        }else {
            if (size < reg_length) {
                re_printf("warning","Should read all bit in a register\n");
            }
            
            pst_data = Register->read();

        }
    }
    pst_data = (uint)(*Register);
    if (size < reg_length) {
        uint read_data = 0;
        if (((reg_length%2 == 0) && (reg_length%size == 0) && ((addr&mask_size)%size == 0)) 
         || (!IsDbgFunc)) {
            for (uint i = start_pos; i < (8*size + start_pos); i++) {
                read_data |= (pst_data & (1 << i)) >> start_pos;
            }
            pst_data = read_data;
        }
    }

    assert(p_data != NULL);
    memcpy(p_data, &pst_data, size);
    DumpRegMsg("R", Register->name(), "", size, addr, 0, 0, pst_data, mRegArray[reg_index]->length*8);
    for (vpcl::bit_info *it=Register->mBitInfo ; it!=NULL ; it=it->next) {
        uint val = (uint)(*Register);
        val = bit_select(val, it->mStartAddr, it->mEndAddr);
        if (mDumpBitInfo) {
            DumpRegMsg("R", Register->name(), it->name(), size, addr, 0, 0, val, it->mEndAddr - it->mStartAddr + 1);
        }
    }
    return true;
}

/// Process writing function
/// @return true if writing successfully
bool Cadc_regif::reg_wr_func(cuint addr,                       ///< [in] Writting address
                             const unsigned char *p_data,      ///< [in] Writing data
                             cuint size,                       ///< [in] Data size (byte)
                             cuint reg_index,                  ///< [in] Register index
                             bool IsDbgFunc)                   ///< [in] Flag indicate reg_wr or reg_wr_dbg
{
    vpcl::re_register* Register = mRegArray[reg_index]->my_p;
    uint pre_data = 0;
    uint data = 0;
    uint reg_length = mRegArray[reg_index]->length;
    uint start_pos = 0;
    assert ((p_data != NULL) && (Register != NULL));
    memcpy(&data, p_data, size);
    uint wr_data = data;
    if (size < reg_length) {
        uint mask_size = (1 << (reg_length/2)) - 1;
        if (((reg_length%2 == 0) && (reg_length%size == 0) && ((addr&mask_size)%size == 0)) 
         || (!IsDbgFunc)) {
            uint new_data = (uint)(*Register);  // For writing to register
            uint written_data = 0;         // For transferring to callback function
            #ifdef IS_MODELED_ENDIAN_BIG
            start_pos =  (reg_length - size)*8 - (addr & mask_size)*8; // Start bit position
            #else
            start_pos =  (addr & mask_size)*8;  // Start bit position
            #endif
            for (uint i = start_pos; i < (8*size + start_pos); i++) {
                new_data = (new_data & (~(1 << i))) | ((data << start_pos) & (1 << i));
                written_data = (written_data & (~(1 << i))) | ((data << start_pos) & (1 << i));
            }
            data = new_data;
        }
    }

    if (!mRegArray[reg_index]->block || IsDbgFunc){
        pre_data = (uint)(*Register);
        if (IsDbgFunc) {
            bool backup_warning = Register->mMessageLevel["warning"];
            bool backup_error = Register->mMessageLevel["error"];
            Register->mMessageLevel["warning"] = false;
            Register->mMessageLevel["error"]   = false;

            Register->write(data);

            Register->mMessageLevel["warning"] = backup_warning;
            Register->mMessageLevel["error"]   = backup_error;
        } else {
            Register->write(data);
        }
        UpdateLocalVal(Register->addr());
        DumpRegMsg("W", Register->name(), "", size, addr, wr_data, pre_data, (uint)(*Register), mRegArray[reg_index]->length*8);
        for (vpcl::bit_info *it=Register->mBitInfo ; it!=NULL ; it=it->next) {
            uint val = (uint)(*Register);
            val = bit_select(val, it->mStartAddr, it->mEndAddr);
            uint pre_val = pre_data;
            pre_val = bit_select(pre_val, it->mStartAddr, it->mEndAddr);
            if (mDumpBitInfo) {
                DumpRegMsg("W", Register->name(), it->name(), size, addr, (unsigned int)*it, pre_val, val, it->mEndAddr - it->mStartAddr + 1);
            }
            if ((mWrCbAPI[Register->name()][it->name()]) != NULL) {
                (this->*(mWrCbAPI[Register->name()][it->name()]))(RegCBstr(mRegArray[reg_index]->channel, true, size, pre_data, data));
            }
        }
    } else {
        re_printf("warning","%s is blocked writing from Bus I/F.\n", Register->name().c_str());
    }
    return true;
}

/// Check access size
/// @@return true if detect_size equal expect_size
bool Cadc_regif::ChkSize(std::string expect_size, cuint detect_size, cuint addr, bool is_wr)
{
    std::vector<std::string> arg_vec = Str2Vec(expect_size, '|');
    std::vector<std::string>::iterator it;
    char *err_p = NULL;
    uint size = 0;
    if (detect_size > mBusByteWidth) {
        re_printf("error", "Invalid access size: %d bytes\n", detect_size);
        return false;
    }
    if (addr%detect_size != 0) {
        re_printf("error", "Invalid access address 0x%08X with access size %d bytes\n", addr, detect_size);
        return false;
    }
    if (is_wr || !(mAPBAccessMode)) {
        for (it = arg_vec.begin(); it != arg_vec.end(); it++) {
            errno = 0; size = (uint) strtoul((*it).c_str(), &err_p, 0);
            assert(err_p != NULL);
            if (errno != ERANGE && *err_p == '\0') {
                if ((size/8) == detect_size) {
                    return true;
                }
            }
        }
    } else {
        return true;
    }
    return false;
}

/// Initialize reg_handle_command variables
/// @return none
void Cadc_regif::CommandInit()
{
    mDumpRegisterRW = false;
    mAPBAccessMode  = false;
    mDumpBitInfo    = true;
    mMessageLevel["fatal"]   = true;
    mMessageLevel["error"]   = true;
    mMessageLevel["warning"] = false;
    mMessageLevel["info"]    = false;
}

/// Process reg_handle_command command
/// @return string
std::string Cadc_regif::reg_handle_command(const std::vector<std::string>& args)
{
    std::string ret = "";
    std::string err_msg = "Error ("   + mInstName + ") ";   // error message
    if (args[0] == "reg") {
        if (args[1] == "help") {
            ret += "    --- reg ---\n";
            ret += "    reg MessageLevel <fatal|error|warning|info> Select debug message level (Default: fatal|error)\n";
            ret += "    reg DumpRegisterRW <true/false>             Select dump register access information  (Default: false)\n";
            ret += "    reg APBAccessMode <true/false>              Select for APB access mode when reading (Default: false)\n";
            ret += "    reg DumpBitInfo <true/false>                Select for dump bit information (Default: true)\n";
            ret += "    reg <register_name> MessageLevel <fatal|error|warning|info> Select debug message level for register (Default: fatal|error)\n";
            ret += "    reg <register_name> force <value>           Force register with setting value\n";
            ret += "    reg <register_name> release                 Release register from force value\n";
            ret += "    reg <register_name> <value>                 Write a value into register\n";
            ret += "    reg <register_name>                         Read value of register\n";
            ret += "    reg help                                    Show a direction\n";
        } else if (args[1] == "DumpRegisterRW") {
            if (args.size() == 2) {
                ret = (mDumpRegisterRW)? "true" : "false";
            } else if (args.size() == 3) {
                if (args[2] == "true") {
                    mDumpRegisterRW = true;
                } else if (args[2] == "false") {
                    mDumpRegisterRW = false;
                } else {
                    ret = err_msg + "DumpRegisterRW command needs an argument [true/false]\n";
                }
            } else {
                ret = err_msg + "DumpRegisterRW has too much arguments\n";
            }
        } else if (args[1] == "APBAccessMode") {
            if (args.size() == 2) {
                ret = (mAPBAccessMode)? "true" : "false";
            } else if (args.size() == 3) {
                if (args[2] == "true") {
                    mAPBAccessMode = true;
                } else if (args[2] == "false") {
                    mAPBAccessMode = false;
                } else {
                    ret = err_msg + "APBAccessMode command needs an argument [true/false]\n";
                }
            } else {
                ret = err_msg + "APBAccessMode has too much arguments\n";
            }
        } else if (args[1] == "DumpBitInfo") {
            if (args.size() == 2) {
                ret = (mDumpBitInfo)? "true" : "false";
            } else if (args.size() == 3) {
                if (args[2] == "true") {
                    mDumpBitInfo = true;
                } else if (args[2] == "false") {
                    mDumpBitInfo = false;
                } else {
                    ret = err_msg + "DumpBitInfo command needs an argument [true/false]\n";
                }
            } else {
                ret = err_msg + "DumpBitInfo has too much arguments\n";
            }
        } else if (args[1] == "MessageLevel") {
            // read mode
            if (args.size() == 2) {
                std::map<std::string, bool>::iterator it;
                for (it = mMessageLevel.begin(); it != mMessageLevel.end(); it++) {
                    if ( it->second ) {
                        ret += " " + it->first;
                    }
                }
            // write mode
            } else if (args.size() == 3) {
                std::vector<std::string> arg_vec = Str2Vec(args[2], '|');
                std::map<std::string, bool>::iterator msgit;
                for (msgit =mMessageLevel.begin(); msgit != mMessageLevel.end(); msgit++) {
                    msgit->second = false;
                }
                std::vector<std::string>::iterator it;
                for (it = arg_vec.begin(); it != arg_vec.end(); it++) {
                    mMessageLevel[*it] = true;
                }
            } else {
                ret = err_msg + "MessageLevel has too much arguments\n";
            }
        } else {
            bool matched = false;
            for (uint i = 0; i < mTotalRegNum; i++) {
                if (args[1] == mRegArray[i]->my_p->name()) {
                    ret = AccessRegCommand(args, mRegArray[i]->my_p, mRegArray[i]->block);
                    matched = true;
                    break;
                }
            }
            if (!matched) {
                ret = err_msg + "Register name " + (std::string)args[1] + " is invalid\n";
            }
        }
    }
    return ret;
}

/// process reg_handle_command of "reg" parameter
/// @return string
std::string Cadc_regif::AccessRegCommand(const std::vector<std::string>& args, vpcl::re_register *Register, bool &BlockReg)
{
    std::string ret = "";
    char *err_p = NULL;
    std::string err_msg = "Error ("   + mInstName + ") ";   // error message
    uint data = 0;
    std::ostringstream str_tmp;
    assert(Register != NULL);
    if (args.size() == 2) {
        data = (uint)(*Register);
        str_tmp<<std::setw(14)<<std::left<<(Register->name());
        str_tmp<<"0x"<<std::setw(8)<<std::hex<<std::uppercase<<std::left<<data<<"\n";
        ret = str_tmp.str();
    } else if ((args.size() == 3) && (args[2] == "release")) {
        BlockReg = false;
    } else if ((args.size() == 4) && (args[2] == "force")) {
        errno = 0; data = (uint) strtoul(args[3].c_str(), &err_p, 0);
        assert(err_p != NULL);
        if (errno != ERANGE && *err_p == '\0') {
            *Register = data;
            BlockReg = true;
            UpdateLocalVal(Register->addr());
        } else {
            ret = err_msg + "[" + Register->name() + "] Invalid force value\n";
        }
    } else if ((args.size() >= 3) && (args[2] == "MessageLevel")) {
        if (args.size() == 3) {
            ret = Register->name() + " ";
            ret += Register->GetMessageLevel();
        } else if (args.size() == 4) {
            std::map<std::string, bool> MessageLevel;
            std::vector<std::string> arg_vec = Str2Vec(args[3], '|');
            std::vector<std::string>::iterator it;
            for (it = arg_vec.begin(); it != arg_vec.end(); it++) {
                MessageLevel[*it] = true;
            }
            Register->SetMessageLevel(MessageLevel);
        } else {
            ret = err_msg + "[" + Register->name() + "] MessageLevel has too much arguments\n";
        }
    } else if ((args.size() == 3) && (args[2] != "release")) {
        errno = 0; data = (uint) strtoul(args[2].c_str(), &err_p, 0);
        if (errno != ERANGE && *err_p == '\0') {
            *Register = data;
            UpdateLocalVal(Register->addr());
        } else {
            ret = err_msg + "[" + Register->name() + "] Invalid write value\n";
        }
    } else {
        ret = err_msg + "Wrong command : ";
        for (uint index = 0; index < args.size(); index ++) {
            ret += args[index] + " ";
        }
    }
    return ret;
}

#ifdef USE_WEB_SIM
/// Build register value ID library
/// @return none
void Cadc_regif::InitializeRegValueID()
{//{{{
    vpcl::bit_info* bit_ref[emBitNum] = { };

    for (unsigned int bit = 0; bit < emBitNum; bit++) {
        // Construct bit_info array
        mBitInfoPtr[bit] = bit_ref[bit];
        // Initial value of target bits
        mTargetRegVal[bit] = *(mBitInfoPtr[bit]);
    }

    // Construct mRegValueIDLib
    int bit_val[emRegIDNum][emBitNum] = { };

}//}}}

/// Calculate register value
/// @return none
void Cadc_regif::CalcTargetRegVal(void)
{//{{{
    bool is_update = false;
    unsigned int value = 0;
    for (unsigned int bit = 0; bit < emBitNum; bit++) {
        value = *(mBitInfoPtr[bit]);
        if (mTargetRegVal[bit] != value) {
            mTargetRegVal[bit] = value;
            is_update = true;
        }
    }
    if (is_update) {
        IssueRegValueID();
    }
}//}}}

/// Send register value ID to IP core
/// @return none
void Cadc_regif::IssueRegValueID(void)
{//{{{
    for (unsigned int id = 0; id < emRegIDNum; id++) {
        unsigned int bit;
        for (bit = 0; bit < emBitNum; bit++) {
            if (mRegValueIDLib[bit].BitVal[bit] > -1) { // In case that BitVal = "-" (dont care)
                if (mTargetRegVal[bit] != (unsigned int)mRegValueIDLib[id].BitVal[bit]) {
                    bit = emBitNum + 1; // Break the loop
                }
            }
        }
        // when all fields of current ID are matched, issue RegValueID
        if (bit == emBitNum) {
            (this->*(mNotifyRegValueIDAPI))(mRegValueIDLib[id].RegValueID);
            id = emRegIDNum; // Break the loop
        }
    }
}//}}}
#endif

/// Initialize local variables
/// @return none
void Cadc_regif::InitLocalVal()
{
    // Initialize local variables
    for(uint i = 0; i < emNUM_VCR;        i++) {
        VCR_VCULME  [i] = 0x0;
        VCR_VCLLME  [i] = 0x0;
        VCR_VCULLMTBS[i] = 0x0;
        VCR_PUE     [i] = 0x0;
        VCR_PDE     [i] = 0x0;
        VCR_CNVCLS  [i] = 0x0;
        VCR_DFENT   [i] = 0x0;
        VCR_DFTAG   [i] = 0x0;
        VCR_ADIE    [i] = 0x0;
        VCR_GCTRL   [i] = 0x0;
    }
    for(uint i = 0; i < emNUM_DR;         i++) {
        DR_DR1      [i] = 0x0;
        DR_DR0      [i] = 0x0;
    }
    for(uint i = 0; i < emNUM_DIR;        i++) {
        DIR_IDEF    [i] = 0x0;
        DIR_WFLG    [i] = 0x0;
        DIR_PRTY    [i] = 0x0;
        DIR_ID      [i] = 0x0;
        DIR_DRn     [i] = 0x0;
    }
    ADHALTR_HALT = 0x0;
    ADCR1_SUSMTD = 0x0;
    MPXCURCR_MSKCFMT = 0x0;
    MPXINTER_ADMPXIE = 0x0;
    MPXCURR_MSKC = 0x0;
    MPXCURR_MPXCMD = 0x0;
    MPXCURR_MPXCUR = 0x0;
    MPXOWR_MPXOW = 0x0;
    MPXCMDR_MPXCMD = 0x0;
    ADCR2_DFMT   = 0x0;
    ADCR2_ADDNT  = 0x0;
    DFASENTSGER_DFENTSG4E = 0x0;
    DFASENTSGER_DFENTSG3E = 0x0;
    DFASENTSGER_DFENTSG2E = 0x0;
    DFASENTSGER_DFENTSG1E = 0x0;
    DFASENTSGER_DFENTSG0E = 0x0;
    DFASENTSGER_ASENTSG4E = 0x0;
    DFASENTSGER_ASENTSG3E = 0x0;
    DFASENTSGER_ASENTSG2E = 0x0;
    DFASENTSGER_ASENTSG1E = 0x0;
    DFASENTSGER_ASENTSG0E = 0x0;
    for(uint i = 0; i < emNUM_ADENDP;     i++) {
        ADENDP_ENDP [i] = 0x0;
    }
    THSMPSTCR_SMPST = 0x0;
    THSTPCR_THSTP = 0x0;
    THCR_ASMPMSK = 0x0;
    THAHLDSTCR_HLDST = 0x0;
    THBHLDSTCR_HLDST = 0x0;
    THACR_HLDCTE = 0x0;
    THACR_HLDTE  = 0x0;
    THACR_SGS    = 0x0;
    THBCR_HLDCTE = 0x0;
    THBCR_HLDTE  = 0x0;
    THBCR_SGS    = 0x0;
    THER_TH5E    = 0x0;
    THER_TH4E    = 0x0;
    THER_TH3E    = 0x0;
    THER_TH2E    = 0x0;
    THER_TH1E    = 0x0;
    THER_TH0E    = 0x0;
    THGSR_TH5GS  = 0x0;
    THGSR_TH4GS  = 0x0;
    THGSR_TH3GS  = 0x0;
    THGSR_TH2GS  = 0x0;
    THGSR_TH1GS  = 0x0;
    THGSR_TH0GS  = 0x0;
    THOMSR_KEY   = 0x0;
    THOMSR_THOMS = 0x0;
    SFTCR_SYNCEIE = 0x0;
    SFTCR_RDCLRE = 0x0;
    SFTCR_ULEIE  = 0x0;
    SFTCR_OWEIE  = 0x0;
    SFTCR_PEIE   = 0x0;
    SFTCR_IDEIE  = 0x0;
    TDCR_TDE     = 0x0;
    TDCR_TDLV    = 0x0;
    ODCR_ODDE    = 0x0;
    ODCR_DSCE    = 0x0;
    ODCR_ODE     = 0x0;
    ODCR_ODPW    = 0x0;
    for(uint i = 0; i < emNUM_ULLMTBR;    i++) {
        ULLMTBR_ULMTB[i] = 0x7FFE;
        ULLMTBR_LLMTB[i] = 0x0;
    }
    ECR_SYNCEC   = 0x0;
    ECR_ULEC     = 0x0;
    ECR_OWEC     = 0x0;
    ECR_PEC      = 0x0;
    ECR_IDEC     = 0x0;
    ULER_ULE     = 0x0;
    ULER_ULECAP  = 0x0;
    OWER_OWE     = 0x0;
    OWER_OWECAP  = 0x0;
    PER_PE       = 0x0;
    PER_PECAP    = 0x0;
    IDER_IDE     = 0x0;
    IDER_IDECAP  = 0x0;
    SYNCER_SYNCE = 0x0;
    SMPCR_BUFAMPD = 0x0;
    SMPCR_SMPT13_14 = 0x0;
    SMPCR_SMPTS  = 0x0;
    SMPCR_SMPT8_11 = 0x0;
    SMPCR_SMPT   = 0x0;
    TRMCR_TRMS   = 0x0;
    TRMCR_TRMTTUNE = 0x0;
    TRMCR_TRMBTUNE = 0x0;
    TRMCR_TRMATUNE = 0x0;
    TRMCR_TRMT   = 0x0;
    TRMCR_TRMB   = 0x0;
    TRMCR_TRMA   = 0x0;
    ADTSTRA_ADTST = 0x0;
    ADTSTRB_ADVAL = 0x0;
    ADTSTRC_CKSTP = 0x0;
    ADTSTRC_ADMD = 0x0;
    for(uint i = 0; i < emNUM_SGSTCR;     i++) {
        SGSTCR_SGST [i] = 0x0;
    }
    for(uint i = 0; i < emNUM_SGSTPCR;    i++) {
        SGSTPCR_SGSTP[i] = 0x0;
    }
    for(uint i = 0; i < emNUM_ADTSTCR;    i++) {
        ADTSTCR_ADTST[mFactorIndexADTSTCR[i]] = 0x0;
    }
    for(uint i = 0; i < emNUM_ADTENDCR;   i++) {
        ADTENDCR_ADTEND[mFactorIndexADTENDCR[i]] = 0x0;
    }
    for(uint i = 0; i < emNUM_SGCR;       i++) {
        SGCR_ADTSTARTE[i] = 0x0;
        SGCR_ADSTARTE[i] = 0x0;
        SGCR_SCANMD [i] = 0x0;
        SGCR_ADIE   [i] = 0x0;
        SGCR_TRGMD  [i] = 0x0;
    }
    for(uint i = 0; i < emNUM_SGVCSP;     i++) {
        SGVCSP_VCSP [i] = 0x0;
    }
    for(uint i = 0; i < emNUM_SGVCEP;     i++) {
        SGVCEP_VCEP [i] = 0x0;
    }
    for(uint i = 0; i < emNUM_SGMCYCR;    i++) {
        SGMCYCR_MCYC[i] = 0x0;
    }
    for(uint i = 0; i < emNUM_SGVCPR;     i++) {
        SGVCPR_VCEP [i] = 0x0;
        SGVCPR_VCSP [i] = 0x0;
    }
    for(uint i = 0; i < emNUM_SGVCOWR;    i++) {
        SGVCOWR_VCOW[i] = 0x0;
    }
    for(uint i = 0; i < emNUM_SGSR;       i++) {
        SGSR_ADTACT [i] = 0x0;
        SGSR_SGACT  [i] = 0x0;
    }
    for(uint i = 0; i < emNUM_ADTIPR;     i++) {
        ADTIPR_ADTIP[mFactorIndexADTIPR[i]] = 0x0;
    }
    for(uint i = 0; i < emNUM_ADTPRR;     i++) {
        ADTPRR_ADTPR[mFactorIndexADTPRR[i]] = 0x1FFFFF;
    }
    for(uint i = 0; i < emNUM_ULLMSR;     i++) {
        ULLMSR_ULS  [i] = 0x0;
    }
    for(uint i = 0; i < emNUM_VCULLMTBR;  i++) {
        VCULLMTBR_VCULMTB[i] = 0x7FFE;
        VCULLMTBR_VCLLMTB[i] = 0x0;
    }
    VCLMINTER1_ADUL31IE = 0x0;
    VCLMINTER1_ADUL30IE = 0x0;
    VCLMINTER1_ADUL29IE = 0x0;
    VCLMINTER1_ADUL28IE = 0x0;
    VCLMINTER1_ADUL27IE = 0x0;
    VCLMINTER1_ADUL26IE = 0x0;
    VCLMINTER1_ADUL25IE = 0x0;
    VCLMINTER1_ADUL24IE = 0x0;
    VCLMINTER1_ADUL23IE = 0x0;
    VCLMINTER1_ADUL22IE = 0x0;
    VCLMINTER1_ADUL21IE = 0x0;
    VCLMINTER1_ADUL20IE = 0x0;
    VCLMINTER1_ADUL19IE = 0x0;
    VCLMINTER1_ADUL18IE = 0x0;
    VCLMINTER1_ADUL17IE = 0x0;
    VCLMINTER1_ADUL16IE = 0x0;
    VCLMINTER1_ADUL15IE = 0x0;
    VCLMINTER1_ADUL14IE = 0x0;
    VCLMINTER1_ADUL13IE = 0x0;
    VCLMINTER1_ADUL12IE = 0x0;
    VCLMINTER1_ADUL11IE = 0x0;
    VCLMINTER1_ADUL10IE = 0x0;
    VCLMINTER1_ADUL09IE = 0x0;
    VCLMINTER1_ADUL08IE = 0x0;
    VCLMINTER1_ADUL07IE = 0x0;
    VCLMINTER1_ADUL06IE = 0x0;
    VCLMINTER1_ADUL05IE = 0x0;
    VCLMINTER1_ADUL04IE = 0x0;
    VCLMINTER1_ADUL03IE = 0x0;
    VCLMINTER1_ADUL02IE = 0x0;
    VCLMINTER1_ADUL01IE = 0x0;
    VCLMINTER1_ADUL00IE = 0x0;
    VCLMINTER2_ADUL47IE = 0x0;
    VCLMINTER2_ADUL46IE = 0x0;
    VCLMINTER2_ADUL45IE = 0x0;
    VCLMINTER2_ADUL44IE = 0x0;
    VCLMINTER2_ADUL43IE = 0x0;
    VCLMINTER2_ADUL42IE = 0x0;
    VCLMINTER2_ADUL41IE = 0x0;
    VCLMINTER2_ADUL40IE = 0x0;
    VCLMINTER2_ADUL39IE = 0x0;
    VCLMINTER2_ADUL38IE = 0x0;
    VCLMINTER2_ADUL37IE = 0x0;
    VCLMINTER2_ADUL36IE = 0x0;
    VCLMINTER2_ADUL35IE = 0x0;
    VCLMINTER2_ADUL34IE = 0x0;
    VCLMINTER2_ADUL33IE = 0x0;
    VCLMINTER2_ADUL32IE = 0x0;
    VCLMSR1_VC31LMS = 0x0;
    VCLMSR1_VC30LMS = 0x0;
    VCLMSR1_VC29LMS = 0x0;
    VCLMSR1_VC28LMS = 0x0;
    VCLMSR1_VC27LMS = 0x0;
    VCLMSR1_VC26LMS = 0x0;
    VCLMSR1_VC25LMS = 0x0;
    VCLMSR1_VC24LMS = 0x0;
    VCLMSR1_VC23LMS = 0x0;
    VCLMSR1_VC22LMS = 0x0;
    VCLMSR1_VC21LMS = 0x0;
    VCLMSR1_VC20LMS = 0x0;
    VCLMSR1_VC19LMS = 0x0;
    VCLMSR1_VC18LMS = 0x0;
    VCLMSR1_VC17LMS = 0x0;
    VCLMSR1_VC16LMS = 0x0;
    VCLMSR1_VC15LMS = 0x0;
    VCLMSR1_VC14LMS = 0x0;
    VCLMSR1_VC13LMS = 0x0;
    VCLMSR1_VC12LMS = 0x0;
    VCLMSR1_VC11LMS = 0x0;
    VCLMSR1_VC10LMS = 0x0;
    VCLMSR1_VC09LMS = 0x0;
    VCLMSR1_VC08LMS = 0x0;
    VCLMSR1_VC07LMS = 0x0;
    VCLMSR1_VC06LMS = 0x0;
    VCLMSR1_VC05LMS = 0x0;
    VCLMSR1_VC04LMS = 0x0;
    VCLMSR1_VC03LMS = 0x0;
    VCLMSR1_VC02LMS = 0x0;
    VCLMSR1_VC01LMS = 0x0;
    VCLMSR1_VC00LMS = 0x0;
    VCLMSR2_VC47LMS = 0x0;
    VCLMSR2_VC46LMS = 0x0;
    VCLMSR2_VC45LMS = 0x0;
    VCLMSR2_VC44LMS = 0x0;
    VCLMSR2_VC43LMS = 0x0;
    VCLMSR2_VC42LMS = 0x0;
    VCLMSR2_VC41LMS = 0x0;
    VCLMSR2_VC40LMS = 0x0;
    VCLMSR2_VC39LMS = 0x0;
    VCLMSR2_VC38LMS = 0x0;
    VCLMSR2_VC37LMS = 0x0;
    VCLMSR2_VC36LMS = 0x0;
    VCLMSR2_VC35LMS = 0x0;
    VCLMSR2_VC34LMS = 0x0;
    VCLMSR2_VC33LMS = 0x0;
    VCLMSR2_VC32LMS = 0x0;
    VCLMSCR1_VC31LMSC = 0x0;
    VCLMSCR1_VC30LMSC = 0x0;
    VCLMSCR1_VC29LMSC = 0x0;
    VCLMSCR1_VC28LMSC = 0x0;
    VCLMSCR1_VC27LMSC = 0x0;
    VCLMSCR1_VC26LMSC = 0x0;
    VCLMSCR1_VC25LMSC = 0x0;
    VCLMSCR1_VC24LMSC = 0x0;
    VCLMSCR1_VC23LMSC = 0x0;
    VCLMSCR1_VC22LMSC = 0x0;
    VCLMSCR1_VC21LMSC = 0x0;
    VCLMSCR1_VC20LMSC = 0x0;
    VCLMSCR1_VC19LMSC = 0x0;
    VCLMSCR1_VC18LMSC = 0x0;
    VCLMSCR1_VC17LMSC = 0x0;
    VCLMSCR1_VC16LMSC = 0x0;
    VCLMSCR1_VC15LMSC = 0x0;
    VCLMSCR1_VC14LMSC = 0x0;
    VCLMSCR1_VC13LMSC = 0x0;
    VCLMSCR1_VC12LMSC = 0x0;
    VCLMSCR1_VC11LMSC = 0x0;
    VCLMSCR1_VC10LMSC = 0x0;
    VCLMSCR1_VC09LMSC = 0x0;
    VCLMSCR1_VC08LMSC = 0x0;
    VCLMSCR1_VC07LMSC = 0x0;
    VCLMSCR1_VC06LMSC = 0x0;
    VCLMSCR1_VC05LMSC = 0x0;
    VCLMSCR1_VC04LMSC = 0x0;
    VCLMSCR1_VC03LMSC = 0x0;
    VCLMSCR1_VC02LMSC = 0x0;
    VCLMSCR1_VC01LMSC = 0x0;
    VCLMSCR1_VC00LMSC = 0x0;
    VCLMSCR2_VC47LMSC = 0x0;
    VCLMSCR2_VC46LMSC = 0x0;
    VCLMSCR2_VC45LMSC = 0x0;
    VCLMSCR2_VC44LMSC = 0x0;
    VCLMSCR2_VC43LMSC = 0x0;
    VCLMSCR2_VC42LMSC = 0x0;
    VCLMSCR2_VC41LMSC = 0x0;
    VCLMSCR2_VC40LMSC = 0x0;
    VCLMSCR2_VC39LMSC = 0x0;
    VCLMSCR2_VC38LMSC = 0x0;
    VCLMSCR2_VC37LMSC = 0x0;
    VCLMSCR2_VC36LMSC = 0x0;
    VCLMSCR2_VC35LMSC = 0x0;
    VCLMSCR2_VC34LMSC = 0x0;
    VCLMSCR2_VC33LMSC = 0x0;
    VCLMSCR2_VC32LMSC = 0x0;
    ADOPDIG_ADOPDIGn0 = 0x0;
    ADOPDIG_ADOPDIGn1 = 0x0;
    ADOPDIG_ADOPDIGn2 = 0x0;
    ADOPDIG_ADOPDIGn3 = 0x0;
    ADOPDIG_ADOPDIGn4 = 0x0;
    ADOPDIG_ADOPDIGn5 = 0x0;
    ADOPDIG_ADOPDIGn6 = 0x0;
    ADOPDIG_ADOPDIGn7 = 0x0;
    ADOPDIG_ADOPDIGn8 = 0x0;
    ADOPDIG_ADOPDIGn9 = 0x0;
    ADOPDIG_ADOPDIGn10 = 0x0;
    ADOPDIG_ADOPDIGn11 = 0x0;
}

/// Update bit value to local value
/// @return None
void Cadc_regif::UpdateLocalVal(cuint addr)
{
    if ((0x0000 <= addr) && (addr <= (0x0000)+(4*47)) && ((addr-0x0000)%4 == 0)) {
        uint i = (addr - 0x0000)/4;
        VCR_VCULME                     [i] = (*(VCR        [i]))["VCULME"     ];
        VCR_VCLLME                     [i] = (*(VCR        [i]))["VCLLME"     ];
        VCR_VCULLMTBS                  [i] = (*(VCR        [i]))["VCULLMTBS"  ];
        VCR_PUE                        [i] = (*(VCR        [i]))["PUE"        ];
        VCR_PDE                        [i] = (*(VCR        [i]))["PDE"        ];
        VCR_CNVCLS                     [i] = (*(VCR        [i]))["CNVCLS"     ];
        VCR_DFENT                      [i] = (*(VCR        [i]))["DFENT"      ];
        VCR_DFTAG                      [i] = (*(VCR        [i]))["DFTAG"      ];
        VCR_ADIE                       [i] = (*(VCR        [i]))["ADIE"       ];
        VCR_GCTRL                      [i] = (*(VCR        [i]))["GCTRL"      ];
        return;
    }
    if ((0x0100 <= addr) && (addr <= (0x0100)+(4*23)) && ((addr-0x0100)%4 == 0)) {
        uint i = (addr - 0x0100)/4;
        DR_DR1                         [i] = (*(DR         [i]))["DR1"        ];
        DR_DR0                         [i] = (*(DR         [i]))["DR0"        ];
        return;
    }
    if ((0x0200 <= addr) && (addr <= (0x0200)+(4*47)) && ((addr-0x0200)%4 == 0)) {
        uint i = (addr - 0x0200)/4;
        DIR_IDEF                       [i] = (*(DIR        [i]))["IDEF"       ];
        DIR_WFLG                       [i] = (*(DIR        [i]))["WFLG"       ];
        DIR_PRTY                       [i] = (*(DIR        [i]))["PRTY"       ];
        DIR_ID                         [i] = (*(DIR        [i]))["ID"         ];
        DIR_DRn                        [i] = (*(DIR        [i]))["DRn"        ];
        return;
    }
    if (addr == 0x0380) {
        ADHALTR_HALT                    = (*ADHALTR    )["HALT"       ];
        return;
    }
    if (addr == 0x0384) {
        ADCR1_SUSMTD                    = (*ADCR1      )["SUSMTD"     ];
        return;
    }
    if (addr == 0x0388) {
        MPXCURCR_MSKCFMT                = (*MPXCURCR   )["MSKCFMT"    ];
        return;
    }
    if (addr == 0x038A) {
        MPXINTER_ADMPXIE                = (*MPXINTER   )["ADMPXIE"    ];
        return;
    }
    if (addr == 0x038C) {
        MPXCURR_MSKC                    = (*MPXCURR    )["MSKC"       ];
        MPXCURR_MPXCMD                  = (*MPXCURR    )["MPXCMD"     ];
        MPXCURR_MPXCUR                  = (*MPXCURR    )["MPXCUR"     ];
        return;
    }
    if (addr == 0x0390) {
        MPXOWR_MPXOW                    = (*MPXOWR     )["MPXOW"      ];
        return;
    }
    if (addr == 0x0394) {
        MPXCMDR_MPXCMD                  = (*MPXCMDR    )["MPXCMD"     ];
        return;
    }
    if (addr == 0x0398) {
        ADCR2_DFMT                      = (*ADCR2      )["DFMT"       ];
        ADCR2_ADDNT                     = (*ADCR2      )["ADDNT"      ];
        return;
    }
    if (addr == 0x039C) {
        DFASENTSGER_DFENTSG4E           = (*DFASENTSGER)["DFENTSG4E"  ];
        DFASENTSGER_DFENTSG3E           = (*DFASENTSGER)["DFENTSG3E"  ];
        DFASENTSGER_DFENTSG2E           = (*DFASENTSGER)["DFENTSG2E"  ];
        DFASENTSGER_DFENTSG1E           = (*DFASENTSGER)["DFENTSG1E"  ];
        DFASENTSGER_DFENTSG0E           = (*DFASENTSGER)["DFENTSG0E"  ];
        DFASENTSGER_ASENTSG4E           = (*DFASENTSGER)["ASENTSG4E"  ];
        DFASENTSGER_ASENTSG3E           = (*DFASENTSGER)["ASENTSG3E"  ];
        DFASENTSGER_ASENTSG2E           = (*DFASENTSGER)["ASENTSG2E"  ];
        DFASENTSGER_ASENTSG1E           = (*DFASENTSGER)["ASENTSG1E"  ];
        DFASENTSGER_ASENTSG0E           = (*DFASENTSGER)["ASENTSG0E"  ];
        return;
    }
    if ((0x03A0 <= addr) && (addr <= (0x03A0)+(4*4)) && ((addr-0x03A0)%4 == 0)) {
        uint i = (addr - 0x03A0)/4;
        ADENDP_ENDP                    [i] = (*(ADENDP     [i]))["ENDP"       ];
        return;
    }
    if (addr == 0x0400) {
        THSMPSTCR_SMPST                 = (*THSMPSTCR  )["SMPST"      ];
        return;
    }
    if (addr == 0x0404) {
        THSTPCR_THSTP                   = (*THSTPCR    )["THSTP"      ];
        return;
    }
    if (addr == 0x0408) {
        THCR_ASMPMSK                    = (*THCR       )["ASMPMSK"    ];
        return;
    }
    if (addr == 0x0410) {
        THAHLDSTCR_HLDST                = (*THAHLDSTCR )["HLDST"      ];
        return;
    }
    if (addr == 0x0414) {
        THBHLDSTCR_HLDST                = (*THBHLDSTCR )["HLDST"      ];
        return;
    }
    if (addr == 0x0420) {
        THACR_HLDCTE                    = (*THACR      )["HLDCTE"     ];
        THACR_HLDTE                     = (*THACR      )["HLDTE"      ];
        THACR_SGS                       = (*THACR      )["SGS"        ];
        return;
    }
    if (addr == 0x0424) {
        THBCR_HLDCTE                    = (*THBCR      )["HLDCTE"     ];
        THBCR_HLDTE                     = (*THBCR      )["HLDTE"      ];
        THBCR_SGS                       = (*THBCR      )["SGS"        ];
        return;
    }
    if (addr == 0x0430) {
        THER_TH5E                       = (*THER       )["TH5E"       ];
        THER_TH4E                       = (*THER       )["TH4E"       ];
        THER_TH3E                       = (*THER       )["TH3E"       ];
        THER_TH2E                       = (*THER       )["TH2E"       ];
        THER_TH1E                       = (*THER       )["TH1E"       ];
        THER_TH0E                       = (*THER       )["TH0E"       ];
        return;
    }
    if (addr == 0x0434) {
        THGSR_TH5GS                     = (*THGSR      )["TH5GS"      ];
        THGSR_TH4GS                     = (*THGSR      )["TH4GS"      ];
        THGSR_TH3GS                     = (*THGSR      )["TH3GS"      ];
        THGSR_TH2GS                     = (*THGSR      )["TH2GS"      ];
        THGSR_TH1GS                     = (*THGSR      )["TH1GS"      ];
        THGSR_TH0GS                     = (*THGSR      )["TH0GS"      ];
        return;
    }
    if (addr == 0x0440) {
        THOMSR_KEY                      = (*THOMSR     )["KEY"        ];
        THOMSR_THOMS                    = (*THOMSR     )["THOMS"      ];
        return;
    }
    if (addr == 0x03C0) {
        SFTCR_SYNCEIE                   = (*SFTCR      )["SYNCEIE"    ];
        SFTCR_RDCLRE                    = (*SFTCR      )["RDCLRE"     ];
        SFTCR_ULEIE                     = (*SFTCR      )["ULEIE"      ];
        SFTCR_OWEIE                     = (*SFTCR      )["OWEIE"      ];
        SFTCR_PEIE                      = (*SFTCR      )["PEIE"       ];
        SFTCR_IDEIE                     = (*SFTCR      )["IDEIE"      ];
        return;
    }
    if (addr == 0x03C4) {
        TDCR_TDE                        = (*TDCR       )["TDE"        ];
        TDCR_TDLV                       = (*TDCR       )["TDLV"       ];
        return;
    }
    if (addr == 0x03C8) {
        ODCR_ODDE                       = (*ODCR       )["ODDE"       ];
        ODCR_DSCE                       = (*ODCR       )["DSCE"       ];
        ODCR_ODE                        = (*ODCR       )["ODE"        ];
        ODCR_ODPW                       = (*ODCR       )["ODPW"       ];
        return;
    }
    if ((0x03CC <= addr) && (addr <= (0x03CC)+(4*2)) && ((addr-0x03CC)%4 == 0)) {
        uint i = (addr - 0x03CC)/4;
        ULLMTBR_ULMTB                  [i] = (*(ULLMTBR    [i]))["ULMTB"      ];
        ULLMTBR_LLMTB                  [i] = (*(ULLMTBR    [i]))["LLMTB"      ];
        return;
    }
    if (addr == 0x03D8) {
        ECR_SYNCEC                      = (*ECR        )["SYNCEC"     ];
        ECR_ULEC                        = (*ECR        )["ULEC"       ];
        ECR_OWEC                        = (*ECR        )["OWEC"       ];
        ECR_PEC                         = (*ECR        )["PEC"        ];
        ECR_IDEC                        = (*ECR        )["IDEC"       ];
        return;
    }
    if (addr == 0x03DC) {
        ULER_ULE                        = (*ULER       )["ULE"        ];
        ULER_ULECAP                     = (*ULER       )["ULECAP"     ];
        return;
    }
    if (addr == 0x03E0) {
        OWER_OWE                        = (*OWER       )["OWE"        ];
        OWER_OWECAP                     = (*OWER       )["OWECAP"     ];
        return;
    }
    if (addr == 0x03E4) {
        PER_PE                          = (*PER        )["PE"         ];
        PER_PECAP                       = (*PER        )["PECAP"      ];
        return;
    }
    if (addr == 0x03E8) {
        IDER_IDE                        = (*IDER       )["IDE"        ];
        IDER_IDECAP                     = (*IDER       )["IDECAP"     ];
        return;
    }
    if (addr == 0x03EC) {
        SYNCER_SYNCE                    = (*SYNCER     )["SYNCE"      ];
        return;
    }
    if (addr == 0x0340) {
        SMPCR_BUFAMPD                   = (*SMPCR      )["BUFAMPD"    ];
        SMPCR_SMPT13_14                 = (*SMPCR      )["SMPT13_14"  ];
        SMPCR_SMPTS                     = (*SMPCR      )["SMPTS"      ];
        SMPCR_SMPT8_11                  = (*SMPCR      )["SMPT8_11"   ];
        SMPCR_SMPT                      = (*SMPCR      )["SMPT"       ];
        return;
    }
    if (addr == 0x0360) {
        TRMCR_TRMS                      = (*TRMCR      )["TRMS"       ];
        TRMCR_TRMTTUNE                  = (*TRMCR      )["TRMTTUNE"   ];
        TRMCR_TRMBTUNE                  = (*TRMCR      )["TRMBTUNE"   ];
        TRMCR_TRMATUNE                  = (*TRMCR      )["TRMATUNE"   ];
        TRMCR_TRMT                      = (*TRMCR      )["TRMT"       ];
        TRMCR_TRMB                      = (*TRMCR      )["TRMB"       ];
        TRMCR_TRMA                      = (*TRMCR      )["TRMA"       ];
        return;
    }
    if (addr == 0x0364) {
        ADTSTRA_ADTST                   = (*ADTSTRA    )["ADTST"      ];
        return;
    }
    if (addr == 0x0368) {
        ADTSTRB_ADVAL                   = (*ADTSTRB    )["ADVAL"      ];
        return;
    }
    if (addr == 0x036C) {
        ADTSTRC_CKSTP                   = (*ADTSTRC    )["CKSTP"      ];
        ADTSTRC_ADMD                    = (*ADTSTRC    )["ADMD"       ];
        return;
    }
    if ((0x0480 <= addr) && (addr <= (0x0480)+(128*4)) && ((addr-0x0480)%128 == 0)) {
        uint i = (addr - 0x0480)/128;
        SGSTCR_SGST                    [i] = (*(SGSTCR     [i]))["SGST"       ];
        return;
    }
    if ((0x0484 <= addr) && (addr <= (0x0484)+(128*4)) && ((addr-0x0484)%128 == 0)) {
        uint i = (addr - 0x0484)/128;
        SGSTPCR_SGSTP                  [i] = (*(SGSTPCR    [i]))["SGSTP"      ];
        return;
    }
    if ((0x0608 <= addr) && (addr <= (0x0608)+(128*1)) && ((addr-0x0608)%128 == 0) && ChkAddrWithFactorIndex((addr-0x0608)/128 + 3, mFactorIndexADTSTCR, 2)) {
        uint i = (addr - 0x0608)/128 + 3;
        ADTSTCR_ADTST                  [i] = (*(ADTSTCR    [i]))["ADTST"      ];
        return;
    }
    if ((0x060C <= addr) && (addr <= (0x060C)+(128*1)) && ((addr-0x060C)%128 == 0) && ChkAddrWithFactorIndex((addr-0x060C)/128 + 3, mFactorIndexADTENDCR, 2)) {
        uint i = (addr - 0x060C)/128 + 3;
        ADTENDCR_ADTEND                [i] = (*(ADTENDCR   [i]))["ADTEND"     ];
        return;
    }
    if ((0x0490 <= addr) && (addr <= (0x0490)+(128*4)) && ((addr-0x0490)%128 == 0)) {
        uint i = (addr - 0x0490)/128;
        SGCR_ADTSTARTE                 [i] = (*(SGCR       [i]))["ADTSTARTE"  ];
        SGCR_ADSTARTE                  [i] = (*(SGCR       [i]))["ADSTARTE"   ];
        SGCR_SCANMD                    [i] = (*(SGCR       [i]))["SCANMD"     ];
        SGCR_ADIE                      [i] = (*(SGCR       [i]))["ADIE"       ];
        SGCR_TRGMD                     [i] = (*(SGCR       [i]))["TRGMD"      ];
        return;
    }
    if ((0x0494 <= addr) && (addr <= (0x0494)+(128*4)) && ((addr-0x0494)%128 == 0)) {
        uint i = (addr - 0x0494)/128;
        SGVCSP_VCSP                    [i] = (*(SGVCSP     [i]))["VCSP"       ];
        return;
    }
    if ((0x0498 <= addr) && (addr <= (0x0498)+(128*4)) && ((addr-0x0498)%128 == 0)) {
        uint i = (addr - 0x0498)/128;
        SGVCEP_VCEP                    [i] = (*(SGVCEP     [i]))["VCEP"       ];
        return;
    }
    if ((0x049C <= addr) && (addr <= (0x049C)+(128*4)) && ((addr-0x049C)%128 == 0)) {
        uint i = (addr - 0x049C)/128;
        SGMCYCR_MCYC                   [i] = (*(SGMCYCR    [i]))["MCYC"       ];
        return;
    }
    if ((0x04A0 <= addr) && (addr <= (0x04A0)+(128*4)) && ((addr-0x04A0)%128 == 0)) {
        uint i = (addr - 0x04A0)/128;
        SGVCPR_VCEP                    [i] = (*(SGVCPR     [i]))["VCEP"       ];
        SGVCPR_VCSP                    [i] = (*(SGVCPR     [i]))["VCSP"       ];
        return;
    }
    if ((0x04B4 <= addr) && (addr <= (0x04B4)+(128*4)) && ((addr-0x04B4)%128 == 0)) {
        uint i = (addr - 0x04B4)/128;
        SGVCOWR_VCOW                   [i] = (*(SGVCOWR    [i]))["VCOW"       ];
        return;
    }
    if ((0x04A4 <= addr) && (addr <= (0x04A4)+(128*4)) && ((addr-0x04A4)%128 == 0)) {
        uint i = (addr - 0x04A4)/128;
        SGSR_ADTACT                    [i] = (*(SGSR       [i]))["ADTACT"     ];
        SGSR_SGACT                     [i] = (*(SGSR       [i]))["SGACT"      ];
        return;
    }
    if ((0x0628 <= addr) && (addr <= (0x0628)+(128*1)) && ((addr-0x0628)%128 == 0) && ChkAddrWithFactorIndex((addr-0x0628)/128 + 3, mFactorIndexADTIPR, 2)) {
        uint i = (addr - 0x0628)/128 + 3;
        ADTIPR_ADTIP                   [i] = (*(ADTIPR     [i]))["ADTIP"      ];
        return;
    }
    if ((0x062C <= addr) && (addr <= (0x062C)+(128*1)) && ((addr-0x062C)%128 == 0) && ChkAddrWithFactorIndex((addr-0x062C)/128 + 3, mFactorIndexADTPRR, 2)) {
        uint i = (addr - 0x062C)/128 + 3;
        ADTPRR_ADTPR                   [i] = (*(ADTPRR     [i]))["ADTPR"      ];
        return;
    }
    if ((0x04B0 <= addr) && (addr <= (0x04B0)+(128*4)) && ((addr-0x04B0)%128 == 0)) {
        uint i = (addr - 0x04B0)/128;
        ULLMSR_ULS                     [i] = (*(ULLMSR     [i]))["ULS"        ];
        return;
    }
    if ((0x0700 <= addr) && (addr <= (0x0700)+(4*6)) && ((addr-0x0700)%4 == 0)) {
        uint i = (addr - 0x0700)/4;
        VCULLMTBR_VCULMTB              [i] = (*(VCULLMTBR  [i]))["VCULMTB"    ];
        VCULLMTBR_VCLLMTB              [i] = (*(VCULLMTBR  [i]))["VCLLMTB"    ];
        return;
    }
    if (addr == 0x0730) {
        VCLMINTER1_ADUL31IE             = (*VCLMINTER1 )["ADUL31IE"   ];
        VCLMINTER1_ADUL30IE             = (*VCLMINTER1 )["ADUL30IE"   ];
        VCLMINTER1_ADUL29IE             = (*VCLMINTER1 )["ADUL29IE"   ];
        VCLMINTER1_ADUL28IE             = (*VCLMINTER1 )["ADUL28IE"   ];
        VCLMINTER1_ADUL27IE             = (*VCLMINTER1 )["ADUL27IE"   ];
        VCLMINTER1_ADUL26IE             = (*VCLMINTER1 )["ADUL26IE"   ];
        VCLMINTER1_ADUL25IE             = (*VCLMINTER1 )["ADUL25IE"   ];
        VCLMINTER1_ADUL24IE             = (*VCLMINTER1 )["ADUL24IE"   ];
        VCLMINTER1_ADUL23IE             = (*VCLMINTER1 )["ADUL23IE"   ];
        VCLMINTER1_ADUL22IE             = (*VCLMINTER1 )["ADUL22IE"   ];
        VCLMINTER1_ADUL21IE             = (*VCLMINTER1 )["ADUL21IE"   ];
        VCLMINTER1_ADUL20IE             = (*VCLMINTER1 )["ADUL20IE"   ];
        VCLMINTER1_ADUL19IE             = (*VCLMINTER1 )["ADUL19IE"   ];
        VCLMINTER1_ADUL18IE             = (*VCLMINTER1 )["ADUL18IE"   ];
        VCLMINTER1_ADUL17IE             = (*VCLMINTER1 )["ADUL17IE"   ];
        VCLMINTER1_ADUL16IE             = (*VCLMINTER1 )["ADUL16IE"   ];
        VCLMINTER1_ADUL15IE             = (*VCLMINTER1 )["ADUL15IE"   ];
        VCLMINTER1_ADUL14IE             = (*VCLMINTER1 )["ADUL14IE"   ];
        VCLMINTER1_ADUL13IE             = (*VCLMINTER1 )["ADUL13IE"   ];
        VCLMINTER1_ADUL12IE             = (*VCLMINTER1 )["ADUL12IE"   ];
        VCLMINTER1_ADUL11IE             = (*VCLMINTER1 )["ADUL11IE"   ];
        VCLMINTER1_ADUL10IE             = (*VCLMINTER1 )["ADUL10IE"   ];
        VCLMINTER1_ADUL09IE             = (*VCLMINTER1 )["ADUL09IE"   ];
        VCLMINTER1_ADUL08IE             = (*VCLMINTER1 )["ADUL08IE"   ];
        VCLMINTER1_ADUL07IE             = (*VCLMINTER1 )["ADUL07IE"   ];
        VCLMINTER1_ADUL06IE             = (*VCLMINTER1 )["ADUL06IE"   ];
        VCLMINTER1_ADUL05IE             = (*VCLMINTER1 )["ADUL05IE"   ];
        VCLMINTER1_ADUL04IE             = (*VCLMINTER1 )["ADUL04IE"   ];
        VCLMINTER1_ADUL03IE             = (*VCLMINTER1 )["ADUL03IE"   ];
        VCLMINTER1_ADUL02IE             = (*VCLMINTER1 )["ADUL02IE"   ];
        VCLMINTER1_ADUL01IE             = (*VCLMINTER1 )["ADUL01IE"   ];
        VCLMINTER1_ADUL00IE             = (*VCLMINTER1 )["ADUL00IE"   ];
        return;
    }
    if (addr == 0x0734) {
        VCLMINTER2_ADUL47IE             = (*VCLMINTER2 )["ADUL47IE"   ];
        VCLMINTER2_ADUL46IE             = (*VCLMINTER2 )["ADUL46IE"   ];
        VCLMINTER2_ADUL45IE             = (*VCLMINTER2 )["ADUL45IE"   ];
        VCLMINTER2_ADUL44IE             = (*VCLMINTER2 )["ADUL44IE"   ];
        VCLMINTER2_ADUL43IE             = (*VCLMINTER2 )["ADUL43IE"   ];
        VCLMINTER2_ADUL42IE             = (*VCLMINTER2 )["ADUL42IE"   ];
        VCLMINTER2_ADUL41IE             = (*VCLMINTER2 )["ADUL41IE"   ];
        VCLMINTER2_ADUL40IE             = (*VCLMINTER2 )["ADUL40IE"   ];
        VCLMINTER2_ADUL39IE             = (*VCLMINTER2 )["ADUL39IE"   ];
        VCLMINTER2_ADUL38IE             = (*VCLMINTER2 )["ADUL38IE"   ];
        VCLMINTER2_ADUL37IE             = (*VCLMINTER2 )["ADUL37IE"   ];
        VCLMINTER2_ADUL36IE             = (*VCLMINTER2 )["ADUL36IE"   ];
        VCLMINTER2_ADUL35IE             = (*VCLMINTER2 )["ADUL35IE"   ];
        VCLMINTER2_ADUL34IE             = (*VCLMINTER2 )["ADUL34IE"   ];
        VCLMINTER2_ADUL33IE             = (*VCLMINTER2 )["ADUL33IE"   ];
        VCLMINTER2_ADUL32IE             = (*VCLMINTER2 )["ADUL32IE"   ];
        return;
    }
    if (addr == 0x0738) {
        VCLMSR1_VC31LMS                 = (*VCLMSR1    )["VC31LMS"    ];
        VCLMSR1_VC30LMS                 = (*VCLMSR1    )["VC30LMS"    ];
        VCLMSR1_VC29LMS                 = (*VCLMSR1    )["VC29LMS"    ];
        VCLMSR1_VC28LMS                 = (*VCLMSR1    )["VC28LMS"    ];
        VCLMSR1_VC27LMS                 = (*VCLMSR1    )["VC27LMS"    ];
        VCLMSR1_VC26LMS                 = (*VCLMSR1    )["VC26LMS"    ];
        VCLMSR1_VC25LMS                 = (*VCLMSR1    )["VC25LMS"    ];
        VCLMSR1_VC24LMS                 = (*VCLMSR1    )["VC24LMS"    ];
        VCLMSR1_VC23LMS                 = (*VCLMSR1    )["VC23LMS"    ];
        VCLMSR1_VC22LMS                 = (*VCLMSR1    )["VC22LMS"    ];
        VCLMSR1_VC21LMS                 = (*VCLMSR1    )["VC21LMS"    ];
        VCLMSR1_VC20LMS                 = (*VCLMSR1    )["VC20LMS"    ];
        VCLMSR1_VC19LMS                 = (*VCLMSR1    )["VC19LMS"    ];
        VCLMSR1_VC18LMS                 = (*VCLMSR1    )["VC18LMS"    ];
        VCLMSR1_VC17LMS                 = (*VCLMSR1    )["VC17LMS"    ];
        VCLMSR1_VC16LMS                 = (*VCLMSR1    )["VC16LMS"    ];
        VCLMSR1_VC15LMS                 = (*VCLMSR1    )["VC15LMS"    ];
        VCLMSR1_VC14LMS                 = (*VCLMSR1    )["VC14LMS"    ];
        VCLMSR1_VC13LMS                 = (*VCLMSR1    )["VC13LMS"    ];
        VCLMSR1_VC12LMS                 = (*VCLMSR1    )["VC12LMS"    ];
        VCLMSR1_VC11LMS                 = (*VCLMSR1    )["VC11LMS"    ];
        VCLMSR1_VC10LMS                 = (*VCLMSR1    )["VC10LMS"    ];
        VCLMSR1_VC09LMS                 = (*VCLMSR1    )["VC09LMS"    ];
        VCLMSR1_VC08LMS                 = (*VCLMSR1    )["VC08LMS"    ];
        VCLMSR1_VC07LMS                 = (*VCLMSR1    )["VC07LMS"    ];
        VCLMSR1_VC06LMS                 = (*VCLMSR1    )["VC06LMS"    ];
        VCLMSR1_VC05LMS                 = (*VCLMSR1    )["VC05LMS"    ];
        VCLMSR1_VC04LMS                 = (*VCLMSR1    )["VC04LMS"    ];
        VCLMSR1_VC03LMS                 = (*VCLMSR1    )["VC03LMS"    ];
        VCLMSR1_VC02LMS                 = (*VCLMSR1    )["VC02LMS"    ];
        VCLMSR1_VC01LMS                 = (*VCLMSR1    )["VC01LMS"    ];
        VCLMSR1_VC00LMS                 = (*VCLMSR1    )["VC00LMS"    ];
        return;
    }
    if (addr == 0x073C) {
        VCLMSR2_VC47LMS                 = (*VCLMSR2    )["VC47LMS"    ];
        VCLMSR2_VC46LMS                 = (*VCLMSR2    )["VC46LMS"    ];
        VCLMSR2_VC45LMS                 = (*VCLMSR2    )["VC45LMS"    ];
        VCLMSR2_VC44LMS                 = (*VCLMSR2    )["VC44LMS"    ];
        VCLMSR2_VC43LMS                 = (*VCLMSR2    )["VC43LMS"    ];
        VCLMSR2_VC42LMS                 = (*VCLMSR2    )["VC42LMS"    ];
        VCLMSR2_VC41LMS                 = (*VCLMSR2    )["VC41LMS"    ];
        VCLMSR2_VC40LMS                 = (*VCLMSR2    )["VC40LMS"    ];
        VCLMSR2_VC39LMS                 = (*VCLMSR2    )["VC39LMS"    ];
        VCLMSR2_VC38LMS                 = (*VCLMSR2    )["VC38LMS"    ];
        VCLMSR2_VC37LMS                 = (*VCLMSR2    )["VC37LMS"    ];
        VCLMSR2_VC36LMS                 = (*VCLMSR2    )["VC36LMS"    ];
        VCLMSR2_VC35LMS                 = (*VCLMSR2    )["VC35LMS"    ];
        VCLMSR2_VC34LMS                 = (*VCLMSR2    )["VC34LMS"    ];
        VCLMSR2_VC33LMS                 = (*VCLMSR2    )["VC33LMS"    ];
        VCLMSR2_VC32LMS                 = (*VCLMSR2    )["VC32LMS"    ];
        return;
    }
    if (addr == 0x0740) {
        VCLMSCR1_VC31LMSC               = (*VCLMSCR1   )["VC31LMSC"   ];
        VCLMSCR1_VC30LMSC               = (*VCLMSCR1   )["VC30LMSC"   ];
        VCLMSCR1_VC29LMSC               = (*VCLMSCR1   )["VC29LMSC"   ];
        VCLMSCR1_VC28LMSC               = (*VCLMSCR1   )["VC28LMSC"   ];
        VCLMSCR1_VC27LMSC               = (*VCLMSCR1   )["VC27LMSC"   ];
        VCLMSCR1_VC26LMSC               = (*VCLMSCR1   )["VC26LMSC"   ];
        VCLMSCR1_VC25LMSC               = (*VCLMSCR1   )["VC25LMSC"   ];
        VCLMSCR1_VC24LMSC               = (*VCLMSCR1   )["VC24LMSC"   ];
        VCLMSCR1_VC23LMSC               = (*VCLMSCR1   )["VC23LMSC"   ];
        VCLMSCR1_VC22LMSC               = (*VCLMSCR1   )["VC22LMSC"   ];
        VCLMSCR1_VC21LMSC               = (*VCLMSCR1   )["VC21LMSC"   ];
        VCLMSCR1_VC20LMSC               = (*VCLMSCR1   )["VC20LMSC"   ];
        VCLMSCR1_VC19LMSC               = (*VCLMSCR1   )["VC19LMSC"   ];
        VCLMSCR1_VC18LMSC               = (*VCLMSCR1   )["VC18LMSC"   ];
        VCLMSCR1_VC17LMSC               = (*VCLMSCR1   )["VC17LMSC"   ];
        VCLMSCR1_VC16LMSC               = (*VCLMSCR1   )["VC16LMSC"   ];
        VCLMSCR1_VC15LMSC               = (*VCLMSCR1   )["VC15LMSC"   ];
        VCLMSCR1_VC14LMSC               = (*VCLMSCR1   )["VC14LMSC"   ];
        VCLMSCR1_VC13LMSC               = (*VCLMSCR1   )["VC13LMSC"   ];
        VCLMSCR1_VC12LMSC               = (*VCLMSCR1   )["VC12LMSC"   ];
        VCLMSCR1_VC11LMSC               = (*VCLMSCR1   )["VC11LMSC"   ];
        VCLMSCR1_VC10LMSC               = (*VCLMSCR1   )["VC10LMSC"   ];
        VCLMSCR1_VC09LMSC               = (*VCLMSCR1   )["VC09LMSC"   ];
        VCLMSCR1_VC08LMSC               = (*VCLMSCR1   )["VC08LMSC"   ];
        VCLMSCR1_VC07LMSC               = (*VCLMSCR1   )["VC07LMSC"   ];
        VCLMSCR1_VC06LMSC               = (*VCLMSCR1   )["VC06LMSC"   ];
        VCLMSCR1_VC05LMSC               = (*VCLMSCR1   )["VC05LMSC"   ];
        VCLMSCR1_VC04LMSC               = (*VCLMSCR1   )["VC04LMSC"   ];
        VCLMSCR1_VC03LMSC               = (*VCLMSCR1   )["VC03LMSC"   ];
        VCLMSCR1_VC02LMSC               = (*VCLMSCR1   )["VC02LMSC"   ];
        VCLMSCR1_VC01LMSC               = (*VCLMSCR1   )["VC01LMSC"   ];
        VCLMSCR1_VC00LMSC               = (*VCLMSCR1   )["VC00LMSC"   ];
        return;
    }
    if (addr == 0x0744) {
        VCLMSCR2_VC47LMSC               = (*VCLMSCR2   )["VC47LMSC"   ];
        VCLMSCR2_VC46LMSC               = (*VCLMSCR2   )["VC46LMSC"   ];
        VCLMSCR2_VC45LMSC               = (*VCLMSCR2   )["VC45LMSC"   ];
        VCLMSCR2_VC44LMSC               = (*VCLMSCR2   )["VC44LMSC"   ];
        VCLMSCR2_VC43LMSC               = (*VCLMSCR2   )["VC43LMSC"   ];
        VCLMSCR2_VC42LMSC               = (*VCLMSCR2   )["VC42LMSC"   ];
        VCLMSCR2_VC41LMSC               = (*VCLMSCR2   )["VC41LMSC"   ];
        VCLMSCR2_VC40LMSC               = (*VCLMSCR2   )["VC40LMSC"   ];
        VCLMSCR2_VC39LMSC               = (*VCLMSCR2   )["VC39LMSC"   ];
        VCLMSCR2_VC38LMSC               = (*VCLMSCR2   )["VC38LMSC"   ];
        VCLMSCR2_VC37LMSC               = (*VCLMSCR2   )["VC37LMSC"   ];
        VCLMSCR2_VC36LMSC               = (*VCLMSCR2   )["VC36LMSC"   ];
        VCLMSCR2_VC35LMSC               = (*VCLMSCR2   )["VC35LMSC"   ];
        VCLMSCR2_VC34LMSC               = (*VCLMSCR2   )["VC34LMSC"   ];
        VCLMSCR2_VC33LMSC               = (*VCLMSCR2   )["VC33LMSC"   ];
        VCLMSCR2_VC32LMSC               = (*VCLMSCR2   )["VC32LMSC"   ];
        return;
    }
    if (addr == 0x0748) {
        ADOPDIG_ADOPDIGn0               = (*ADOPDIG    )["ADOPDIGn0"  ];
        ADOPDIG_ADOPDIGn1               = (*ADOPDIG    )["ADOPDIGn1"  ];
        ADOPDIG_ADOPDIGn2               = (*ADOPDIG    )["ADOPDIGn2"  ];
        ADOPDIG_ADOPDIGn3               = (*ADOPDIG    )["ADOPDIGn3"  ];
        ADOPDIG_ADOPDIGn4               = (*ADOPDIG    )["ADOPDIGn4"  ];
        ADOPDIG_ADOPDIGn5               = (*ADOPDIG    )["ADOPDIGn5"  ];
        ADOPDIG_ADOPDIGn6               = (*ADOPDIG    )["ADOPDIGn6"  ];
        ADOPDIG_ADOPDIGn7               = (*ADOPDIG    )["ADOPDIGn7"  ];
        ADOPDIG_ADOPDIGn8               = (*ADOPDIG    )["ADOPDIGn8"  ];
        ADOPDIG_ADOPDIGn9               = (*ADOPDIG    )["ADOPDIGn9"  ];
        ADOPDIG_ADOPDIGn10              = (*ADOPDIG    )["ADOPDIGn10" ];
        ADOPDIG_ADOPDIGn11              = (*ADOPDIG    )["ADOPDIGn11" ];
        return;
    }
}

/// Check address for multiple registers
/// @return true/false
bool Cadc_regif::ChkAddrWithFactorIndex(cuint num, cuint factor_index[], cuint len)
{
    assert(factor_index != NULL);
    for (uint i = 0; i < len; i++) {
        if (num == factor_index[i]) {
            return true;
        }
    }
    return false;
}

/// Update local value to bit value
/// @return None
void Cadc_regif::UpdateRegVal(cuint addr)
{
    if ((0x0000 <= addr) && (addr <= (0x0000)+(4*47)) && ((addr-0x0000)%4 == 0)) {
        uint i = (addr - 0x0000)/4;
        (*(VCR        [i]))["VCULME"     ] = VCR_VCULME[i];
        (*(VCR        [i]))["VCLLME"     ] = VCR_VCLLME[i];
        (*(VCR        [i]))["VCULLMTBS"  ] = VCR_VCULLMTBS[i];
        (*(VCR        [i]))["PUE"        ] = VCR_PUE[i];
        (*(VCR        [i]))["PDE"        ] = VCR_PDE[i];
        (*(VCR        [i]))["CNVCLS"     ] = VCR_CNVCLS[i];
        (*(VCR        [i]))["DFENT"      ] = VCR_DFENT[i];
        (*(VCR        [i]))["DFTAG"      ] = VCR_DFTAG[i];
        (*(VCR        [i]))["ADIE"       ] = VCR_ADIE[i];
        (*(VCR        [i]))["GCTRL"      ] = VCR_GCTRL[i];
        return;
    }
    if ((0x0100 <= addr) && (addr <= (0x0100)+(4*23)) && ((addr-0x0100)%4 == 0)) {
        uint i = (addr - 0x0100)/4;
        (*(DR         [i]))["DR1"        ] = DR_DR1[i];
        (*(DR         [i]))["DR0"        ] = DR_DR0[i];
        return;
    }
    if ((0x0200 <= addr) && (addr <= (0x0200)+(4*47)) && ((addr-0x0200)%4 == 0)) {
        uint i = (addr - 0x0200)/4;
        (*(DIR        [i]))["IDEF"       ] = DIR_IDEF[i];
        (*(DIR        [i]))["WFLG"       ] = DIR_WFLG[i];
        (*(DIR        [i]))["PRTY"       ] = DIR_PRTY[i];
        (*(DIR        [i]))["ID"         ] = DIR_ID[i];
        (*(DIR        [i]))["DRn"        ] = DIR_DRn[i];
        return;
    }
    if (addr == 0x0380) {
        (*ADHALTR    )["HALT"       ] = ADHALTR_HALT;
        return;
    }
    if (addr == 0x0384) {
        (*ADCR1      )["SUSMTD"     ] = ADCR1_SUSMTD;
        return;
    }
    if (addr == 0x0388) {
        (*MPXCURCR   )["MSKCFMT"    ] = MPXCURCR_MSKCFMT;
        return;
    }
    if (addr == 0x038A) {
        (*MPXINTER   )["ADMPXIE"    ] = MPXINTER_ADMPXIE;
        return;
    }
    if (addr == 0x038C) {
        (*MPXCURR    )["MSKC"       ] = MPXCURR_MSKC;
        (*MPXCURR    )["MPXCMD"     ] = MPXCURR_MPXCMD;
        (*MPXCURR    )["MPXCUR"     ] = MPXCURR_MPXCUR;
        return;
    }
    if (addr == 0x0390) {
        (*MPXOWR     )["MPXOW"      ] = MPXOWR_MPXOW;
        return;
    }
    if (addr == 0x0394) {
        (*MPXCMDR    )["MPXCMD"     ] = MPXCMDR_MPXCMD;
        return;
    }
    if (addr == 0x0398) {
        (*ADCR2      )["DFMT"       ] = ADCR2_DFMT;
        (*ADCR2      )["ADDNT"      ] = ADCR2_ADDNT;
        return;
    }
    if (addr == 0x039C) {
        (*DFASENTSGER)["DFENTSG4E"  ] = DFASENTSGER_DFENTSG4E;
        (*DFASENTSGER)["DFENTSG3E"  ] = DFASENTSGER_DFENTSG3E;
        (*DFASENTSGER)["DFENTSG2E"  ] = DFASENTSGER_DFENTSG2E;
        (*DFASENTSGER)["DFENTSG1E"  ] = DFASENTSGER_DFENTSG1E;
        (*DFASENTSGER)["DFENTSG0E"  ] = DFASENTSGER_DFENTSG0E;
        (*DFASENTSGER)["ASENTSG4E"  ] = DFASENTSGER_ASENTSG4E;
        (*DFASENTSGER)["ASENTSG3E"  ] = DFASENTSGER_ASENTSG3E;
        (*DFASENTSGER)["ASENTSG2E"  ] = DFASENTSGER_ASENTSG2E;
        (*DFASENTSGER)["ASENTSG1E"  ] = DFASENTSGER_ASENTSG1E;
        (*DFASENTSGER)["ASENTSG0E"  ] = DFASENTSGER_ASENTSG0E;
        return;
    }
    if ((0x03A0 <= addr) && (addr <= (0x03A0)+(4*4)) && ((addr-0x03A0)%4 == 0)) {
        uint i = (addr - 0x03A0)/4;
        (*(ADENDP     [i]))["ENDP"       ] = ADENDP_ENDP[i];
        return;
    }
    if (addr == 0x0400) {
        (*THSMPSTCR  )["SMPST"      ] = THSMPSTCR_SMPST;
        return;
    }
    if (addr == 0x0404) {
        (*THSTPCR    )["THSTP"      ] = THSTPCR_THSTP;
        return;
    }
    if (addr == 0x0408) {
        (*THCR       )["ASMPMSK"    ] = THCR_ASMPMSK;
        return;
    }
    if (addr == 0x0410) {
        (*THAHLDSTCR )["HLDST"      ] = THAHLDSTCR_HLDST;
        return;
    }
    if (addr == 0x0414) {
        (*THBHLDSTCR )["HLDST"      ] = THBHLDSTCR_HLDST;
        return;
    }
    if (addr == 0x0420) {
        (*THACR      )["HLDCTE"     ] = THACR_HLDCTE;
        (*THACR      )["HLDTE"      ] = THACR_HLDTE;
        (*THACR      )["SGS"        ] = THACR_SGS;
        return;
    }
    if (addr == 0x0424) {
        (*THBCR      )["HLDCTE"     ] = THBCR_HLDCTE;
        (*THBCR      )["HLDTE"      ] = THBCR_HLDTE;
        (*THBCR      )["SGS"        ] = THBCR_SGS;
        return;
    }
    if (addr == 0x0430) {
        (*THER       )["TH5E"       ] = THER_TH5E;
        (*THER       )["TH4E"       ] = THER_TH4E;
        (*THER       )["TH3E"       ] = THER_TH3E;
        (*THER       )["TH2E"       ] = THER_TH2E;
        (*THER       )["TH1E"       ] = THER_TH1E;
        (*THER       )["TH0E"       ] = THER_TH0E;
        return;
    }
    if (addr == 0x0434) {
        (*THGSR      )["TH5GS"      ] = THGSR_TH5GS;
        (*THGSR      )["TH4GS"      ] = THGSR_TH4GS;
        (*THGSR      )["TH3GS"      ] = THGSR_TH3GS;
        (*THGSR      )["TH2GS"      ] = THGSR_TH2GS;
        (*THGSR      )["TH1GS"      ] = THGSR_TH1GS;
        (*THGSR      )["TH0GS"      ] = THGSR_TH0GS;
        return;
    }
    if (addr == 0x0440) {
        (*THOMSR     )["KEY"        ] = THOMSR_KEY;
        (*THOMSR     )["THOMS"      ] = THOMSR_THOMS;
        return;
    }
    if (addr == 0x03C0) {
        (*SFTCR      )["SYNCEIE"    ] = SFTCR_SYNCEIE;
        (*SFTCR      )["RDCLRE"     ] = SFTCR_RDCLRE;
        (*SFTCR      )["ULEIE"      ] = SFTCR_ULEIE;
        (*SFTCR      )["OWEIE"      ] = SFTCR_OWEIE;
        (*SFTCR      )["PEIE"       ] = SFTCR_PEIE;
        (*SFTCR      )["IDEIE"      ] = SFTCR_IDEIE;
        return;
    }
    if (addr == 0x03C4) {
        (*TDCR       )["TDE"        ] = TDCR_TDE;
        (*TDCR       )["TDLV"       ] = TDCR_TDLV;
        return;
    }
    if (addr == 0x03C8) {
        (*ODCR       )["ODDE"       ] = ODCR_ODDE;
        (*ODCR       )["DSCE"       ] = ODCR_DSCE;
        (*ODCR       )["ODE"        ] = ODCR_ODE;
        (*ODCR       )["ODPW"       ] = ODCR_ODPW;
        return;
    }
    if ((0x03CC <= addr) && (addr <= (0x03CC)+(4*2)) && ((addr-0x03CC)%4 == 0)) {
        uint i = (addr - 0x03CC)/4;
        (*(ULLMTBR    [i]))["ULMTB"      ] = ULLMTBR_ULMTB[i];
        (*(ULLMTBR    [i]))["LLMTB"      ] = ULLMTBR_LLMTB[i];
        return;
    }
    if (addr == 0x03D8) {
        (*ECR        )["SYNCEC"     ] = ECR_SYNCEC;
        (*ECR        )["ULEC"       ] = ECR_ULEC;
        (*ECR        )["OWEC"       ] = ECR_OWEC;
        (*ECR        )["PEC"        ] = ECR_PEC;
        (*ECR        )["IDEC"       ] = ECR_IDEC;
        return;
    }
    if (addr == 0x03DC) {
        (*ULER       )["ULE"        ] = ULER_ULE;
        (*ULER       )["ULECAP"     ] = ULER_ULECAP;
        return;
    }
    if (addr == 0x03E0) {
        (*OWER       )["OWE"        ] = OWER_OWE;
        (*OWER       )["OWECAP"     ] = OWER_OWECAP;
        return;
    }
    if (addr == 0x03E4) {
        (*PER        )["PE"         ] = PER_PE;
        (*PER        )["PECAP"      ] = PER_PECAP;
        return;
    }
    if (addr == 0x03E8) {
        (*IDER       )["IDE"        ] = IDER_IDE;
        (*IDER       )["IDECAP"     ] = IDER_IDECAP;
        return;
    }
    if (addr == 0x03EC) {
        (*SYNCER     )["SYNCE"      ] = SYNCER_SYNCE;
        return;
    }
    if (addr == 0x0340) {
        (*SMPCR      )["BUFAMPD"    ] = SMPCR_BUFAMPD;
        (*SMPCR      )["SMPT13_14"  ] = SMPCR_SMPT13_14;
        (*SMPCR      )["SMPTS"      ] = SMPCR_SMPTS;
        (*SMPCR      )["SMPT8_11"   ] = SMPCR_SMPT8_11;
        (*SMPCR      )["SMPT"       ] = SMPCR_SMPT;
        return;
    }
    if (addr == 0x0360) {
        (*TRMCR      )["TRMS"       ] = TRMCR_TRMS;
        (*TRMCR      )["TRMTTUNE"   ] = TRMCR_TRMTTUNE;
        (*TRMCR      )["TRMBTUNE"   ] = TRMCR_TRMBTUNE;
        (*TRMCR      )["TRMATUNE"   ] = TRMCR_TRMATUNE;
        (*TRMCR      )["TRMT"       ] = TRMCR_TRMT;
        (*TRMCR      )["TRMB"       ] = TRMCR_TRMB;
        (*TRMCR      )["TRMA"       ] = TRMCR_TRMA;
        return;
    }
    if (addr == 0x0364) {
        (*ADTSTRA    )["ADTST"      ] = ADTSTRA_ADTST;
        return;
    }
    if (addr == 0x0368) {
        (*ADTSTRB    )["ADVAL"      ] = ADTSTRB_ADVAL;
        return;
    }
    if (addr == 0x036C) {
        (*ADTSTRC    )["CKSTP"      ] = ADTSTRC_CKSTP;
        (*ADTSTRC    )["ADMD"       ] = ADTSTRC_ADMD;
        return;
    }
    if ((0x0480 <= addr) && (addr <= (0x0480)+(128*4)) && ((addr-0x0480)%128 == 0)) {
        uint i = (addr - 0x0480)/128;
        (*(SGSTCR     [i]))["SGST"       ] = SGSTCR_SGST[i];
        return;
    }
    if ((0x0484 <= addr) && (addr <= (0x0484)+(128*4)) && ((addr-0x0484)%128 == 0)) {
        uint i = (addr - 0x0484)/128;
        (*(SGSTPCR    [i]))["SGSTP"      ] = SGSTPCR_SGSTP[i];
        return;
    }
    if ((0x0608 <= addr) && (addr <= (0x0608)+(128*1)) && ((addr-0x0608)%128 == 0) && ChkAddrWithFactorIndex((addr-0x0608)/128 + 3, mFactorIndexADTSTCR, 2)) {
        uint i = (addr - 0x0608)/128 + 3;
        (*(ADTSTCR    [i]))["ADTST"      ] = ADTSTCR_ADTST[i];
        return;
    }
    if ((0x060C <= addr) && (addr <= (0x060C)+(128*1)) && ((addr-0x060C)%128 == 0) && ChkAddrWithFactorIndex((addr-0x060C)/128 + 3, mFactorIndexADTENDCR, 2)) {
        uint i = (addr - 0x060C)/128 + 3;
        (*(ADTENDCR   [i]))["ADTEND"     ] = ADTENDCR_ADTEND[i];
        return;
    }
    if ((0x0490 <= addr) && (addr <= (0x0490)+(128*4)) && ((addr-0x0490)%128 == 0)) {
        uint i = (addr - 0x0490)/128;
        (*(SGCR       [i]))["ADTSTARTE"  ] = SGCR_ADTSTARTE[i];
        (*(SGCR       [i]))["ADSTARTE"   ] = SGCR_ADSTARTE[i];
        (*(SGCR       [i]))["SCANMD"     ] = SGCR_SCANMD[i];
        (*(SGCR       [i]))["ADIE"       ] = SGCR_ADIE[i];
        (*(SGCR       [i]))["TRGMD"      ] = SGCR_TRGMD[i];
        return;
    }
    if ((0x0494 <= addr) && (addr <= (0x0494)+(128*4)) && ((addr-0x0494)%128 == 0)) {
        uint i = (addr - 0x0494)/128;
        (*(SGVCSP     [i]))["VCSP"       ] = SGVCSP_VCSP[i];
        return;
    }
    if ((0x0498 <= addr) && (addr <= (0x0498)+(128*4)) && ((addr-0x0498)%128 == 0)) {
        uint i = (addr - 0x0498)/128;
        (*(SGVCEP     [i]))["VCEP"       ] = SGVCEP_VCEP[i];
        return;
    }
    if ((0x049C <= addr) && (addr <= (0x049C)+(128*4)) && ((addr-0x049C)%128 == 0)) {
        uint i = (addr - 0x049C)/128;
        (*(SGMCYCR    [i]))["MCYC"       ] = SGMCYCR_MCYC[i];
        return;
    }
    if ((0x04A0 <= addr) && (addr <= (0x04A0)+(128*4)) && ((addr-0x04A0)%128 == 0)) {
        uint i = (addr - 0x04A0)/128;
        (*(SGVCPR     [i]))["VCEP"       ] = SGVCPR_VCEP[i];
        (*(SGVCPR     [i]))["VCSP"       ] = SGVCPR_VCSP[i];
        return;
    }
    if ((0x04B4 <= addr) && (addr <= (0x04B4)+(128*4)) && ((addr-0x04B4)%128 == 0)) {
        uint i = (addr - 0x04B4)/128;
        (*(SGVCOWR    [i]))["VCOW"       ] = SGVCOWR_VCOW[i];
        return;
    }
    if ((0x04A4 <= addr) && (addr <= (0x04A4)+(128*4)) && ((addr-0x04A4)%128 == 0)) {
        uint i = (addr - 0x04A4)/128;
        (*(SGSR       [i]))["ADTACT"     ] = SGSR_ADTACT[i];
        (*(SGSR       [i]))["SGACT"      ] = SGSR_SGACT[i];
        return;
    }
    if ((0x0628 <= addr) && (addr <= (0x0628)+(128*1)) && ((addr-0x0628)%128 == 0) && ChkAddrWithFactorIndex((addr-0x0628)/128 + 3, mFactorIndexADTIPR, 2)) {
        uint i = (addr - 0x0628)/128 + 3;
        (*(ADTIPR     [i]))["ADTIP"      ] = ADTIPR_ADTIP[i];
        return;
    }
    if ((0x062C <= addr) && (addr <= (0x062C)+(128*1)) && ((addr-0x062C)%128 == 0) && ChkAddrWithFactorIndex((addr-0x062C)/128 + 3, mFactorIndexADTPRR, 2)) {
        uint i = (addr - 0x062C)/128 + 3;
        (*(ADTPRR     [i]))["ADTPR"      ] = ADTPRR_ADTPR[i];
        return;
    }
    if ((0x04B0 <= addr) && (addr <= (0x04B0)+(128*4)) && ((addr-0x04B0)%128 == 0)) {
        uint i = (addr - 0x04B0)/128;
        (*(ULLMSR     [i]))["ULS"        ] = ULLMSR_ULS[i];
        return;
    }
    if ((0x0700 <= addr) && (addr <= (0x0700)+(4*6)) && ((addr-0x0700)%4 == 0)) {
        uint i = (addr - 0x0700)/4;
        (*(VCULLMTBR  [i]))["VCULMTB"    ] = VCULLMTBR_VCULMTB[i];
        (*(VCULLMTBR  [i]))["VCLLMTB"    ] = VCULLMTBR_VCLLMTB[i];
        return;
    }
    if (addr == 0x0730) {
        (*VCLMINTER1 )["ADUL31IE"   ] = VCLMINTER1_ADUL31IE;
        (*VCLMINTER1 )["ADUL30IE"   ] = VCLMINTER1_ADUL30IE;
        (*VCLMINTER1 )["ADUL29IE"   ] = VCLMINTER1_ADUL29IE;
        (*VCLMINTER1 )["ADUL28IE"   ] = VCLMINTER1_ADUL28IE;
        (*VCLMINTER1 )["ADUL27IE"   ] = VCLMINTER1_ADUL27IE;
        (*VCLMINTER1 )["ADUL26IE"   ] = VCLMINTER1_ADUL26IE;
        (*VCLMINTER1 )["ADUL25IE"   ] = VCLMINTER1_ADUL25IE;
        (*VCLMINTER1 )["ADUL24IE"   ] = VCLMINTER1_ADUL24IE;
        (*VCLMINTER1 )["ADUL23IE"   ] = VCLMINTER1_ADUL23IE;
        (*VCLMINTER1 )["ADUL22IE"   ] = VCLMINTER1_ADUL22IE;
        (*VCLMINTER1 )["ADUL21IE"   ] = VCLMINTER1_ADUL21IE;
        (*VCLMINTER1 )["ADUL20IE"   ] = VCLMINTER1_ADUL20IE;
        (*VCLMINTER1 )["ADUL19IE"   ] = VCLMINTER1_ADUL19IE;
        (*VCLMINTER1 )["ADUL18IE"   ] = VCLMINTER1_ADUL18IE;
        (*VCLMINTER1 )["ADUL17IE"   ] = VCLMINTER1_ADUL17IE;
        (*VCLMINTER1 )["ADUL16IE"   ] = VCLMINTER1_ADUL16IE;
        (*VCLMINTER1 )["ADUL15IE"   ] = VCLMINTER1_ADUL15IE;
        (*VCLMINTER1 )["ADUL14IE"   ] = VCLMINTER1_ADUL14IE;
        (*VCLMINTER1 )["ADUL13IE"   ] = VCLMINTER1_ADUL13IE;
        (*VCLMINTER1 )["ADUL12IE"   ] = VCLMINTER1_ADUL12IE;
        (*VCLMINTER1 )["ADUL11IE"   ] = VCLMINTER1_ADUL11IE;
        (*VCLMINTER1 )["ADUL10IE"   ] = VCLMINTER1_ADUL10IE;
        (*VCLMINTER1 )["ADUL09IE"   ] = VCLMINTER1_ADUL09IE;
        (*VCLMINTER1 )["ADUL08IE"   ] = VCLMINTER1_ADUL08IE;
        (*VCLMINTER1 )["ADUL07IE"   ] = VCLMINTER1_ADUL07IE;
        (*VCLMINTER1 )["ADUL06IE"   ] = VCLMINTER1_ADUL06IE;
        (*VCLMINTER1 )["ADUL05IE"   ] = VCLMINTER1_ADUL05IE;
        (*VCLMINTER1 )["ADUL04IE"   ] = VCLMINTER1_ADUL04IE;
        (*VCLMINTER1 )["ADUL03IE"   ] = VCLMINTER1_ADUL03IE;
        (*VCLMINTER1 )["ADUL02IE"   ] = VCLMINTER1_ADUL02IE;
        (*VCLMINTER1 )["ADUL01IE"   ] = VCLMINTER1_ADUL01IE;
        (*VCLMINTER1 )["ADUL00IE"   ] = VCLMINTER1_ADUL00IE;
        return;
    }
    if (addr == 0x0734) {
        (*VCLMINTER2 )["ADUL47IE"   ] = VCLMINTER2_ADUL47IE;
        (*VCLMINTER2 )["ADUL46IE"   ] = VCLMINTER2_ADUL46IE;
        (*VCLMINTER2 )["ADUL45IE"   ] = VCLMINTER2_ADUL45IE;
        (*VCLMINTER2 )["ADUL44IE"   ] = VCLMINTER2_ADUL44IE;
        (*VCLMINTER2 )["ADUL43IE"   ] = VCLMINTER2_ADUL43IE;
        (*VCLMINTER2 )["ADUL42IE"   ] = VCLMINTER2_ADUL42IE;
        (*VCLMINTER2 )["ADUL41IE"   ] = VCLMINTER2_ADUL41IE;
        (*VCLMINTER2 )["ADUL40IE"   ] = VCLMINTER2_ADUL40IE;
        (*VCLMINTER2 )["ADUL39IE"   ] = VCLMINTER2_ADUL39IE;
        (*VCLMINTER2 )["ADUL38IE"   ] = VCLMINTER2_ADUL38IE;
        (*VCLMINTER2 )["ADUL37IE"   ] = VCLMINTER2_ADUL37IE;
        (*VCLMINTER2 )["ADUL36IE"   ] = VCLMINTER2_ADUL36IE;
        (*VCLMINTER2 )["ADUL35IE"   ] = VCLMINTER2_ADUL35IE;
        (*VCLMINTER2 )["ADUL34IE"   ] = VCLMINTER2_ADUL34IE;
        (*VCLMINTER2 )["ADUL33IE"   ] = VCLMINTER2_ADUL33IE;
        (*VCLMINTER2 )["ADUL32IE"   ] = VCLMINTER2_ADUL32IE;
        return;
    }
    if (addr == 0x0738) {
        (*VCLMSR1    )["VC31LMS"    ] = VCLMSR1_VC31LMS;
        (*VCLMSR1    )["VC30LMS"    ] = VCLMSR1_VC30LMS;
        (*VCLMSR1    )["VC29LMS"    ] = VCLMSR1_VC29LMS;
        (*VCLMSR1    )["VC28LMS"    ] = VCLMSR1_VC28LMS;
        (*VCLMSR1    )["VC27LMS"    ] = VCLMSR1_VC27LMS;
        (*VCLMSR1    )["VC26LMS"    ] = VCLMSR1_VC26LMS;
        (*VCLMSR1    )["VC25LMS"    ] = VCLMSR1_VC25LMS;
        (*VCLMSR1    )["VC24LMS"    ] = VCLMSR1_VC24LMS;
        (*VCLMSR1    )["VC23LMS"    ] = VCLMSR1_VC23LMS;
        (*VCLMSR1    )["VC22LMS"    ] = VCLMSR1_VC22LMS;
        (*VCLMSR1    )["VC21LMS"    ] = VCLMSR1_VC21LMS;
        (*VCLMSR1    )["VC20LMS"    ] = VCLMSR1_VC20LMS;
        (*VCLMSR1    )["VC19LMS"    ] = VCLMSR1_VC19LMS;
        (*VCLMSR1    )["VC18LMS"    ] = VCLMSR1_VC18LMS;
        (*VCLMSR1    )["VC17LMS"    ] = VCLMSR1_VC17LMS;
        (*VCLMSR1    )["VC16LMS"    ] = VCLMSR1_VC16LMS;
        (*VCLMSR1    )["VC15LMS"    ] = VCLMSR1_VC15LMS;
        (*VCLMSR1    )["VC14LMS"    ] = VCLMSR1_VC14LMS;
        (*VCLMSR1    )["VC13LMS"    ] = VCLMSR1_VC13LMS;
        (*VCLMSR1    )["VC12LMS"    ] = VCLMSR1_VC12LMS;
        (*VCLMSR1    )["VC11LMS"    ] = VCLMSR1_VC11LMS;
        (*VCLMSR1    )["VC10LMS"    ] = VCLMSR1_VC10LMS;
        (*VCLMSR1    )["VC09LMS"    ] = VCLMSR1_VC09LMS;
        (*VCLMSR1    )["VC08LMS"    ] = VCLMSR1_VC08LMS;
        (*VCLMSR1    )["VC07LMS"    ] = VCLMSR1_VC07LMS;
        (*VCLMSR1    )["VC06LMS"    ] = VCLMSR1_VC06LMS;
        (*VCLMSR1    )["VC05LMS"    ] = VCLMSR1_VC05LMS;
        (*VCLMSR1    )["VC04LMS"    ] = VCLMSR1_VC04LMS;
        (*VCLMSR1    )["VC03LMS"    ] = VCLMSR1_VC03LMS;
        (*VCLMSR1    )["VC02LMS"    ] = VCLMSR1_VC02LMS;
        (*VCLMSR1    )["VC01LMS"    ] = VCLMSR1_VC01LMS;
        (*VCLMSR1    )["VC00LMS"    ] = VCLMSR1_VC00LMS;
        return;
    }
    if (addr == 0x073C) {
        (*VCLMSR2    )["VC47LMS"    ] = VCLMSR2_VC47LMS;
        (*VCLMSR2    )["VC46LMS"    ] = VCLMSR2_VC46LMS;
        (*VCLMSR2    )["VC45LMS"    ] = VCLMSR2_VC45LMS;
        (*VCLMSR2    )["VC44LMS"    ] = VCLMSR2_VC44LMS;
        (*VCLMSR2    )["VC43LMS"    ] = VCLMSR2_VC43LMS;
        (*VCLMSR2    )["VC42LMS"    ] = VCLMSR2_VC42LMS;
        (*VCLMSR2    )["VC41LMS"    ] = VCLMSR2_VC41LMS;
        (*VCLMSR2    )["VC40LMS"    ] = VCLMSR2_VC40LMS;
        (*VCLMSR2    )["VC39LMS"    ] = VCLMSR2_VC39LMS;
        (*VCLMSR2    )["VC38LMS"    ] = VCLMSR2_VC38LMS;
        (*VCLMSR2    )["VC37LMS"    ] = VCLMSR2_VC37LMS;
        (*VCLMSR2    )["VC36LMS"    ] = VCLMSR2_VC36LMS;
        (*VCLMSR2    )["VC35LMS"    ] = VCLMSR2_VC35LMS;
        (*VCLMSR2    )["VC34LMS"    ] = VCLMSR2_VC34LMS;
        (*VCLMSR2    )["VC33LMS"    ] = VCLMSR2_VC33LMS;
        (*VCLMSR2    )["VC32LMS"    ] = VCLMSR2_VC32LMS;
        return;
    }
    if (addr == 0x0740) {
        (*VCLMSCR1   )["VC31LMSC"   ] = VCLMSCR1_VC31LMSC;
        (*VCLMSCR1   )["VC30LMSC"   ] = VCLMSCR1_VC30LMSC;
        (*VCLMSCR1   )["VC29LMSC"   ] = VCLMSCR1_VC29LMSC;
        (*VCLMSCR1   )["VC28LMSC"   ] = VCLMSCR1_VC28LMSC;
        (*VCLMSCR1   )["VC27LMSC"   ] = VCLMSCR1_VC27LMSC;
        (*VCLMSCR1   )["VC26LMSC"   ] = VCLMSCR1_VC26LMSC;
        (*VCLMSCR1   )["VC25LMSC"   ] = VCLMSCR1_VC25LMSC;
        (*VCLMSCR1   )["VC24LMSC"   ] = VCLMSCR1_VC24LMSC;
        (*VCLMSCR1   )["VC23LMSC"   ] = VCLMSCR1_VC23LMSC;
        (*VCLMSCR1   )["VC22LMSC"   ] = VCLMSCR1_VC22LMSC;
        (*VCLMSCR1   )["VC21LMSC"   ] = VCLMSCR1_VC21LMSC;
        (*VCLMSCR1   )["VC20LMSC"   ] = VCLMSCR1_VC20LMSC;
        (*VCLMSCR1   )["VC19LMSC"   ] = VCLMSCR1_VC19LMSC;
        (*VCLMSCR1   )["VC18LMSC"   ] = VCLMSCR1_VC18LMSC;
        (*VCLMSCR1   )["VC17LMSC"   ] = VCLMSCR1_VC17LMSC;
        (*VCLMSCR1   )["VC16LMSC"   ] = VCLMSCR1_VC16LMSC;
        (*VCLMSCR1   )["VC15LMSC"   ] = VCLMSCR1_VC15LMSC;
        (*VCLMSCR1   )["VC14LMSC"   ] = VCLMSCR1_VC14LMSC;
        (*VCLMSCR1   )["VC13LMSC"   ] = VCLMSCR1_VC13LMSC;
        (*VCLMSCR1   )["VC12LMSC"   ] = VCLMSCR1_VC12LMSC;
        (*VCLMSCR1   )["VC11LMSC"   ] = VCLMSCR1_VC11LMSC;
        (*VCLMSCR1   )["VC10LMSC"   ] = VCLMSCR1_VC10LMSC;
        (*VCLMSCR1   )["VC09LMSC"   ] = VCLMSCR1_VC09LMSC;
        (*VCLMSCR1   )["VC08LMSC"   ] = VCLMSCR1_VC08LMSC;
        (*VCLMSCR1   )["VC07LMSC"   ] = VCLMSCR1_VC07LMSC;
        (*VCLMSCR1   )["VC06LMSC"   ] = VCLMSCR1_VC06LMSC;
        (*VCLMSCR1   )["VC05LMSC"   ] = VCLMSCR1_VC05LMSC;
        (*VCLMSCR1   )["VC04LMSC"   ] = VCLMSCR1_VC04LMSC;
        (*VCLMSCR1   )["VC03LMSC"   ] = VCLMSCR1_VC03LMSC;
        (*VCLMSCR1   )["VC02LMSC"   ] = VCLMSCR1_VC02LMSC;
        (*VCLMSCR1   )["VC01LMSC"   ] = VCLMSCR1_VC01LMSC;
        (*VCLMSCR1   )["VC00LMSC"   ] = VCLMSCR1_VC00LMSC;
        return;
    }
    if (addr == 0x0744) {
        (*VCLMSCR2   )["VC47LMSC"   ] = VCLMSCR2_VC47LMSC;
        (*VCLMSCR2   )["VC46LMSC"   ] = VCLMSCR2_VC46LMSC;
        (*VCLMSCR2   )["VC45LMSC"   ] = VCLMSCR2_VC45LMSC;
        (*VCLMSCR2   )["VC44LMSC"   ] = VCLMSCR2_VC44LMSC;
        (*VCLMSCR2   )["VC43LMSC"   ] = VCLMSCR2_VC43LMSC;
        (*VCLMSCR2   )["VC42LMSC"   ] = VCLMSCR2_VC42LMSC;
        (*VCLMSCR2   )["VC41LMSC"   ] = VCLMSCR2_VC41LMSC;
        (*VCLMSCR2   )["VC40LMSC"   ] = VCLMSCR2_VC40LMSC;
        (*VCLMSCR2   )["VC39LMSC"   ] = VCLMSCR2_VC39LMSC;
        (*VCLMSCR2   )["VC38LMSC"   ] = VCLMSCR2_VC38LMSC;
        (*VCLMSCR2   )["VC37LMSC"   ] = VCLMSCR2_VC37LMSC;
        (*VCLMSCR2   )["VC36LMSC"   ] = VCLMSCR2_VC36LMSC;
        (*VCLMSCR2   )["VC35LMSC"   ] = VCLMSCR2_VC35LMSC;
        (*VCLMSCR2   )["VC34LMSC"   ] = VCLMSCR2_VC34LMSC;
        (*VCLMSCR2   )["VC33LMSC"   ] = VCLMSCR2_VC33LMSC;
        (*VCLMSCR2   )["VC32LMSC"   ] = VCLMSCR2_VC32LMSC;
        return;
    }
    if (addr == 0x0748) {
        (*ADOPDIG    )["ADOPDIGn0"  ] = ADOPDIG_ADOPDIGn0;
        (*ADOPDIG    )["ADOPDIGn1"  ] = ADOPDIG_ADOPDIGn1;
        (*ADOPDIG    )["ADOPDIGn2"  ] = ADOPDIG_ADOPDIGn2;
        (*ADOPDIG    )["ADOPDIGn3"  ] = ADOPDIG_ADOPDIGn3;
        (*ADOPDIG    )["ADOPDIGn4"  ] = ADOPDIG_ADOPDIGn4;
        (*ADOPDIG    )["ADOPDIGn5"  ] = ADOPDIG_ADOPDIGn5;
        (*ADOPDIG    )["ADOPDIGn6"  ] = ADOPDIG_ADOPDIGn6;
        (*ADOPDIG    )["ADOPDIGn7"  ] = ADOPDIG_ADOPDIGn7;
        (*ADOPDIG    )["ADOPDIGn8"  ] = ADOPDIG_ADOPDIGn8;
        (*ADOPDIG    )["ADOPDIGn9"  ] = ADOPDIG_ADOPDIGn9;
        (*ADOPDIG    )["ADOPDIGn10" ] = ADOPDIG_ADOPDIGn10;
        (*ADOPDIG    )["ADOPDIGn11" ] = ADOPDIG_ADOPDIGn11;
        return;
    }
}

/// convert string to vector
/// @return vector
std::vector<std::string> Cadc_regif::Str2Vec(std::string str, const char sep)
{
    std::vector<std::string> buf;
    std::string::size_type index = 0;
    for (uint i=0 ; i<str.size() ; i++) {
        if (str[i] == sep) {
            buf.push_back(str.substr(index, i-index));
            index = i+1;
        }
    }
    buf.push_back(str.substr(index));
    return buf;
}

/// Align nuber to hexadecimal format
/// @return aligned number
std::string Cadc_regif::Num2HexStr(cuint num, cuint num_length, bool space_strip, bool is_wr_data, uint acc_size)
{
    std::ostringstream str_tmp;
    #ifdef MSG_WO_WR_DATA
    str_tmp<<"0x"<<std::hex<<std::uppercase<<std::right<<num;
    str_tmp<<std::setfill(' ')<<std::setw(10-str_tmp.str().length())<<"";
    #else
    uint total_length = 0;
    acc_size = acc_size*8;
    if ((acc_size < num_length) && is_wr_data) {
        total_length = (acc_size + 3)/4; // Calculate number of hexadecimal number
    } else {
        total_length = (num_length + 3)/4; // Calculate number of hexadecimal number
    }
    str_tmp<<"0x"<<std::setfill('0')<<std::setw(total_length)<<std::hex<<std::uppercase<<std::right<<num;
    if (!space_strip) {
        str_tmp<<std::setfill(' ')<<std::setw(10-str_tmp.str().length())<<"";   
    }
    #endif
    return str_tmp.str();
}

/// Dump register access information
/// @return none
void Cadc_regif::DumpRegMsg(const std::string operation, const std::string RegName, const std::string BitName, cuint size, cuint addr, cuint wr_data, cuint pre_data, cuint data, cuint reg_length)
{
    if (mDumpRegisterRW) {
        std::string reg_name = RegName;
        std::ostringstream str_tmp;
        if (BitName != "") {
            reg_name += ":" + BitName;
        }
        str_tmp<<"REG ["<<std::setw(15)<<std::left<<reg_name<<"] ";
        str_tmp<<operation;
        str_tmp<<" Size= "<<size;
        str_tmp<<" Addr= "<<Num2HexStr(addr,11, false, false, size);
        if (operation == "R") {
            str_tmp<<" Data= "<<Num2HexStr(data    , reg_length, true, true, size);
        } else {
            #ifdef MSG_WO_WR_DATA
            str_tmp<<" Data= "<<Num2HexStr(pre_data, reg_length, false, false, size);
            #else
            str_tmp<<" Data= "<<Num2HexStr(wr_data , reg_length, false, true, size);
            str_tmp<<" : "    <<Num2HexStr(pre_data, reg_length, false, false, size);
            #endif
            str_tmp<<" => "   <<Num2HexStr(data    , reg_length, true, false, size);
        }
        re_printf("DumpRegMsg", "%s\n", str_tmp.str().c_str());
    }
}

/// find register pointer based on accessed address
/// @return accessed register pointer
int Cadc_regif::get_reg_index(cuint access_addr)
{
    if (mRegMap[access_addr] != (1<<11)) {
        return mRegMap[access_addr];
    } else {
        return -1;
    }
}

/// find first register pointer
/// @return first register pointer
vpcl::re_register *Cadc_regif::first_reg_object()
{
    mCurReg = mRegList;
    return mCurReg->my_p;
}

/// find next register pointer
/// @return next register pointer
vpcl::re_register *Cadc_regif::next_reg_object()
{
    if (mCurReg != NULL) {
        mCurReg = mCurReg->prev;
        if (mCurReg != NULL) {
            return mCurReg->my_p;
        }
    }
    return NULL;
}

/// write callback function of CoWare
/// @return none
void Cadc_regif::wr_cb(cuint addr, uint data)
{
    #ifdef CWR_SYSTEMC
    cwmem.put( (addr&0xFFFF), data);
    #else
    array[addr&0xFFFF] = data;
    #endif
}

/// read callback function of CoWare
/// @return read data
Cadc_regif::uint Cadc_regif::rd_cb(cuint addr)
{
    #ifdef CWR_SYSTEMC
    uint data=0;
    data = cwmem.get((addr&0xFFFF));
    return data;
    #else
    return array[addr&0xFFFF];
    #endif
}

/// print message function
/// @return none
void Cadc_regif::_re_printf(std::string group, const char *message, ...)
{
    // message group check
    if (group == "DumpRegMsg") {
        group = "info";
    } else {
        #ifndef REGIF_SC_REPORT
        if (!mMessageLevel[group]) return;
        #endif//REGIF_SC_REPORT
    }

    if (message == NULL) return;

    // print header
    #ifndef REGIF_NOT_USE_SYSTEMC
    std::stringstream t_stream;
    std::string cur_time;

    double tu_value = 0;
    std::string tu_name = "";
    if (sc_get_time_resolution() < sc_time(1, SC_PS)) {
        tu_value = 1000000000000000LL;
        tu_name = " fs";
    } else if (sc_get_time_resolution() < sc_time(1, SC_NS)) {
        tu_value = 1000000000000LL;
        tu_name = " ps";
    } else if (sc_get_time_resolution() < sc_time(1, SC_US)) {
        tu_value = 1000000000;
        tu_name = " ns";
    } else if (sc_get_time_resolution() < sc_time(1, SC_MS)) {
        tu_value = 1000000;
        tu_name = " us";
    } else if (sc_get_time_resolution() < sc_time(1, SC_SEC)) {
        tu_value = 1000;
        tu_name = " ms";
    } else {
        tu_value = 1;
        tu_name = " s";
    }
    t_stream << sc_time_stamp().value() * (uint64) (sc_get_time_resolution().to_seconds() * tu_value) << tu_name;

    cur_time = t_stream.str();
    #else
    std::string cur_time = "";
    #endif

    #ifndef REGIF_SC_REPORT
    #ifdef MSG_COLOR
    // color setting
    //
    // severity color       color Linux       Windows
    // fatal    RED         RED   \033[0;31m  FOREGROUND_RED
    // error    RED         BLUE  \033[0;34m  FOREGROUND_BLUE
    // warning  RED
    // info     BLUE
    #ifdef _WIN32
    HANDLE hStdout;
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    if (group == "fatal" || group == "error" || group == "warning") {
        SetConsoleTextAttribute(hStdout, FOREGROUND_RED);
    } else if (group == "info" ){
        SetConsoleTextAttribute(hStdout, FOREGROUND_BLUE);
    }
    #else
    if (group == "fatal" || group == "error" || group == "warning") {
        printf("\033[0;31m");
    } else if (group == "info" ){
        printf("\033[0;34m");
    }
    #endif
    #endif //MSG_COLOR
    printf("%8s [%20s] (%10s) ", group.c_str(), cur_time.c_str(), mInstName.c_str());
    #endif//REGIF_SC_REPORT

    // print body
    va_list argptr;
    va_start(argptr, message);
    if (argptr == NULL) return;
    #ifdef REGIF_SC_REPORT
    char str[1024];
    sprintf(str, "[%20s] ", cur_time.c_str());
    vsprintf(str+23, message, argptr);
    if (group == "fatal") {
        SC_REPORT_FATAL(mInstName.c_str(), str);
    } else if (group == "error") {
        SC_REPORT_ERROR(mInstName.c_str(), str);
    } else if (group == "warning") {
        SC_REPORT_WARNING(mInstName.c_str(), str);
    } else if (group == "info") {
        SC_REPORT_INFO(mInstName.c_str(), str);
    }
    #else //REGIF_SC_REPORT
    vprintf(message, argptr);
    #endif//REGIF_SC_REPORT

    #ifndef REGIF_SC_REPORT
    #ifdef DumpFileNameLineNum
    // print footer
    if (group == "fatal" || group == "error") {
        printf(" [%s:%d]\n", mFileName.c_str(), mLineNum);
    }
    #endif//DumpFileNameLineNum
    #endif//REGIF_SC_REPORT
    va_end(argptr);

    #ifndef REGIF_SC_REPORT
    #ifdef MSG_COLOR
    #ifdef _WIN32
    SetConsoleTextAttribute(hStdout, csbi.wAttributes);
    #else
    printf("\033[m");
    #endif
    #endif //MSG_COLOR
    #endif//REGIF_SC_REPORT

    fflush(stdout);
    fflush(stderr);

    if (group == "fatal") {
        exit(1);
    }
}

/// Get file name and line number
/// @return none
void Cadc_regif::get_fileline(std::string filename, int line_number)
{
    mFileName = filename;
    mLineNum  = line_number;
}

/// API for instance registration
/// @return none
void Cadc_regif::set_instance_name(std::string InstName)
{
    mInstName = InstName;
}

/// Method to change value of mIsReset
/// @return none
void Cadc_regif::EnableReset(const bool is_active)
{
    // update register IF class's reset status
    mIsReset = is_active;

    // update re_register's reset status
    for (uint i = 0; i < mTotalRegNum; i++) {
        mRegArray[i]->my_p->EnableReset(is_active);
        if (is_active) {
            re_printf("info", "Initialize %s (%08x)\n", mRegArray[i]->my_p->name().c_str(), (uint)(*mRegArray[i]->my_p));
        }
    }

    if (is_active) {
        InitLocalVal(); // Initialize local variable
    }
}

#ifdef CWR_SYSTEMC
uint Cadc_regif::cw_rd_cb(tlm::tlm_generic_payload& trans, int tag)
{
    int reg_index = get_reg_index((uint)tag);
    assert(reg_index != (1<<16));
    uint length = mRegArray[reg_index]->length;
    uint tmp_addr = (uint)tag;
    #ifdef IS_MODELED_ENDIAN_BIG
    if (length < mBusByteWidth) {
        tmp_addr = (uint)tag ^ (mBusByteWidth - length);
    }
    #endif
    unsigned char* ptr = (unsigned char*)trans.get_data_ptr();
    memset(ptr,0,sizeof(REG_TYPE));
    reg_rd_dbg(tmp_addr, ptr, length);
    return sizeof(REG_TYPE);
}

uint Cadc_regif::cw_wr_cb(tlm::tlm_generic_payload& trans, int tag)
{
    int reg_index = get_reg_index((uint)tag);
    assert(reg_index != (1<<16));
    uint length = mRegArray[reg_index]->length;
    uint tmp_addr = (uint)tag;
    #ifdef IS_MODELED_ENDIAN_BIG
    if (length < mBusByteWidth) {
        tmp_addr = (uint)tag ^ (mBusByteWidth - length);
    }
    #endif
    unsigned char* ptr = (unsigned char*)trans.get_data_ptr();
    reg_wr_dbg(tmp_addr, ptr, length);
    return sizeof(REG_TYPE);
}

void Cadc_regif::cw_set_all_callback_reg(void)
{
    for(uint indx=0; indx<mTotalRegNum; indx++){
        cw_set_callback_reg( mRegArray[indx]->my_cw_p, (unsigned int)mRegArray[indx]->my_p->addr());
    }
}
#endif
