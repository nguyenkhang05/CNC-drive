// -----------------------------------------------------------------------------
// $Id: atu5010_timerb_regif.cpp,v 1.1 2017/07/04 03:21:49 binhnguyen Exp $
//
// Copyright(c) 2016-2017 Renesas Electronics Corporation
// Copyright(c) 2016-2017 Renesas Design Vietnam Co., Ltd.
// RENESAS ELECTRONICS CONFIDENTIAL AND PROPRIETARY.
// This program must be used solely for the purpose for which
// it was furnished by Renesas Electronics Corporation. No part of this
// program may be reproduced or disclosed to others, in any
// form, without the prior written permission of Renesas Electronics
// Corporation.
// -----------------------------------------------------------------------------
// This file is generated by Register I/F generator
//    gen_regif.py 1.9 2013/12/04 09:51:36 sontran
//    gen_regif_class.py 1.60 2014/10/24 09:42:15 ducduong
//    regif_cpp.skl 1.53 2014/10/13 03:19:16 sontran
//
// Input file : atu5010_timerb_regif.txt
////////////////////////////////////////////////////////////////////////////////
// %MODULE ATU5010_TIMERB
//     #                   name            offset_size
//     %%REG_INSTANCE      reg_def         9
// 
// %REG_CHANNEL reg_def
//     %%TITLE  group  name        reg_name    wsize       rsize       length  offset  factor_start    factor_end  factor_index    factor_step     access  init        support     callback
//     %%REG    -      TCRB        TCRB        8           8|16|32      8      0x000   -               -           -               -               W|R     0x0         TRUE        -
//     %%REG    -      TIORB       TIORB       8           8|16|32      8      0x002   -               -           -               -               W|R     0x0         TRUE        -
//     %%REG    -      TSRB        TSRB        -           8|16|32     16      0x004   -               -           -               -               R       0x0         TRUE        -
//     %%REG    -      TSCRB       TSCRB       8|16        8|16|32     16      0x006   -               -           -               -               W1|R    0x0         TRUE        -
//     %%REG    -      TICRB       TICRB       8           8|16|32      8      0x008   -               -           -               -               W|R     0x0         TRUE        -
//     %%REG    -      TIERB       TIERB       8|16        8|16|32     16      0x00A   -               -           -               -               W|R     0x0         TRUE        -
//     %%REG    -      CHSELBR     CHSELBR     8           8|16|32      8      0x00C   -               -           -               -               W|R     0x0         TRUE        -
//     %%REG    -      TCNT4CRB    TCNT4CRB    8           8|16|32      8      0x00E   -               -           -               -               W|R     0x0         TRUE        -
//     %%REG    -      TCRBS1      TCRBS1      8           8|16|32      8      0x010   -               -           -               -               W|R     0x0         TRUE        -
//     %%REG    -      TCRBS2      TCRBS2      8           8|16|32      8      0x014   -               -           -               -               W|R     0x0         TRUE        -
//     %%REG    -      TCNTB0S1    TCNTB0S1    32          8|16|32     32      0x040   -               -           -               -               W|R     0x1         TRUE        -
//     %%REG    -      ICRB0S1     ICRB0S1     -           8|16|32     32      0x044   -               -           -               -               R       0x0         TRUE        -
//     %%REG    -      OCRB0S1     OCRB0S1     32          8|16|32     32      0x048   -               -           -               -               W|R     0xFFFFFFFF  TRUE        -
//     %%REG    -      TCNTB1S1    TCNTB1S1    8           8|16|32      8      0x04C   -               -           -               -               W|R     0x0         TRUE        -
//     %%REG    -      OCRB1S1     OCRB1S1     8           8|16|32      8      0x04E   -               -           -               -               W|R     0xFF        TRUE        -
//     %%REG    -      OCRB10S1    OCRB10S1    8           8|16|32      8      0x050   -               -           -               -               W|R     0xFF        TRUE        -
//     %%REG    -      OCRB11S1    OCRB11S1    8           8|16|32      8      0x052   -               -           -               -               W|R     0xFF        TRUE        -
//     %%REG    -      OCRB12S1    OCRB12S1    8           8|16|32      8      0x054   -               -           -               -               W|R     0xFF        TRUE        -
//     %%REG    -      ICRB1S1     ICRB1S1     -           8|16|32     32      0x058   -               -           -               -               R       0x0         TRUE        -
//     %%REG    -      ICRB2S1     ICRB2S1     -           8|16|32     32      0x05C   -               -           -               -               R       0x0         TRUE        -
//     %%REG    -      TCNTB0S2    TCNTB0S2    32          8|16|32     32      0x060   -               -           -               -               W|R     0x1         TRUE        -
//     %%REG    -      ICRB0S2     ICRB0S2     -           8|16|32     32      0x064   -               -           -               -               R       0x0         TRUE        -
//     %%REG    -      OCRB0S2     OCRB0S2     32          8|16|32     32      0x068   -               -           -               -               W|R     0xFFFFFFFF  TRUE        -
//     %%REG    -      TCNTB1S2    TCNTB1S2    8           8|16|32      8      0x06C   -               -           -               -               W|R     0x0         TRUE        -
//     %%REG    -      OCRB1S2     OCRB1S2     8           8|16|32      8      0x06E   -               -           -               -               W|R     0xFF        TRUE        -
//     %%REG    -      OCRB10S2    OCRB10S2    8           8|16|32      8      0x070   -               -           -               -               W|R     0xFF        TRUE        -
//     %%REG    -      OCRB11S2    OCRB11S2    8           8|16|32      8      0x072   -               -           -               -               W|R     0xFF        TRUE        -
//     %%REG    -      OCRB12S2    OCRB12S2    8           8|16|32      8      0x074   -               -           -               -               W|R     0xFF        TRUE        -
//     %%REG    -      ICRB1S2     ICRB1S2     -           8|16|32     32      0x078   -               -           -               -               R       0x0         TRUE        -
//     %%REG    -      ICRB2S2     ICRB2S2     -           8|16|32     32      0x07C   -               -           -               -               R       0x0         TRUE        -
//     %%REG    -      TCNTB0      TCNTB0      32          8|16|32     32      0x080   -               -           -               -               W|R     0x1         TRUE        -
//     %%REG    -      ICRB0       ICRB0       -           8|16|32     32      0x084   -               -           -               -               R       0x0         TRUE        -
//     %%REG    -      RECRB       RECRB       32          8|16|32     32      0x088   1               6           -               0x4             W|R     0x0         TRUE        -
//     %%REG    -      RBURB       RBURB       32          8|16|32     32      0x0A0   0               6           -               0x4             W|R     0x0         TRUE        -
//     %%REG    -      OCRB0       OCRB0       32          8|16|32     32      0x0BC   -               -           -               -               W|R     0xFFFFFFFF  TRUE        -
//     %%REG    -      MIICRB0     MIICRB0     -           8|16|32     32      0x0C0   -               -           -               -               R       0x0         TRUE        -
//     %%REG    -      TCNTB1      TCNTB1      8           8|16|32      8      0x0C4   -               -           -               -               W|R     0x0         TRUE        -
//     %%REG    -      OCRB1       OCRB1       8           8|16|32      8      0x0C6   -               -           -               -               W|R     0xFF        TRUE        -
//     %%REG    -      OCRB10      OCRB10      8           8|16|32      8      0x0C8   -               -           -               -               W|R     0xFF        TRUE        -
//     %%REG    -      OCRB11      OCRB11      8           8|16|32      8      0x0CA   -               -           -               -               W|R     0xFF        TRUE        -
//     %%REG    -      OCRB12      OCRB12      8           8|16|32      8      0x0CC   -               -           -               -               W|R     0xFF        TRUE        -
//     %%REG    -      ICRB1       ICRB1       -           8|16|32     32      0x0D0   -               -           -               -               R       0x0         TRUE        -
//     %%REG    -      ICRB2       ICRB2       -           8|16|32     32      0x0D4   -               -           -               -               R       0x0         TRUE        -
//     %%REG    -      ICRB        ICRB        -           8|16|32      8      0x0D8   30              37          -               0x1             R       0x0         TRUE        -
//     %%REG    -      OCRB        OCRB        8           8|16|32      8      0x0E0   20              43          -               0x1             W|R     0xFF        TRUE        -
//     %%REG    -      LDB         LDB         32          8|16|32     32      0x100   -               -           -               -               W|R     0x0         TRUE        -
//     %%REG    -      RLDB        RLDB        32          8|16|32     32      0x104   -               -           -               -               W|R     0x0         TRUE        -
//     %%REG    -      TCNTB2      TCNTB2      32          8|16|32     32      0x108   -               -           -               -               W|R     0x0         TRUE        -
//     %%REG    -      PIMR1       PIMR1       16          8|16|32     16      0x10C   -               -           -               -               W|R     0x1         TRUE        -
//     %%REG    -      PIMR2       PIMR2       16          8|16|32     16      0x10E   -               -           -               -               W|R     0x1         TRUE        -
//     %%REG    -      TCNTB6      TCNTB6      32          8|16|32     32      0x110   -               -           -               -               W|R     0x0         TRUE        -
//     %%REG    -      ICRB6       ICRB6       -           8|16|32     32      0x114   -               -           -               -               R       0x0         TRUE        -
//     %%REG    -      RARB6       RARB6       8           8|16|32      8      0x118   -               -           -               -               W|R     0x40        TRUE        -
//     %%REG    -      TCNTB6M     TCNTB6M     32          8|16|32     32      0x11C   -               -           -               -               W|R     0x0         TRUE        -
//     %%REG    -      OCRB6       OCRB6       32          8|16|32     32      0x120   -               -           -               -               W|R     0xFFFFF000  TRUE        -
//     %%REG    -      OCRB7       OCRB7       32          8|16|32     32      0x124   -               -           -               -               W|R     0xFFFFF000  TRUE        -
//     %%REG    -      TSEQCRB     TSEQCRB     8           8|16|32      8      0x140   -               -           -               -               W|R     0x0         TRUE        -
//     %%REG    -      TSEQRB      TSEQRB      -           8|16|32      8      0x142   -               -           -               -               R       0x0         TRUE        -
//     %%REG    -      TSEQENB     TSEQENB     8           8|16|32      8      0x144   0               2           -               0x1             W|R     0x0         TRUE        -
//     %%REG    -      TEPCFB      TEPCFB      16          8|16|32     16      0x148   0               23          -               0x2             W|R     0x300       TRUE        -
//     %%REG    -      TEPCFENB    TEPCFENB    8           8|16|32      8      0x178   0               2           -               0x1             W|R     0x0         TRUE        -
//     %%REG    -      TCNTB3      TCNTB3      32          8|16|32     32      0x180   -               -           -               -               W|R     0x0         TRUE        -
//     %%REG    -      TCNTB4      TCNTB4      32          8|16|32     32      0x184   -               -           -               -               W|R     0x0         TRUE        -
//     %%REG    -      TCNTB5      TCNTB5      32          8|16|32     32      0x188   -               -           -               -               W|R     0x1000      TRUE        -
//     %%REG    -      TCCLFRB     TCCLFRB     -           8|16|32      8      0x18C   -               -           -               -               R       0x0         TRUE        -
//     %%REG    -      TCCLFSRB    TCCLFSRB    8           8|16|32      8      0x18D   -               -           -               -               R|W1:0  0x0         TRUE        -
//     %%REG    -      TCCLFCRB    TCCLFCRB    8           8|16|32      8      0x18E   -               -           -               -               R|W1:0  0x0         TRUE        -
//     %%REG    -      TCCLRB      TCCLRB      32          8|16|32     32      0x190   -               -           -               -               W|R     0x0         TRUE        -
//     %%REG    -      OCRB8       OCRB8       32          8|16|32     32      0x194   -               -           -               -               W|R     0xFFFFF000  TRUE        -
//     %%REG    -      DICRB0      DICRB0      -           8|16|32     32      0x1C0   -               -           -               -               R       0x0         TRUE        -
//     %%REG    -      DRECRB1     DRECRB1     32          8|16|32     32      0x1C4   -               -           -               -               W|R     0x0         TRUE        -
//     %%REG    -      TEPCRECRB1  TEPCRECRB1  -           8|16|32     32      0x1C8   -               -           -               -               R       0x0         TRUE        -
//     %%REG    -      TEPCVALRB0  TEPCVALRB0  -           8|16|32     32      0x1CC   -               -           -               -               R       0x0         TRUE        -
// 
// 
// %REG_NAME TCRB
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    CKSELB            1      0     0x0             W|R     TRUE        W
//     %%BIT    CLRB1SEL          2      2     0x0             W|R     TRUE        -
//     %%BIT    CLRB3SEL          4      3     0x0             W|R     TRUE        -
//     %%BIT    CLRB1             5      5     0x0             W|R     TRUE        -
//     %%BIT    CLRB3             6      6     0x0             W|R     TRUE        -
//     %%BIT    PIMRSEL           7      7     0x0             W|R     TRUE        -
// 
// %REG_NAME TIORB
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    IOB6              0      0     0x0             W|R     TRUE        -
//     %%BIT    CCS               3      3     0x0             W|R     TRUE        -
//     %%BIT    LDEN              4      4     0x0             W|R     TRUE        -
//     %%BIT    EVCNTB            5      5     0x0             W|R     TRUE        -
//     %%BIT    CTCNTB5           6      6     0x0             W|R     TRUE        -
//     %%BIT    LDSEL             7      7     0x0             W|R     TRUE        W
// 
// %REG_NAME TSRB
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    CMFB0             0      0     0x0             R       TRUE        -
//     %%BIT    ICFB0             1      1     0x0             R       TRUE        -
//     %%BIT    CMFB1             2      2     0x0             R       TRUE        -
//     %%BIT    CMFB6             3      3     0x0             R       TRUE        -
//     %%BIT    CMFB10            4      4     0x0             R       TRUE        -
//     %%BIT    CMFB11            5      5     0x0             R       TRUE        -
//     %%BIT    CMFB12            6      6     0x0             R       TRUE        -
//     %%BIT    CMFB6M            8      8     0x0             R       TRUE        -
//     %%BIT    CMFB6E            9      9     0x0             R       TRUE        -
// 
// %REG_NAME TSCRB
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    CMFCB0            0      0     0x0             W1|R    TRUE        W
//     %%BIT    ICFCB0            1      1     0x0             W1|R    TRUE        -
//     %%BIT    CMFCB1            2      2     0x0             W1|R    TRUE        -
//     %%BIT    CMFCB6            3      3     0x0             W1|R    TRUE        -
//     %%BIT    CMFCB10           4      4     0x0             W1|R    TRUE        -
//     %%BIT    CMFCB11           5      5     0x0             W1|R    TRUE        -
//     %%BIT    CMFCB12           6      6     0x0             W1|R    TRUE        -
//     %%BIT    CMFCB6M           8      8     0x0             W1|R    TRUE        -
//     %%BIT    CMFCB6E           9      9     0x0             W1|R    TRUE        -
// 
// %REG_NAME TICRB
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    IREGB6            1      0     0x0             W|R     TRUE        W
//     %%BIT    IREGB6E           3      2     0x0             W|R     TRUE        -
// 
// %REG_NAME TIERB
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    CMFB0IE           0      0     0x0             W|R     TRUE        -
//     %%BIT    ICFB0IE           1      1     0x0             W|R     TRUE        -
//     %%BIT    CMFB1IE           2      2     0x0             W|R     TRUE        -
//     %%BIT    CMFB6IE           3      3     0x0             W|R     TRUE        -
//     %%BIT    CMFB10IE          4      4     0x0             W|R     TRUE        -
//     %%BIT    CMFB11IE          5      5     0x0             W|R     TRUE        -
//     %%BIT    CMFB12IE          6      6     0x0             W|R     TRUE        -
//     %%BIT    CMFB6MIE          8      8     0x0             W|R     TRUE        -
//     %%BIT    CMFB6EIE          9      9     0x0             W|R     TRUE        -
// 
// %REG_NAME CHSELBR
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    CHSELB            1      0     0x0             W|R     TRUE        -
//     
// %REG_NAME TCNT4CRB    
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    CU4SEL            0      0     0x0             W|R     TRUE        -
// 
// %REG_NAME TCRBS1
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    CLRB1SELS1        2      2     0x0             W|R     TRUE        -
//     %%BIT    CLRB1S1           5      5     0x0             W|R     TRUE        -
// 
// %REG_NAME TCRBS2
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    CLRB1SELS2        2      2     0x0             W|R     TRUE        -
//     %%BIT    CLRB1S2           5      5     0x0             W|R     TRUE        -
// 
// %REG_NAME TCNTB0S1
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    CNTB0S1          31      0     0x1             W|R     TRUE        W
// 
// %REG_NAME ICRB0S1
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    ICB0S1           31      0     0x0             R       TRUE        -
// 
// %REG_NAME OCRB0S1
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    OCB0S1           31      0     0xFFFFFFFF      W|R     TRUE        W
// 
// %REG_NAME TCNTB1S1
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    CNTB1S1           7      0     0x0             W|R     TRUE        -
// 
// %REG_NAME OCRB1S1
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    OCB1S1            7      0     0xFF            W|R     TRUE        -
// 
// %REG_NAME OCRB10S1
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    OCB10S1           7      0     0xFF            W|R     TRUE        -
// 
// %REG_NAME OCRB11S1
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    OCB11S1           7      0     0xFF            W|R     TRUE        -
// 
// %REG_NAME OCRB12S1
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    OCB12S1           7      0     0xFF            W|R     TRUE        -
// 
// %REG_NAME ICRB1S1
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    ICB1S1           31      0     0x0             R       TRUE        -
// 
// %REG_NAME ICRB2S1
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    ICB2S1           31      0     0x0             R       TRUE        -
// 
// %REG_NAME TCNTB0S2
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    CNTB0S2          31      0     0x1             W|R     TRUE        W
// 
// %REG_NAME ICRB0S2
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    ICB0S2           31      0     0x0             R       TRUE        -
// 
// %REG_NAME OCRB0S2
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    OCB0S2           31      0     0xFFFFFFFF      W|R     TRUE        W
// 
// %REG_NAME TCNTB1S2
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    CNTB1S2           7      0     0x0             W|R     TRUE        -
// 
// %REG_NAME OCRB1S2
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    OCB1S2            7      0     0xFF            W|R     TRUE        -
// 
// %REG_NAME OCRB10S2
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    OCB10S2           7      0     0xFF            W|R     TRUE        -
// 
// %REG_NAME OCRB11S2
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    OCB11S2           7      0     0xFF            W|R     TRUE        -
// 
// %REG_NAME OCRB12S2
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    OCB12S2           7      0     0xFF            W|R     TRUE        -
// 
// %REG_NAME ICRB1S1
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    ICB1S2           31      0     0x0             R       TRUE        -
// 
// %REG_NAME ICRB2S1
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    ICB2S2           31      0     0x0             R       TRUE        -
// 
// %REG_NAME TCNTB0
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    CNTB0            31      0     0x1             W|R     TRUE        W
// 
// %REG_NAME ICRB0
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    ICB0             31      0     0x0             R       TRUE        -
// 
// %REG_NAME RECRB
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    RECRB            31      0     0x0             W|R     TRUE        -
// 
// %REG_NAME RBURB
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    RBURB            31      0     0x0             W|R     TRUE        -
// 
// %REG_NAME OCRB0
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    OCB0             31      0     0xFFFFFFFF      W|R     TRUE        W
// 
// %REG_NAME MIICRB0
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    ICB0             31      0     0x0             R       TRUE        -
// 
// %REG_NAME TCNTB1
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    CNTB1             7      0     0x0             W|R     TRUE        -
// 
// %REG_NAME OCRB1
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    OCB1              7      0     0xFF            W|R     TRUE        -
// 
// %REG_NAME OCRB10
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    OCB10             7      0     0xFF            W|R     TRUE        -
// 
// %REG_NAME OCRB11
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    OCB11             7      0     0xFF            W|R     TRUE        -
// 
// %REG_NAME OCRB12
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    OCB12             7      0     0xFF            W|R     TRUE        -
// 
// %REG_NAME ICRB1
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    ICB1             31      0     0x0             R       TRUE        -
// 
// %REG_NAME ICRB2
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    ICB2             31      0     0x0             R       TRUE        -
// 
// %REG_NAME ICRB
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    ICB               7      0     0x0             R       TRUE        -
// 
// %REG_NAME OCRB
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    OCB               7      0     0xFF            W|R     TRUE        W
// 
// %REG_NAME LDB
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    LDVAL            23      0     0x0             W|R     TRUE        -
// 
// %REG_NAME RLDB
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    RLDVAL           31      8     0x0             W|R     TRUE        -
// 
// %REG_NAME TCNTB2
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    CNTB2            31      8     0x0             W|R     TRUE        W
// 
// %REG_NAME PIMR1
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    PIM1             11      0     0x1             W|R     TRUE        W
// 
// %REG_NAME PIMR2
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    PIM2             11      0     0x1             W|R     TRUE        -
// 
// %REG_NAME TCNTB6
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    CNTB6            31     12     0x0             W|R     TRUE        -
// 
// %REG_NAME ICRB6
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    ICB6             31     12     0x0             R       TRUE        -
// 
// %REG_NAME RARB6
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    RARB6             7      0     0x40            W|R     TRUE        -
// 
// %REG_NAME TCNTB6M
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    CNTB6M           31      6     0x0             W|R     TRUE        -
// 
// %REG_NAME OCRB6
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    OCB6             31     12     0xFFFFF         W|R     TRUE        -
// 
// %REG_NAME OCRB7
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    OCB7             31     12     0xFFFFF         W|R     TRUE        -
// 
// %REG_NAME TSEQCRB
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    EVSEQENB          0      0     0x0             W|R     TRUE        W
// 
// %REG_NAME TSEQRB
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    SEQB              4      0     0x0             R       TRUE        -
//     %%BIT    FONS              7      7     0x0             R       TRUE        -
// 
// %REG_NAME TSEQENB
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    TSEQNENB          7      0     0x0             W|R     TRUE        -
// 
// %REG_NAME TEPCFB
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    CRFIT2            2      0     0x0             W|R     TRUE        W
//     %%BIT    CRFIT1            6      4     0x0             W|R     TRUE        -
//     %%BIT    COEFF            10      8     0x3             W|R     TRUE        -
//     %%BIT    HALFEN           12     12     0x0             W|R     TRUE        -
// 
// %REG_NAME TEPCFENB
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    FON               7      0     0x0             W|R     TRUE        -
// 
// %REG_NAME TCNTB3
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    CNTB3            31     12     0x0             W|R     TRUE        -
// 
// %REG_NAME TCNTB4
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    CNTB4            31     12     0x0             W|R     TRUE        W
// 
// %REG_NAME TCNTB5
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    CNTB5            31     12     0x1             W|R     TRUE        W
// 
// %REG_NAME TCCLFRB
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    TCCLFB            0      0     0x0             R       TRUE        -
// 
// %REG_NAME TCCLFSRB
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    TCCLFSB           0      0     0x0             W|R     TRUE        W
// 
// %REG_NAME TCCLFCRB
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    TCCLFCB           0      0     0x0             W|R     TRUE        W
// 
// %REG_NAME TCCLRB
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    CCLRB            31     12     0x0             W|R     TRUE        W
// 
// %REG_NAME OCRB8
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    OCB8             31     12     0xFFFFF         W|R     TRUE        -
// 
// %REG_NAME DICRB0
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    ICB0             31      0     0x0             R       TRUE        -
// 
// %REG_NAME DRECRB1
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    RECRB1           31      0     0x0             W|R     TRUE        -
// 
// %REG_NAME TEPCRECRB1
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    TEPCRECRB1       31      0     0x0             R       TRUE        -
// 
// %REG_NAME TEPCVALRB0
//     %%TITLE  name             upper  lower  init            access  support     callback
//     %%BIT    TEPCVALRB0       31      0     0x0             R       TRUE        -
// 
// 
////////////////////////////////////////////////////////////////////////////////
/// @file atu5010_timerb_regif.cpp
/// @brief Register IF class of model ATU5010_TIMERB
/// $Id$
/// $Date$
/// $Revison$
/// $Author$
////////////////////////////////////////////////////////////////////////////////
#include "atu5010_timerb_regif.h"
#ifndef re_printf
#define re_printf get_fileline(__FILE__, __LINE__); _re_printf
#endif//re_printf

/// Constructor of Register IF class: define registers and bits
/// @return none
Catu5010_timerb_regif::Catu5010_timerb_regif(std::string name, uint buswidth)
    :vpcl::reg_super()
    #ifdef CWR_SYSTEMC
    , cwmem("register", scml_memsize(0x1D0/4))
    #endif
{
    uint FactorIndex_RECRB_tmp[emNUM_RECRB] = {   1,   2,   3,   4,   5,   6};
    uint FactorIndex_ICRB_tmp[emNUM_ICRB] = {  30,  31,  32,  33,  34,  35,  36,  37};
    uint FactorIndex_OCRB_tmp[emNUM_OCRB] = {  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,  32,  33,  34, 
                                                     35,  36,  37,  38,  39,  40,  41,  42,  43};
    for(uint i = 0; i < emNUM_RECRB; i++) {
        mFactorIndexRECRB[i] = FactorIndex_RECRB_tmp[i];
    }
    for(uint i = 0; i < emNUM_ICRB; i++) {
        mFactorIndexICRB[i] = FactorIndex_ICRB_tmp[i];
    }
    for(uint i = 0; i < emNUM_OCRB; i++) {
        mFactorIndexOCRB[i] = FactorIndex_OCRB_tmp[i];
    }

    CommandInit();
    TCRB       = new vpcl::re_register(0x0000, this, "TCRB"      , name.c_str());
    TIORB      = new vpcl::re_register(0x0002, this, "TIORB"     , name.c_str());
    TSRB       = new vpcl::re_register(0x0004, this, "TSRB"      , name.c_str());
    TSCRB      = new vpcl::re_register(0x0006, this, "TSCRB"     , name.c_str());
    TICRB      = new vpcl::re_register(0x0008, this, "TICRB"     , name.c_str());
    TIERB      = new vpcl::re_register(0x000A, this, "TIERB"     , name.c_str());
    CHSELBR    = new vpcl::re_register(0x000C, this, "CHSELBR"   , name.c_str());
    TCNT4CRB   = new vpcl::re_register(0x000E, this, "TCNT4CRB"  , name.c_str());
    TCRBS1     = new vpcl::re_register(0x0010, this, "TCRBS1"    , name.c_str());
    TCRBS2     = new vpcl::re_register(0x0014, this, "TCRBS2"    , name.c_str());
    TCNTB0S1   = new vpcl::re_register(0x0040, this, "TCNTB0S1"  , name.c_str());
    ICRB0S1    = new vpcl::re_register(0x0044, this, "ICRB0S1"   , name.c_str());
    OCRB0S1    = new vpcl::re_register(0x0048, this, "OCRB0S1"   , name.c_str());
    TCNTB1S1   = new vpcl::re_register(0x004C, this, "TCNTB1S1"  , name.c_str());
    OCRB1S1    = new vpcl::re_register(0x004E, this, "OCRB1S1"   , name.c_str());
    OCRB10S1   = new vpcl::re_register(0x0050, this, "OCRB10S1"  , name.c_str());
    OCRB11S1   = new vpcl::re_register(0x0052, this, "OCRB11S1"  , name.c_str());
    OCRB12S1   = new vpcl::re_register(0x0054, this, "OCRB12S1"  , name.c_str());
    ICRB1S1    = new vpcl::re_register(0x0058, this, "ICRB1S1"   , name.c_str());
    ICRB2S1    = new vpcl::re_register(0x005C, this, "ICRB2S1"   , name.c_str());
    TCNTB0S2   = new vpcl::re_register(0x0060, this, "TCNTB0S2"  , name.c_str());
    ICRB0S2    = new vpcl::re_register(0x0064, this, "ICRB0S2"   , name.c_str());
    OCRB0S2    = new vpcl::re_register(0x0068, this, "OCRB0S2"   , name.c_str());
    TCNTB1S2   = new vpcl::re_register(0x006C, this, "TCNTB1S2"  , name.c_str());
    OCRB1S2    = new vpcl::re_register(0x006E, this, "OCRB1S2"   , name.c_str());
    OCRB10S2   = new vpcl::re_register(0x0070, this, "OCRB10S2"  , name.c_str());
    OCRB11S2   = new vpcl::re_register(0x0072, this, "OCRB11S2"  , name.c_str());
    OCRB12S2   = new vpcl::re_register(0x0074, this, "OCRB12S2"  , name.c_str());
    ICRB1S2    = new vpcl::re_register(0x0078, this, "ICRB1S2"   , name.c_str());
    ICRB2S2    = new vpcl::re_register(0x007C, this, "ICRB2S2"   , name.c_str());
    TCNTB0     = new vpcl::re_register(0x0080, this, "TCNTB0"    , name.c_str());
    ICRB0      = new vpcl::re_register(0x0084, this, "ICRB0"     , name.c_str());
    OCRB0      = new vpcl::re_register(0x00BC, this, "OCRB0"     , name.c_str());
    MIICRB0    = new vpcl::re_register(0x00C0, this, "MIICRB0"   , name.c_str());
    TCNTB1     = new vpcl::re_register(0x00C4, this, "TCNTB1"    , name.c_str());
    OCRB1      = new vpcl::re_register(0x00C6, this, "OCRB1"     , name.c_str());
    OCRB10     = new vpcl::re_register(0x00C8, this, "OCRB10"    , name.c_str());
    OCRB11     = new vpcl::re_register(0x00CA, this, "OCRB11"    , name.c_str());
    OCRB12     = new vpcl::re_register(0x00CC, this, "OCRB12"    , name.c_str());
    ICRB1      = new vpcl::re_register(0x00D0, this, "ICRB1"     , name.c_str());
    ICRB2      = new vpcl::re_register(0x00D4, this, "ICRB2"     , name.c_str());
    LDB        = new vpcl::re_register(0x0100, this, "LDB"       , name.c_str());
    RLDB       = new vpcl::re_register(0x0104, this, "RLDB"      , name.c_str());
    TCNTB2     = new vpcl::re_register(0x0108, this, "TCNTB2"    , name.c_str());
    PIMR1      = new vpcl::re_register(0x010C, this, "PIMR1"     , name.c_str());
    PIMR2      = new vpcl::re_register(0x010E, this, "PIMR2"     , name.c_str());
    TCNTB6     = new vpcl::re_register(0x0110, this, "TCNTB6"    , name.c_str());
    ICRB6      = new vpcl::re_register(0x0114, this, "ICRB6"     , name.c_str());
    RARB6      = new vpcl::re_register(0x0118, this, "RARB6"     , name.c_str());
    TCNTB6M    = new vpcl::re_register(0x011C, this, "TCNTB6M"   , name.c_str());
    OCRB6      = new vpcl::re_register(0x0120, this, "OCRB6"     , name.c_str());
    OCRB7      = new vpcl::re_register(0x0124, this, "OCRB7"     , name.c_str());
    TSEQCRB    = new vpcl::re_register(0x0140, this, "TSEQCRB"   , name.c_str());
    TSEQRB     = new vpcl::re_register(0x0142, this, "TSEQRB"    , name.c_str());
    TCNTB3     = new vpcl::re_register(0x0180, this, "TCNTB3"    , name.c_str());
    TCNTB4     = new vpcl::re_register(0x0184, this, "TCNTB4"    , name.c_str());
    TCNTB5     = new vpcl::re_register(0x0188, this, "TCNTB5"    , name.c_str());
    TCCLFRB    = new vpcl::re_register(0x018C, this, "TCCLFRB"   , name.c_str());
    TCCLFSRB   = new vpcl::re_register(0x018D, this, "TCCLFSRB"  , name.c_str());
    TCCLFCRB   = new vpcl::re_register(0x018E, this, "TCCLFCRB"  , name.c_str());
    TCCLRB     = new vpcl::re_register(0x0190, this, "TCCLRB"    , name.c_str());
    OCRB8      = new vpcl::re_register(0x0194, this, "OCRB8"     , name.c_str());
    DICRB0     = new vpcl::re_register(0x01C0, this, "DICRB0"    , name.c_str());
    DRECRB1    = new vpcl::re_register(0x01C4, this, "DRECRB1"   , name.c_str());
    TEPCRECRB1 = new vpcl::re_register(0x01C8, this, "TEPCRECRB1", name.c_str());
    TEPCVALRB0 = new vpcl::re_register(0x01CC, this, "TEPCVALRB0", name.c_str());
    std::ostringstream str_tmp;
    for(uint i = 0; i < emNUM_RECRB; i++) {
        str_tmp.str("");
        str_tmp<<"RECRB"<< mFactorIndexRECRB[i];
        RECRB     [mFactorIndexRECRB[i]] = new vpcl::re_register((0x0088) + 4*(mFactorIndexRECRB[i]-1), this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_RBURB; i++) {
        str_tmp.str("");
        str_tmp<<"RBURB"<< i;
        RBURB     [i] = new vpcl::re_register((0x00A0) + 4*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_ICRB; i++) {
        str_tmp.str("");
        str_tmp<<"ICRB"<< mFactorIndexICRB[i];
        ICRB      [mFactorIndexICRB[i]] = new vpcl::re_register((0x00D8) + (mFactorIndexICRB[i]-30), this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_OCRB; i++) {
        str_tmp.str("");
        str_tmp<<"OCRB"<< mFactorIndexOCRB[i];
        OCRB      [mFactorIndexOCRB[i]] = new vpcl::re_register((0x00E0) + (mFactorIndexOCRB[i]-20), this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_TSEQENB; i++) {
        str_tmp.str("");
        str_tmp<<"TSEQENB"<< i;
        TSEQENB   [i] = new vpcl::re_register((0x0144) + i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_TEPCFB; i++) {
        str_tmp.str("");
        str_tmp<<"TEPCFB"<< i;
        TEPCFB    [i] = new vpcl::re_register((0x0148) + 2*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_TEPCFENB; i++) {
        str_tmp.str("");
        str_tmp<<"TEPCFENB"<< i;
        TEPCFENB  [i] = new vpcl::re_register((0x0178) + i, this, str_tmp.str(), name.c_str());
    }

    // Construct the register pointer list
    mCurReg = NULL;

    uint index = 0;
    mRegMap = new uint [1<<9];
    for (uint i = 0; i < (1<<9); i++) {
        mRegMap[i] = (1<<9);
    }

    mRegMap[0x0000]     = index++;
    mRegMap[0x0002]     = index++;
    mRegMap[0x0004]     = index;
    mRegMap[0x0004 + 1] = index++;
    mRegMap[0x0006]     = index;
    mRegMap[0x0006 + 1] = index++;
    mRegMap[0x0008]     = index++;
    mRegMap[0x000A]     = index;
    mRegMap[0x000A + 1] = index++;
    mRegMap[0x000C]     = index++;
    mRegMap[0x000E]     = index++;
    mRegMap[0x0010]     = index++;
    mRegMap[0x0014]     = index++;
    mRegMap[0x0040]     = index;
    mRegMap[0x0040 + 1] = index;
    mRegMap[0x0040 + 2] = index;
    mRegMap[0x0040 + 3] = index++;
    mRegMap[0x0044]     = index;
    mRegMap[0x0044 + 1] = index;
    mRegMap[0x0044 + 2] = index;
    mRegMap[0x0044 + 3] = index++;
    mRegMap[0x0048]     = index;
    mRegMap[0x0048 + 1] = index;
    mRegMap[0x0048 + 2] = index;
    mRegMap[0x0048 + 3] = index++;
    mRegMap[0x004C]     = index++;
    mRegMap[0x004E]     = index++;
    mRegMap[0x0050]     = index++;
    mRegMap[0x0052]     = index++;
    mRegMap[0x0054]     = index++;
    mRegMap[0x0058]     = index;
    mRegMap[0x0058 + 1] = index;
    mRegMap[0x0058 + 2] = index;
    mRegMap[0x0058 + 3] = index++;
    mRegMap[0x005C]     = index;
    mRegMap[0x005C + 1] = index;
    mRegMap[0x005C + 2] = index;
    mRegMap[0x005C + 3] = index++;
    mRegMap[0x0060]     = index;
    mRegMap[0x0060 + 1] = index;
    mRegMap[0x0060 + 2] = index;
    mRegMap[0x0060 + 3] = index++;
    mRegMap[0x0064]     = index;
    mRegMap[0x0064 + 1] = index;
    mRegMap[0x0064 + 2] = index;
    mRegMap[0x0064 + 3] = index++;
    mRegMap[0x0068]     = index;
    mRegMap[0x0068 + 1] = index;
    mRegMap[0x0068 + 2] = index;
    mRegMap[0x0068 + 3] = index++;
    mRegMap[0x006C]     = index++;
    mRegMap[0x006E]     = index++;
    mRegMap[0x0070]     = index++;
    mRegMap[0x0072]     = index++;
    mRegMap[0x0074]     = index++;
    mRegMap[0x0078]     = index;
    mRegMap[0x0078 + 1] = index;
    mRegMap[0x0078 + 2] = index;
    mRegMap[0x0078 + 3] = index++;
    mRegMap[0x007C]     = index;
    mRegMap[0x007C + 1] = index;
    mRegMap[0x007C + 2] = index;
    mRegMap[0x007C + 3] = index++;
    mRegMap[0x0080]     = index;
    mRegMap[0x0080 + 1] = index;
    mRegMap[0x0080 + 2] = index;
    mRegMap[0x0080 + 3] = index++;
    mRegMap[0x0084]     = index;
    mRegMap[0x0084 + 1] = index;
    mRegMap[0x0084 + 2] = index;
    mRegMap[0x0084 + 3] = index++;
    for(uint i = 0; i < emNUM_RECRB;     i++) {
        mRegMap[(0x0088)     + (mFactorIndexRECRB[i]-1)*4] = index;
        mRegMap[(0x0088 + 1) + (mFactorIndexRECRB[i]-1)*4] = index;
        mRegMap[(0x0088 + 2) + (mFactorIndexRECRB[i]-1)*4] = index;
        mRegMap[(0x0088 + 3) + (mFactorIndexRECRB[i]-1)*4] = index++;
    }
    for(uint i = 0; i < emNUM_RBURB;     i++) {
        mRegMap[(0x00A0)     + i*4 ] = index;
        mRegMap[(0x00A0 + 1) + i*4 ] = index;
        mRegMap[(0x00A0 + 2) + i*4 ] = index;
        mRegMap[(0x00A0 + 3) + i*4 ] = index++;
    }
    mRegMap[0x00BC]     = index;
    mRegMap[0x00BC + 1] = index;
    mRegMap[0x00BC + 2] = index;
    mRegMap[0x00BC + 3] = index++;
    mRegMap[0x00C0]     = index;
    mRegMap[0x00C0 + 1] = index;
    mRegMap[0x00C0 + 2] = index;
    mRegMap[0x00C0 + 3] = index++;
    mRegMap[0x00C4]     = index++;
    mRegMap[0x00C6]     = index++;
    mRegMap[0x00C8]     = index++;
    mRegMap[0x00CA]     = index++;
    mRegMap[0x00CC]     = index++;
    mRegMap[0x00D0]     = index;
    mRegMap[0x00D0 + 1] = index;
    mRegMap[0x00D0 + 2] = index;
    mRegMap[0x00D0 + 3] = index++;
    mRegMap[0x00D4]     = index;
    mRegMap[0x00D4 + 1] = index;
    mRegMap[0x00D4 + 2] = index;
    mRegMap[0x00D4 + 3] = index++;
    for(uint i = 0; i < emNUM_ICRB;      i++) {
        mRegMap[(0x00D8)     + (mFactorIndexICRB[i]-30)] = index++;
    }
    for(uint i = 0; i < emNUM_OCRB;      i++) {
        mRegMap[(0x00E0)     + (mFactorIndexOCRB[i]-20)] = index++;
    }
    mRegMap[0x0100]     = index;
    mRegMap[0x0100 + 1] = index;
    mRegMap[0x0100 + 2] = index;
    mRegMap[0x0100 + 3] = index++;
    mRegMap[0x0104]     = index;
    mRegMap[0x0104 + 1] = index;
    mRegMap[0x0104 + 2] = index;
    mRegMap[0x0104 + 3] = index++;
    mRegMap[0x0108]     = index;
    mRegMap[0x0108 + 1] = index;
    mRegMap[0x0108 + 2] = index;
    mRegMap[0x0108 + 3] = index++;
    mRegMap[0x010C]     = index;
    mRegMap[0x010C + 1] = index++;
    mRegMap[0x010E]     = index;
    mRegMap[0x010E + 1] = index++;
    mRegMap[0x0110]     = index;
    mRegMap[0x0110 + 1] = index;
    mRegMap[0x0110 + 2] = index;
    mRegMap[0x0110 + 3] = index++;
    mRegMap[0x0114]     = index;
    mRegMap[0x0114 + 1] = index;
    mRegMap[0x0114 + 2] = index;
    mRegMap[0x0114 + 3] = index++;
    mRegMap[0x0118]     = index++;
    mRegMap[0x011C]     = index;
    mRegMap[0x011C + 1] = index;
    mRegMap[0x011C + 2] = index;
    mRegMap[0x011C + 3] = index++;
    mRegMap[0x0120]     = index;
    mRegMap[0x0120 + 1] = index;
    mRegMap[0x0120 + 2] = index;
    mRegMap[0x0120 + 3] = index++;
    mRegMap[0x0124]     = index;
    mRegMap[0x0124 + 1] = index;
    mRegMap[0x0124 + 2] = index;
    mRegMap[0x0124 + 3] = index++;
    mRegMap[0x0140]     = index++;
    mRegMap[0x0142]     = index++;
    for(uint i = 0; i < emNUM_TSEQENB;   i++) {
        mRegMap[(0x0144)     + i*1 ] = index++;
    }
    for(uint i = 0; i < emNUM_TEPCFB;    i++) {
        mRegMap[(0x0148)     + i*2 ] = index;
        mRegMap[(0x0148 + 1) + i*2 ] = index++;
    }
    for(uint i = 0; i < emNUM_TEPCFENB;  i++) {
        mRegMap[(0x0178)     + i*1 ] = index++;
    }
    mRegMap[0x0180]     = index;
    mRegMap[0x0180 + 1] = index;
    mRegMap[0x0180 + 2] = index;
    mRegMap[0x0180 + 3] = index++;
    mRegMap[0x0184]     = index;
    mRegMap[0x0184 + 1] = index;
    mRegMap[0x0184 + 2] = index;
    mRegMap[0x0184 + 3] = index++;
    mRegMap[0x0188]     = index;
    mRegMap[0x0188 + 1] = index;
    mRegMap[0x0188 + 2] = index;
    mRegMap[0x0188 + 3] = index++;
    mRegMap[0x018C]     = index++;
    mRegMap[0x018D]     = index++;
    mRegMap[0x018E]     = index++;
    mRegMap[0x0190]     = index;
    mRegMap[0x0190 + 1] = index;
    mRegMap[0x0190 + 2] = index;
    mRegMap[0x0190 + 3] = index++;
    mRegMap[0x0194]     = index;
    mRegMap[0x0194 + 1] = index;
    mRegMap[0x0194 + 2] = index;
    mRegMap[0x0194 + 3] = index++;
    mRegMap[0x01C0]     = index;
    mRegMap[0x01C0 + 1] = index;
    mRegMap[0x01C0 + 2] = index;
    mRegMap[0x01C0 + 3] = index++;
    mRegMap[0x01C4]     = index;
    mRegMap[0x01C4 + 1] = index;
    mRegMap[0x01C4 + 2] = index;
    mRegMap[0x01C4 + 3] = index++;
    mRegMap[0x01C8]     = index;
    mRegMap[0x01C8 + 1] = index;
    mRegMap[0x01C8 + 2] = index;
    mRegMap[0x01C8 + 3] = index++;
    mRegMap[0x01CC]     = index;
    mRegMap[0x01CC + 1] = index;
    mRegMap[0x01CC + 2] = index;
    mRegMap[0x01CC + 3] = index++;
    mTotalRegNum = index;
    mRegArray = new SRegList* [mTotalRegNum];
    index = 0;
    #ifdef CWR_SYSTEMC
    cw_instantiate_reg(CW_TCRB_TIORB, "TCRB_TIORB", 0x0000);
    CW_TCRB       = new scml2::bitfield<uint>(TCRB->name()      , CW_TCRB_TIORB          ,  0,  8);
    CW_TIORB      = new scml2::bitfield<uint>(TIORB->name()     , CW_TCRB_TIORB          , 16,  8);
    cw_instantiate_reg(CW_TSRB_TSCRB, "TSRB_TSCRB", 0x0004);
    CW_TSRB       = new scml2::bitfield<uint>(TSRB->name()      , CW_TSRB_TSCRB          ,  0, 16);
    CW_TSCRB      = new scml2::bitfield<uint>(TSCRB->name()     , CW_TSRB_TSCRB          , 16, 16);
    cw_instantiate_reg(CW_TICRB_TIERB, "TICRB_TIERB", 0x0008);
    CW_TICRB      = new scml2::bitfield<uint>(TICRB->name()     , CW_TICRB_TIERB         ,  0,  8);
    CW_TIERB      = new scml2::bitfield<uint>(TIERB->name()     , CW_TICRB_TIERB         , 16, 16);
    cw_instantiate_reg(CW_CHSELBR_TCNT4CRB, "CHSELBR_TCNT4CRB", 0x000C);
    CW_CHSELBR    = new scml2::bitfield<uint>(CHSELBR->name()   , CW_CHSELBR_TCNT4CRB    ,  0,  8);
    CW_TCNT4CRB   = new scml2::bitfield<uint>(TCNT4CRB->name()  , CW_CHSELBR_TCNT4CRB    , 16,  8);
    cw_instantiate_reg(CW_TCRBS1_, "TCRBS1_", 0x0010);
    CW_TCRBS1     = new scml2::bitfield<uint>(TCRBS1->name()    , CW_TCRBS1_             ,  0,  8);
    cw_instantiate_reg(CW_TCRBS2_, "TCRBS2_", 0x0014);
    CW_TCRBS2     = new scml2::bitfield<uint>(TCRBS2->name()    , CW_TCRBS2_             ,  0,  8);
    cw_instantiate_reg(CW_TCNTB1S1_OCRB1S1, "TCNTB1S1_OCRB1S1", 0x004C);
    CW_TCNTB1S1   = new scml2::bitfield<uint>(TCNTB1S1->name()  , CW_TCNTB1S1_OCRB1S1    ,  0,  8);
    CW_OCRB1S1    = new scml2::bitfield<uint>(OCRB1S1->name()   , CW_TCNTB1S1_OCRB1S1    , 16,  8);
    cw_instantiate_reg(CW_OCRB10S1_OCRB11S1, "OCRB10S1_OCRB11S1", 0x0050);
    CW_OCRB10S1   = new scml2::bitfield<uint>(OCRB10S1->name()  , CW_OCRB10S1_OCRB11S1   ,  0,  8);
    CW_OCRB11S1   = new scml2::bitfield<uint>(OCRB11S1->name()  , CW_OCRB10S1_OCRB11S1   , 16,  8);
    cw_instantiate_reg(CW_OCRB12S1_, "OCRB12S1_", 0x0054);
    CW_OCRB12S1   = new scml2::bitfield<uint>(OCRB12S1->name()  , CW_OCRB12S1_           ,  0,  8);
    cw_instantiate_reg(CW_TCNTB1S2_OCRB1S2, "TCNTB1S2_OCRB1S2", 0x006C);
    CW_TCNTB1S2   = new scml2::bitfield<uint>(TCNTB1S2->name()  , CW_TCNTB1S2_OCRB1S2    ,  0,  8);
    CW_OCRB1S2    = new scml2::bitfield<uint>(OCRB1S2->name()   , CW_TCNTB1S2_OCRB1S2    , 16,  8);
    cw_instantiate_reg(CW_OCRB10S2_OCRB11S2, "OCRB10S2_OCRB11S2", 0x0070);
    CW_OCRB10S2   = new scml2::bitfield<uint>(OCRB10S2->name()  , CW_OCRB10S2_OCRB11S2   ,  0,  8);
    CW_OCRB11S2   = new scml2::bitfield<uint>(OCRB11S2->name()  , CW_OCRB10S2_OCRB11S2   , 16,  8);
    cw_instantiate_reg(CW_OCRB12S2_, "OCRB12S2_", 0x0074);
    CW_OCRB12S2   = new scml2::bitfield<uint>(OCRB12S2->name()  , CW_OCRB12S2_           ,  0,  8);
    cw_instantiate_reg(CW_TCNTB1_OCRB1, "TCNTB1_OCRB1", 0x00C4);
    CW_TCNTB1     = new scml2::bitfield<uint>(TCNTB1->name()    , CW_TCNTB1_OCRB1        ,  0,  8);
    CW_OCRB1      = new scml2::bitfield<uint>(OCRB1->name()     , CW_TCNTB1_OCRB1        , 16,  8);
    cw_instantiate_reg(CW_OCRB10_OCRB11, "OCRB10_OCRB11", 0x00C8);
    CW_OCRB10     = new scml2::bitfield<uint>(OCRB10->name()    , CW_OCRB10_OCRB11       ,  0,  8);
    CW_OCRB11     = new scml2::bitfield<uint>(OCRB11->name()    , CW_OCRB10_OCRB11       , 16,  8);
    cw_instantiate_reg(CW_OCRB12_, "OCRB12_", 0x00CC);
    CW_OCRB12     = new scml2::bitfield<uint>(OCRB12->name()    , CW_OCRB12_             ,  0,  8);
    cw_instantiate_reg(CW_ICRB_30_ICRB_31_ICRB_32_ICRB_33, "ICRB_30_ICRB_31_ICRB_32_ICRB_33", 0x00D8);
    CW_ICRB      [30] = new scml2::bitfield<uint>(ICRB      [30]->name(), CW_ICRB_30_ICRB_31_ICRB_32_ICRB_33,  0,  8);
    CW_ICRB      [31] = new scml2::bitfield<uint>(ICRB      [31]->name(), CW_ICRB_30_ICRB_31_ICRB_32_ICRB_33,  8,  8);
    CW_ICRB      [32] = new scml2::bitfield<uint>(ICRB      [32]->name(), CW_ICRB_30_ICRB_31_ICRB_32_ICRB_33, 16,  8);
    CW_ICRB      [33] = new scml2::bitfield<uint>(ICRB      [33]->name(), CW_ICRB_30_ICRB_31_ICRB_32_ICRB_33, 24,  8);
    cw_instantiate_reg(CW_ICRB_34_ICRB_35_ICRB_36_ICRB_37, "ICRB_34_ICRB_35_ICRB_36_ICRB_37", 0x00DC);
    CW_ICRB      [34] = new scml2::bitfield<uint>(ICRB      [34]->name(), CW_ICRB_34_ICRB_35_ICRB_36_ICRB_37,  0,  8);
    CW_ICRB      [35] = new scml2::bitfield<uint>(ICRB      [35]->name(), CW_ICRB_34_ICRB_35_ICRB_36_ICRB_37,  8,  8);
    CW_ICRB      [36] = new scml2::bitfield<uint>(ICRB      [36]->name(), CW_ICRB_34_ICRB_35_ICRB_36_ICRB_37, 16,  8);
    CW_ICRB      [37] = new scml2::bitfield<uint>(ICRB      [37]->name(), CW_ICRB_34_ICRB_35_ICRB_36_ICRB_37, 24,  8);
    cw_instantiate_reg(CW_OCRB_20_OCRB_21_OCRB_22_OCRB_23, "OCRB_20_OCRB_21_OCRB_22_OCRB_23", 0x00E0);
    CW_OCRB      [20] = new scml2::bitfield<uint>(OCRB      [20]->name(), CW_OCRB_20_OCRB_21_OCRB_22_OCRB_23,  0,  8);
    CW_OCRB      [21] = new scml2::bitfield<uint>(OCRB      [21]->name(), CW_OCRB_20_OCRB_21_OCRB_22_OCRB_23,  8,  8);
    CW_OCRB      [22] = new scml2::bitfield<uint>(OCRB      [22]->name(), CW_OCRB_20_OCRB_21_OCRB_22_OCRB_23, 16,  8);
    CW_OCRB      [23] = new scml2::bitfield<uint>(OCRB      [23]->name(), CW_OCRB_20_OCRB_21_OCRB_22_OCRB_23, 24,  8);
    cw_instantiate_reg(CW_OCRB_24_OCRB_25_OCRB_26_OCRB_27, "OCRB_24_OCRB_25_OCRB_26_OCRB_27", 0x00E4);
    CW_OCRB      [24] = new scml2::bitfield<uint>(OCRB      [24]->name(), CW_OCRB_24_OCRB_25_OCRB_26_OCRB_27,  0,  8);
    CW_OCRB      [25] = new scml2::bitfield<uint>(OCRB      [25]->name(), CW_OCRB_24_OCRB_25_OCRB_26_OCRB_27,  8,  8);
    CW_OCRB      [26] = new scml2::bitfield<uint>(OCRB      [26]->name(), CW_OCRB_24_OCRB_25_OCRB_26_OCRB_27, 16,  8);
    CW_OCRB      [27] = new scml2::bitfield<uint>(OCRB      [27]->name(), CW_OCRB_24_OCRB_25_OCRB_26_OCRB_27, 24,  8);
    cw_instantiate_reg(CW_OCRB_28_OCRB_29_OCRB_30_OCRB_31, "OCRB_28_OCRB_29_OCRB_30_OCRB_31", 0x00E8);
    CW_OCRB      [28] = new scml2::bitfield<uint>(OCRB      [28]->name(), CW_OCRB_28_OCRB_29_OCRB_30_OCRB_31,  0,  8);
    CW_OCRB      [29] = new scml2::bitfield<uint>(OCRB      [29]->name(), CW_OCRB_28_OCRB_29_OCRB_30_OCRB_31,  8,  8);
    CW_OCRB      [30] = new scml2::bitfield<uint>(OCRB      [30]->name(), CW_OCRB_28_OCRB_29_OCRB_30_OCRB_31, 16,  8);
    CW_OCRB      [31] = new scml2::bitfield<uint>(OCRB      [31]->name(), CW_OCRB_28_OCRB_29_OCRB_30_OCRB_31, 24,  8);
    cw_instantiate_reg(CW_OCRB_32_OCRB_33_OCRB_34_OCRB_35, "OCRB_32_OCRB_33_OCRB_34_OCRB_35", 0x00EC);
    CW_OCRB      [32] = new scml2::bitfield<uint>(OCRB      [32]->name(), CW_OCRB_32_OCRB_33_OCRB_34_OCRB_35,  0,  8);
    CW_OCRB      [33] = new scml2::bitfield<uint>(OCRB      [33]->name(), CW_OCRB_32_OCRB_33_OCRB_34_OCRB_35,  8,  8);
    CW_OCRB      [34] = new scml2::bitfield<uint>(OCRB      [34]->name(), CW_OCRB_32_OCRB_33_OCRB_34_OCRB_35, 16,  8);
    CW_OCRB      [35] = new scml2::bitfield<uint>(OCRB      [35]->name(), CW_OCRB_32_OCRB_33_OCRB_34_OCRB_35, 24,  8);
    cw_instantiate_reg(CW_OCRB_36_OCRB_37_OCRB_38_OCRB_39, "OCRB_36_OCRB_37_OCRB_38_OCRB_39", 0x00F0);
    CW_OCRB      [36] = new scml2::bitfield<uint>(OCRB      [36]->name(), CW_OCRB_36_OCRB_37_OCRB_38_OCRB_39,  0,  8);
    CW_OCRB      [37] = new scml2::bitfield<uint>(OCRB      [37]->name(), CW_OCRB_36_OCRB_37_OCRB_38_OCRB_39,  8,  8);
    CW_OCRB      [38] = new scml2::bitfield<uint>(OCRB      [38]->name(), CW_OCRB_36_OCRB_37_OCRB_38_OCRB_39, 16,  8);
    CW_OCRB      [39] = new scml2::bitfield<uint>(OCRB      [39]->name(), CW_OCRB_36_OCRB_37_OCRB_38_OCRB_39, 24,  8);
    cw_instantiate_reg(CW_OCRB_40_OCRB_41_OCRB_42_OCRB_43, "OCRB_40_OCRB_41_OCRB_42_OCRB_43", 0x00F4);
    CW_OCRB      [40] = new scml2::bitfield<uint>(OCRB      [40]->name(), CW_OCRB_40_OCRB_41_OCRB_42_OCRB_43,  0,  8);
    CW_OCRB      [41] = new scml2::bitfield<uint>(OCRB      [41]->name(), CW_OCRB_40_OCRB_41_OCRB_42_OCRB_43,  8,  8);
    CW_OCRB      [42] = new scml2::bitfield<uint>(OCRB      [42]->name(), CW_OCRB_40_OCRB_41_OCRB_42_OCRB_43, 16,  8);
    CW_OCRB      [43] = new scml2::bitfield<uint>(OCRB      [43]->name(), CW_OCRB_40_OCRB_41_OCRB_42_OCRB_43, 24,  8);
    cw_instantiate_reg(CW_PIMR1_PIMR2, "PIMR1_PIMR2", 0x010C);
    CW_PIMR1      = new scml2::bitfield<uint>(PIMR1->name()     , CW_PIMR1_PIMR2         ,  0, 16);
    CW_PIMR2      = new scml2::bitfield<uint>(PIMR2->name()     , CW_PIMR1_PIMR2         , 16, 16);
    cw_instantiate_reg(CW_RARB6_, "RARB6_", 0x0118);
    CW_RARB6      = new scml2::bitfield<uint>(RARB6->name()     , CW_RARB6_              ,  0,  8);
    cw_instantiate_reg(CW_TSEQCRB_TSEQRB, "TSEQCRB_TSEQRB", 0x0140);
    CW_TSEQCRB    = new scml2::bitfield<uint>(TSEQCRB->name()   , CW_TSEQCRB_TSEQRB      ,  0,  8);
    CW_TSEQRB     = new scml2::bitfield<uint>(TSEQRB->name()    , CW_TSEQCRB_TSEQRB      , 16,  8);
    cw_instantiate_reg(CW_TSEQENB_0_TSEQENB_1_TSEQENB_2, "TSEQENB_0_TSEQENB_1_TSEQENB_2", 0x0144);
    CW_TSEQENB   [0] = new scml2::bitfield<uint>(TSEQENB   [0]->name(), CW_TSEQENB_0_TSEQENB_1_TSEQENB_2,  0,  8);
    CW_TSEQENB   [1] = new scml2::bitfield<uint>(TSEQENB   [1]->name(), CW_TSEQENB_0_TSEQENB_1_TSEQENB_2,  8,  8);
    CW_TSEQENB   [2] = new scml2::bitfield<uint>(TSEQENB   [2]->name(), CW_TSEQENB_0_TSEQENB_1_TSEQENB_2, 16,  8);
    cw_instantiate_reg(CW_TEPCFB_0_TEPCFB_1, "TEPCFB_0_TEPCFB_1", 0x0148);
    CW_TEPCFB    [0] = new scml2::bitfield<uint>(TEPCFB    [0]->name(), CW_TEPCFB_0_TEPCFB_1   ,  0, 16);
    CW_TEPCFB    [1] = new scml2::bitfield<uint>(TEPCFB    [1]->name(), CW_TEPCFB_0_TEPCFB_1   , 16, 16);
    cw_instantiate_reg(CW_TEPCFB_2_TEPCFB_3, "TEPCFB_2_TEPCFB_3", 0x014C);
    CW_TEPCFB    [2] = new scml2::bitfield<uint>(TEPCFB    [2]->name(), CW_TEPCFB_2_TEPCFB_3   ,  0, 16);
    CW_TEPCFB    [3] = new scml2::bitfield<uint>(TEPCFB    [3]->name(), CW_TEPCFB_2_TEPCFB_3   , 16, 16);
    cw_instantiate_reg(CW_TEPCFB_4_TEPCFB_5, "TEPCFB_4_TEPCFB_5", 0x0150);
    CW_TEPCFB    [4] = new scml2::bitfield<uint>(TEPCFB    [4]->name(), CW_TEPCFB_4_TEPCFB_5   ,  0, 16);
    CW_TEPCFB    [5] = new scml2::bitfield<uint>(TEPCFB    [5]->name(), CW_TEPCFB_4_TEPCFB_5   , 16, 16);
    cw_instantiate_reg(CW_TEPCFB_6_TEPCFB_7, "TEPCFB_6_TEPCFB_7", 0x0154);
    CW_TEPCFB    [6] = new scml2::bitfield<uint>(TEPCFB    [6]->name(), CW_TEPCFB_6_TEPCFB_7   ,  0, 16);
    CW_TEPCFB    [7] = new scml2::bitfield<uint>(TEPCFB    [7]->name(), CW_TEPCFB_6_TEPCFB_7   , 16, 16);
    cw_instantiate_reg(CW_TEPCFB_8_TEPCFB_9, "TEPCFB_8_TEPCFB_9", 0x0158);
    CW_TEPCFB    [8] = new scml2::bitfield<uint>(TEPCFB    [8]->name(), CW_TEPCFB_8_TEPCFB_9   ,  0, 16);
    CW_TEPCFB    [9] = new scml2::bitfield<uint>(TEPCFB    [9]->name(), CW_TEPCFB_8_TEPCFB_9   , 16, 16);
    cw_instantiate_reg(CW_TEPCFB_10_TEPCFB_11, "TEPCFB_10_TEPCFB_11", 0x015C);
    CW_TEPCFB    [10] = new scml2::bitfield<uint>(TEPCFB    [10]->name(), CW_TEPCFB_10_TEPCFB_11 ,  0, 16);
    CW_TEPCFB    [11] = new scml2::bitfield<uint>(TEPCFB    [11]->name(), CW_TEPCFB_10_TEPCFB_11 , 16, 16);
    cw_instantiate_reg(CW_TEPCFB_12_TEPCFB_13, "TEPCFB_12_TEPCFB_13", 0x0160);
    CW_TEPCFB    [12] = new scml2::bitfield<uint>(TEPCFB    [12]->name(), CW_TEPCFB_12_TEPCFB_13 ,  0, 16);
    CW_TEPCFB    [13] = new scml2::bitfield<uint>(TEPCFB    [13]->name(), CW_TEPCFB_12_TEPCFB_13 , 16, 16);
    cw_instantiate_reg(CW_TEPCFB_14_TEPCFB_15, "TEPCFB_14_TEPCFB_15", 0x0164);
    CW_TEPCFB    [14] = new scml2::bitfield<uint>(TEPCFB    [14]->name(), CW_TEPCFB_14_TEPCFB_15 ,  0, 16);
    CW_TEPCFB    [15] = new scml2::bitfield<uint>(TEPCFB    [15]->name(), CW_TEPCFB_14_TEPCFB_15 , 16, 16);
    cw_instantiate_reg(CW_TEPCFB_16_TEPCFB_17, "TEPCFB_16_TEPCFB_17", 0x0168);
    CW_TEPCFB    [16] = new scml2::bitfield<uint>(TEPCFB    [16]->name(), CW_TEPCFB_16_TEPCFB_17 ,  0, 16);
    CW_TEPCFB    [17] = new scml2::bitfield<uint>(TEPCFB    [17]->name(), CW_TEPCFB_16_TEPCFB_17 , 16, 16);
    cw_instantiate_reg(CW_TEPCFB_18_TEPCFB_19, "TEPCFB_18_TEPCFB_19", 0x016C);
    CW_TEPCFB    [18] = new scml2::bitfield<uint>(TEPCFB    [18]->name(), CW_TEPCFB_18_TEPCFB_19 ,  0, 16);
    CW_TEPCFB    [19] = new scml2::bitfield<uint>(TEPCFB    [19]->name(), CW_TEPCFB_18_TEPCFB_19 , 16, 16);
    cw_instantiate_reg(CW_TEPCFB_20_TEPCFB_21, "TEPCFB_20_TEPCFB_21", 0x0170);
    CW_TEPCFB    [20] = new scml2::bitfield<uint>(TEPCFB    [20]->name(), CW_TEPCFB_20_TEPCFB_21 ,  0, 16);
    CW_TEPCFB    [21] = new scml2::bitfield<uint>(TEPCFB    [21]->name(), CW_TEPCFB_20_TEPCFB_21 , 16, 16);
    cw_instantiate_reg(CW_TEPCFB_22_TEPCFB_23, "TEPCFB_22_TEPCFB_23", 0x0174);
    CW_TEPCFB    [22] = new scml2::bitfield<uint>(TEPCFB    [22]->name(), CW_TEPCFB_22_TEPCFB_23 ,  0, 16);
    CW_TEPCFB    [23] = new scml2::bitfield<uint>(TEPCFB    [23]->name(), CW_TEPCFB_22_TEPCFB_23 , 16, 16);
    cw_instantiate_reg(CW_TEPCFENB_0_TEPCFENB_1_TEPCFENB_2, "TEPCFENB_0_TEPCFENB_1_TEPCFENB_2", 0x0178);
    CW_TEPCFENB  [0] = new scml2::bitfield<uint>(TEPCFENB  [0]->name(), CW_TEPCFENB_0_TEPCFENB_1_TEPCFENB_2,  0,  8);
    CW_TEPCFENB  [1] = new scml2::bitfield<uint>(TEPCFENB  [1]->name(), CW_TEPCFENB_0_TEPCFENB_1_TEPCFENB_2,  8,  8);
    CW_TEPCFENB  [2] = new scml2::bitfield<uint>(TEPCFENB  [2]->name(), CW_TEPCFENB_0_TEPCFENB_1_TEPCFENB_2, 16,  8);
    cw_instantiate_reg(CW_TCCLFRB_TCCLFSRB_TCCLFCRB, "TCCLFRB_TCCLFSRB_TCCLFCRB", 0x018C);
    CW_TCCLFRB    = new scml2::bitfield<uint>(TCCLFRB->name()   , CW_TCCLFRB_TCCLFSRB_TCCLFCRB,  0,  8);
    CW_TCCLFSRB   = new scml2::bitfield<uint>(TCCLFSRB->name()  , CW_TCCLFRB_TCCLFSRB_TCCLFCRB,  8,  8);
    CW_TCCLFCRB   = new scml2::bitfield<uint>(TCCLFCRB->name()  , CW_TCCLFRB_TCCLFSRB_TCCLFCRB, 16,  8);
    cw_instantiate_reg(CW_TCNTB0S1    , TCNTB0S1->name()  , TCNTB0S1->addr()  );
    cw_instantiate_reg(CW_ICRB0S1     , ICRB0S1->name()   , ICRB0S1->addr()   );
    cw_instantiate_reg(CW_OCRB0S1     , OCRB0S1->name()   , OCRB0S1->addr()   );
    cw_instantiate_reg(CW_ICRB1S1     , ICRB1S1->name()   , ICRB1S1->addr()   );
    cw_instantiate_reg(CW_ICRB2S1     , ICRB2S1->name()   , ICRB2S1->addr()   );
    cw_instantiate_reg(CW_TCNTB0S2    , TCNTB0S2->name()  , TCNTB0S2->addr()  );
    cw_instantiate_reg(CW_ICRB0S2     , ICRB0S2->name()   , ICRB0S2->addr()   );
    cw_instantiate_reg(CW_OCRB0S2     , OCRB0S2->name()   , OCRB0S2->addr()   );
    cw_instantiate_reg(CW_ICRB1S2     , ICRB1S2->name()   , ICRB1S2->addr()   );
    cw_instantiate_reg(CW_ICRB2S2     , ICRB2S2->name()   , ICRB2S2->addr()   );
    cw_instantiate_reg(CW_TCNTB0      , TCNTB0->name()    , TCNTB0->addr()    );
    cw_instantiate_reg(CW_ICRB0       , ICRB0->name()     , ICRB0->addr()     );
    for(uint i = 0; i < emNUM_RECRB     ; i++) cw_instantiate_reg(CW_RECRB       [mFactorIndexRECRB     [i]], RECRB     [mFactorIndexRECRB     [i]]->name(), RECRB     [mFactorIndexRECRB     [i]]->addr());
    for(uint i = 0; i < emNUM_RBURB     ; i++) cw_instantiate_reg(CW_RBURB       [i], RBURB     [i]->name(), RBURB     [i]->addr());
    cw_instantiate_reg(CW_OCRB0       , OCRB0->name()     , OCRB0->addr()     );
    cw_instantiate_reg(CW_MIICRB0     , MIICRB0->name()   , MIICRB0->addr()   );
    cw_instantiate_reg(CW_ICRB1       , ICRB1->name()     , ICRB1->addr()     );
    cw_instantiate_reg(CW_ICRB2       , ICRB2->name()     , ICRB2->addr()     );
    cw_instantiate_reg(CW_LDB         , LDB->name()       , LDB->addr()       );
    cw_instantiate_reg(CW_RLDB        , RLDB->name()      , RLDB->addr()      );
    cw_instantiate_reg(CW_TCNTB2      , TCNTB2->name()    , TCNTB2->addr()    );
    cw_instantiate_reg(CW_TCNTB6      , TCNTB6->name()    , TCNTB6->addr()    );
    cw_instantiate_reg(CW_ICRB6       , ICRB6->name()     , ICRB6->addr()     );
    cw_instantiate_reg(CW_TCNTB6M     , TCNTB6M->name()   , TCNTB6M->addr()   );
    cw_instantiate_reg(CW_OCRB6       , OCRB6->name()     , OCRB6->addr()     );
    cw_instantiate_reg(CW_OCRB7       , OCRB7->name()     , OCRB7->addr()     );
    cw_instantiate_reg(CW_TCNTB3      , TCNTB3->name()    , TCNTB3->addr()    );
    cw_instantiate_reg(CW_TCNTB4      , TCNTB4->name()    , TCNTB4->addr()    );
    cw_instantiate_reg(CW_TCNTB5      , TCNTB5->name()    , TCNTB5->addr()    );
    cw_instantiate_reg(CW_TCCLRB      , TCCLRB->name()    , TCCLRB->addr()    );
    cw_instantiate_reg(CW_OCRB8       , OCRB8->name()     , OCRB8->addr()     );
    cw_instantiate_reg(CW_DICRB0      , DICRB0->name()    , DICRB0->addr()    );
    cw_instantiate_reg(CW_DRECRB1     , DRECRB1->name()   , DRECRB1->addr()   );
    cw_instantiate_reg(CW_TEPCRECRB1  , TEPCRECRB1->name(), TEPCRECRB1->addr());
    cw_instantiate_reg(CW_TEPCVALRB0  , TEPCVALRB0->name(), TEPCVALRB0->addr());
    #endif
    mCurReg = mRegArray[index++] = new SRegList(TCRB        , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TIORB       , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TSRB        , mCurReg, 0,  2,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TSCRB       , mCurReg, 0,  2,    "8|16", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TICRB       , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TIERB       , mCurReg, 0,  2,    "8|16", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(CHSELBR     , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TCNT4CRB    , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TCRBS1      , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TCRBS2      , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TCNTB0S1    , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(ICRB0S1     , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(OCRB0S1     , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TCNTB1S1    , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(OCRB1S1     , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(OCRB10S1    , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(OCRB11S1    , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(OCRB12S1    , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(ICRB1S1     , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(ICRB2S1     , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TCNTB0S2    , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(ICRB0S2     , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(OCRB0S2     , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TCNTB1S2    , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(OCRB1S2     , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(OCRB10S2    , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(OCRB11S2    , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(OCRB12S2    , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(ICRB1S2     , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(ICRB2S2     , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TCNTB0      , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(ICRB0       , mCurReg, 0,  4,      "32", "8|16|32");
    for(uint i = 0; i < emNUM_RECRB     ; i++) mCurReg = mRegArray[index++] = new SRegList(RECRB       [mFactorIndexRECRB     [i]], mCurReg, mFactorIndexRECRB     [i],  4,      "32", "8|16|32");
    for(uint i = 0; i < emNUM_RBURB     ; i++) mCurReg = mRegArray[index++] = new SRegList(RBURB       [i], mCurReg, i,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(OCRB0       , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(MIICRB0     , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TCNTB1      , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(OCRB1       , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(OCRB10      , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(OCRB11      , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(OCRB12      , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(ICRB1       , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(ICRB2       , mCurReg, 0,  4,      "32", "8|16|32");
    for(uint i = 0; i < emNUM_ICRB      ; i++) mCurReg = mRegArray[index++] = new SRegList(ICRB        [mFactorIndexICRB      [i]], mCurReg, mFactorIndexICRB      [i],  1,      "32", "8|16|32");
    for(uint i = 0; i < emNUM_OCRB      ; i++) mCurReg = mRegArray[index++] = new SRegList(OCRB        [mFactorIndexOCRB      [i]], mCurReg, mFactorIndexOCRB      [i],  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(LDB         , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(RLDB        , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TCNTB2      , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(PIMR1       , mCurReg, 0,  2,      "16", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(PIMR2       , mCurReg, 0,  2,      "16", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TCNTB6      , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(ICRB6       , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(RARB6       , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TCNTB6M     , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(OCRB6       , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(OCRB7       , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TSEQCRB     , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TSEQRB      , mCurReg, 0,  1,      "32", "8|16|32");
    for(uint i = 0; i < emNUM_TSEQENB   ; i++) mCurReg = mRegArray[index++] = new SRegList(TSEQENB     [i], mCurReg, i,  1,       "8", "8|16|32");
    for(uint i = 0; i < emNUM_TEPCFB    ; i++) mCurReg = mRegArray[index++] = new SRegList(TEPCFB      [i], mCurReg, i,  2,      "16", "8|16|32");
    for(uint i = 0; i < emNUM_TEPCFENB  ; i++) mCurReg = mRegArray[index++] = new SRegList(TEPCFENB    [i], mCurReg, i,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TCNTB3      , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TCNTB4      , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TCNTB5      , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TCCLFRB     , mCurReg, 0,  1,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TCCLFSRB    , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TCCLFCRB    , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TCCLRB      , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(OCRB8       , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(DICRB0      , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(DRECRB1     , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TEPCRECRB1  , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TEPCVALRB0  , mCurReg, 0,  4,      "32", "8|16|32");

    mRegList = mCurReg;

    (*TCRB        ) ( 1,  0, "CKSELB"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TCRB        ) ( 2,  2, "CLRB1SEL", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TCRB        ) ( 4,  3, "CLRB3SEL", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TCRB        ) ( 5,  5, "CLRB1"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TCRB        ) ( 6,  6, "CLRB3"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TCRB        ) ( 7,  7, "PIMRSEL" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TIORB       ) ( 0,  0, "IOB6"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TIORB       ) ( 3,  3, "CCS"     , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TIORB       ) ( 4,  4, "LDEN"    , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TIORB       ) ( 5,  5, "EVCNTB"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TIORB       ) ( 6,  6, "CTCNTB5" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TIORB       ) ( 7,  7, "LDSEL"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TSRB        ) ( 0,  0, "CMFB0"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TSRB        ) ( 1,  1, "ICFB0"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TSRB        ) ( 2,  2, "CMFB1"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TSRB        ) ( 3,  3, "CMFB6"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TSRB        ) ( 4,  4, "CMFB10"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TSRB        ) ( 5,  5, "CMFB11"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TSRB        ) ( 6,  6, "CMFB12"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TSRB        ) ( 8,  8, "CMFB6M"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TSRB        ) ( 9,  9, "CMFB6E"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TSCRB       ) ( 0,  0, "CMFCB0"  , 0x0       , "W1|R"  , vpcl::SPP_ENABLE);
    (*TSCRB       ) ( 1,  1, "ICFCB0"  , 0x0       , "W1|R"  , vpcl::SPP_ENABLE);
    (*TSCRB       ) ( 2,  2, "CMFCB1"  , 0x0       , "W1|R"  , vpcl::SPP_ENABLE);
    (*TSCRB       ) ( 3,  3, "CMFCB6"  , 0x0       , "W1|R"  , vpcl::SPP_ENABLE);
    (*TSCRB       ) ( 4,  4, "CMFCB10" , 0x0       , "W1|R"  , vpcl::SPP_ENABLE);
    (*TSCRB       ) ( 5,  5, "CMFCB11" , 0x0       , "W1|R"  , vpcl::SPP_ENABLE);
    (*TSCRB       ) ( 6,  6, "CMFCB12" , 0x0       , "W1|R"  , vpcl::SPP_ENABLE);
    (*TSCRB       ) ( 8,  8, "CMFCB6M" , 0x0       , "W1|R"  , vpcl::SPP_ENABLE);
    (*TSCRB       ) ( 9,  9, "CMFCB6E" , 0x0       , "W1|R"  , vpcl::SPP_ENABLE);
    (*TICRB       ) ( 1,  0, "IREGB6"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TICRB       ) ( 3,  2, "IREGB6E" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TIERB       ) ( 0,  0, "CMFB0IE" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TIERB       ) ( 1,  1, "ICFB0IE" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TIERB       ) ( 2,  2, "CMFB1IE" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TIERB       ) ( 3,  3, "CMFB6IE" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TIERB       ) ( 4,  4, "CMFB10IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TIERB       ) ( 5,  5, "CMFB11IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TIERB       ) ( 6,  6, "CMFB12IE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TIERB       ) ( 8,  8, "CMFB6MIE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TIERB       ) ( 9,  9, "CMFB6EIE", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*CHSELBR     ) ( 1,  0, "CHSELB"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TCNT4CRB    ) ( 0,  0, "CU4SEL"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TCRBS1      ) ( 2,  2, "CLRB1SELS1", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TCRBS1      ) ( 5,  5, "CLRB1S1" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TCRBS2      ) ( 2,  2, "CLRB1SELS2", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TCRBS2      ) ( 5,  5, "CLRB1S2" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TCNTB0S1    ) (31,  0, "CNTB0S1" , 0x1       , "W|R"   , vpcl::SPP_ENABLE);
    (*ICRB0S1     ) (31,  0, "ICB0S1"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*OCRB0S1     ) (31,  0, "OCB0S1"  , 0xFFFFFFFF, "W|R"   , vpcl::SPP_ENABLE);
    (*TCNTB1S1    ) ( 7,  0, "CNTB1S1" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*OCRB1S1     ) ( 7,  0, "OCB1S1"  , 0xFF      , "W|R"   , vpcl::SPP_ENABLE);
    (*OCRB10S1    ) ( 7,  0, "OCB10S1" , 0xFF      , "W|R"   , vpcl::SPP_ENABLE);
    (*OCRB11S1    ) ( 7,  0, "OCB11S1" , 0xFF      , "W|R"   , vpcl::SPP_ENABLE);
    (*OCRB12S1    ) ( 7,  0, "OCB12S1" , 0xFF      , "W|R"   , vpcl::SPP_ENABLE);
    (*ICRB1S1     ) (31,  0, "ICB1S1"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*ICRB2S1     ) (31,  0, "ICB2S1"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TCNTB0S2    ) (31,  0, "CNTB0S2" , 0x1       , "W|R"   , vpcl::SPP_ENABLE);
    (*ICRB0S2     ) (31,  0, "ICB0S2"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*OCRB0S2     ) (31,  0, "OCB0S2"  , 0xFFFFFFFF, "W|R"   , vpcl::SPP_ENABLE);
    (*TCNTB1S2    ) ( 7,  0, "CNTB1S2" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*OCRB1S2     ) ( 7,  0, "OCB1S2"  , 0xFF      , "W|R"   , vpcl::SPP_ENABLE);
    (*OCRB10S2    ) ( 7,  0, "OCB10S2" , 0xFF      , "W|R"   , vpcl::SPP_ENABLE);
    (*OCRB11S2    ) ( 7,  0, "OCB11S2" , 0xFF      , "W|R"   , vpcl::SPP_ENABLE);
    (*OCRB12S2    ) ( 7,  0, "OCB12S2" , 0xFF      , "W|R"   , vpcl::SPP_ENABLE);
    (*ICRB1S2     ) (31,  0, "ICRB1S2" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*ICRB2S2     ) (31,  0, "ICRB2S2" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TCNTB0      ) (31,  0, "CNTB0"   , 0x1       , "W|R"   , vpcl::SPP_ENABLE);
    (*ICRB0       ) (31,  0, "ICB0"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*OCRB0       ) (31,  0, "OCB0"    , 0xFFFFFFFF, "W|R"   , vpcl::SPP_ENABLE);
    (*MIICRB0     ) (31,  0, "ICB0"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TCNTB1      ) ( 7,  0, "CNTB1"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*OCRB1       ) ( 7,  0, "OCB1"    , 0xFF      , "W|R"   , vpcl::SPP_ENABLE);
    (*OCRB10      ) ( 7,  0, "OCB10"   , 0xFF      , "W|R"   , vpcl::SPP_ENABLE);
    (*OCRB11      ) ( 7,  0, "OCB11"   , 0xFF      , "W|R"   , vpcl::SPP_ENABLE);
    (*OCRB12      ) ( 7,  0, "OCB12"   , 0xFF      , "W|R"   , vpcl::SPP_ENABLE);
    (*ICRB1       ) (31,  0, "ICB1"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*ICRB2       ) (31,  0, "ICB2"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*LDB         ) (23,  0, "LDVAL"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*RLDB        ) (31,  8, "RLDVAL"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TCNTB2      ) (31,  8, "CNTB2"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PIMR1       ) (11,  0, "PIM1"    , 0x1       , "W|R"   , vpcl::SPP_ENABLE);
    (*PIMR2       ) (11,  0, "PIM2"    , 0x1       , "W|R"   , vpcl::SPP_ENABLE);
    (*TCNTB6      ) (31, 12, "CNTB6"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*ICRB6       ) (31, 12, "ICB6"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*RARB6       ) ( 7,  0, "RARB6"   , 0x40      , "W|R"   , vpcl::SPP_ENABLE);
    (*TCNTB6M     ) (31,  6, "CNTB6M"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*OCRB6       ) (31, 12, "OCB6"    , 0xFFFFF   , "W|R"   , vpcl::SPP_ENABLE);
    (*OCRB7       ) (31, 12, "OCB7"    , 0xFFFFF   , "W|R"   , vpcl::SPP_ENABLE);
    (*TSEQCRB     ) ( 0,  0, "EVSEQENB", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TSEQRB      ) ( 4,  0, "SEQB"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TSEQRB      ) ( 7,  7, "FONS"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TCNTB3      ) (31, 12, "CNTB3"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TCNTB4      ) (31, 12, "CNTB4"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TCNTB5      ) (31, 12, "CNTB5"   , 0x1       , "W|R"   , vpcl::SPP_ENABLE);
    (*TCCLFRB     ) ( 0,  0, "TCCLFB"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TCCLFSRB    ) ( 0,  0, "TCCLFSB" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TCCLFCRB    ) ( 0,  0, "TCCLFCB" , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TCCLRB      ) (31, 12, "CCLRB"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*OCRB8       ) (31, 12, "OCB8"    , 0xFFFFF   , "W|R"   , vpcl::SPP_ENABLE);
    (*DICRB0      ) (31,  0, "ICB0"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*DRECRB1     ) (31,  0, "RECRB1"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*TEPCRECRB1  ) (31,  0, "TEPCRECRB1", 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TEPCVALRB0  ) (31,  0, "TEPCVALRB0", 0x0       , "R"     , vpcl::SPP_ENABLE);
    for(uint i = 0; i < emNUM_ICRB; i++) {
        (*ICRB        [mFactorIndexICRB[i]]) ( 7,  0, "ICB"     , 0x0       , "R"     , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_OCRB; i++) {
        (*OCRB        [mFactorIndexOCRB[i]]) ( 7,  0, "OCB"     , 0xFF      , "W|R"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_RECRB; i++) {
        (*RECRB       [mFactorIndexRECRB[i]]) (31,  0, "RECRB"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_TEPCFB; i++) {
        (*TEPCFB      [i]) ( 2,  0, "CRFIT2"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*TEPCFB      [i]) ( 6,  4, "CRFIT1"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
        (*TEPCFB      [i]) (10,  8, "COEFF"   , 0x3       , "W|R"   , vpcl::SPP_ENABLE);
        (*TEPCFB      [i]) (12, 12, "HALFEN"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_TEPCFENB; i++) {
        (*TEPCFENB    [i]) ( 7,  0, "FON"     , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_TSEQENB; i++) {
        (*TSEQENB     [i]) ( 7,  0, "TSEQNENB", 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_RBURB; i++) {
        (*RBURB       [i]) (31,  0, "RBURB"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    }

    mFileName = "";
    mInstName = name;
    mLineNum = 0;
    mBusWidth = buswidth;
    mBusByteWidth = mBusWidth/8;   // using in BIG ENDIAN
    mIsReset = false;

    // Constructor the callback function of each register
    for (uint i = 0; i < mTotalRegNum; i++) {
        mWrCbAPI[mRegArray[i]->my_p->name()][mRegArray[i]->my_p->name()] = NULL;
        mRdCbAPI[mRegArray[i]->my_p->name()][mRegArray[i]->my_p->name()] = NULL;
    }

    //Constructor the mWrCbAPI, mRdCbAPI variable of each register
    mWrCbAPI["TCRB"    ]["CKSELB"  ] = &Catu5010_timerb_regif::cb_TCRB_CKSELB;
    mWrCbAPI["TIORB"   ]["LDSEL"   ] = &Catu5010_timerb_regif::cb_TIORB_LDSEL;
    mWrCbAPI["TSCRB"   ]["CMFCB0"  ] = &Catu5010_timerb_regif::cb_TSCRB_CMFCB0;
    mWrCbAPI["TICRB"   ]["IREGB6"  ] = &Catu5010_timerb_regif::cb_TICRB_IREGB6;
    mWrCbAPI["TCNTB0S1"]["CNTB0S1" ] = &Catu5010_timerb_regif::cb_TCNTB0S1_CNTB0S1;
    mWrCbAPI["OCRB0S1" ]["OCB0S1"  ] = &Catu5010_timerb_regif::cb_OCRB0S1_OCB0S1;
    mWrCbAPI["TCNTB0S2"]["CNTB0S2" ] = &Catu5010_timerb_regif::cb_TCNTB0S2_CNTB0S2;
    mWrCbAPI["OCRB0S2" ]["OCB0S2"  ] = &Catu5010_timerb_regif::cb_OCRB0S2_OCB0S2;
    mWrCbAPI["TCNTB0"  ]["CNTB0"   ] = &Catu5010_timerb_regif::cb_TCNTB0_CNTB0;
    mWrCbAPI["OCRB0"   ]["OCB0"    ] = &Catu5010_timerb_regif::cb_OCRB0_OCB0;
    mWrCbAPI["TCNTB2"  ]["CNTB2"   ] = &Catu5010_timerb_regif::cb_TCNTB2_CNTB2;
    mWrCbAPI["PIMR1"   ]["PIM1"    ] = &Catu5010_timerb_regif::cb_PIMR1_PIM1;
    mWrCbAPI["TSEQCRB" ]["EVSEQENB"] = &Catu5010_timerb_regif::cb_TSEQCRB_EVSEQENB;
    mWrCbAPI["TCNTB4"  ]["CNTB4"   ] = &Catu5010_timerb_regif::cb_TCNTB4_CNTB4;
    mWrCbAPI["TCNTB5"  ]["CNTB5"   ] = &Catu5010_timerb_regif::cb_TCNTB5_CNTB5;
    mWrCbAPI["TCCLFSRB"]["TCCLFSB" ] = &Catu5010_timerb_regif::cb_TCCLFSRB_TCCLFSB;
    mWrCbAPI["TCCLFCRB"]["TCCLFCB" ] = &Catu5010_timerb_regif::cb_TCCLFCRB_TCCLFCB;
    mWrCbAPI["TCCLRB"  ]["CCLRB"   ] = &Catu5010_timerb_regif::cb_TCCLRB_CCLRB;

    for(uint i = 0; i < emNUM_OCRB; i++) {
        str_tmp.str("");
        str_tmp<<"OCRB"<< mFactorIndexOCRB[i];
        mWrCbAPI[str_tmp.str()]["OCB"] = &Catu5010_timerb_regif::cb_OCRB_OCB;
    }
    for(uint i = 0; i < emNUM_TEPCFB; i++) {
        str_tmp.str("");
        str_tmp<<"TEPCFB"<< i;
        mWrCbAPI[str_tmp.str()]["CRFIT2"] = &Catu5010_timerb_regif::cb_TEPCFB_CRFIT2;
    }
    InitLocalVal();
}

/// Destructor: delete pointers
/// @return none
Catu5010_timerb_regif::~Catu5010_timerb_regif()
{
    // Delete registers' pointer
    for (uint i = 0 ; i < mTotalRegNum ; i++) {
        delete mRegArray[i]->my_p;
        mRegArray[i]->prev = NULL;
    }
    delete [] mRegMap;
    delete [] mRegArray;
    delete mRegList;
    mCurReg = NULL;
}

/// Mask unselected bit
/// @return selected value
Catu5010_timerb_regif::uint Catu5010_timerb_regif::bit_select(
                                cuint val,    ///< [in] Writting address
                                cuint start,  ///< [in] start bit position
                                cuint end)    ///< [in] end bit position
{
    uint ret_val = val;
    if (end - start + 1 < 32) {
        ret_val = (val>>start) & (uint)((1<<(end-start+1))-1);
    }
    return ret_val;
}

/// Write the value to requested module register
/// @return true if writing transaction is finished normally
bool Catu5010_timerb_regif::reg_wr(cuint addr,                    ///< [in] Writting address
                                const unsigned char *p_data,   ///< [in] Writing data
                                cuint size)                    ///< [in] Data size (byte)
{
    if(size == 0) return false;
    #ifdef IS_MODELED_ENDIAN_BIG
    if ((addr % mBusByteWidth) + size > mBusByteWidth) return false;
    #endif

    bool ret_val = false;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(p_data != NULL);
    #else
    sc_assert(p_data != NULL);
    #endif
    ret_val = reg_wr_process (addr, p_data, size, false);
    return ret_val;
}

/// Read the register value of requested module
/// @return true if reading transaction is finished normally
bool Catu5010_timerb_regif::reg_rd(cuint addr,              ///< [in]  Reading address
                                unsigned char *p_data,   ///< [out] Reading data
                                cuint size)              ///< [in]  Data size (byte)
{
    if(size == 0) return false;
    #ifdef IS_MODELED_ENDIAN_BIG
    if ((addr % mBusByteWidth) + size > mBusByteWidth) return false;
    #endif

    bool ret_val = false;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(p_data != NULL);
    #else
    sc_assert(p_data != NULL);
    #endif
    ret_val = reg_rd_process (addr, p_data, size, false);
    return ret_val;
}

/// Write the value to requested module register
/// @return true if writing transaction is finished normally
bool Catu5010_timerb_regif::reg_wr_dbg(cuint addr,                    ///< [in] Writting address
                                    const unsigned char *p_data,   ///< [in] Writing data
                                    cuint size)                    ///< [in] Data size (byte)
{
    if(size == 0) return false;
    #ifdef IS_MODELED_ENDIAN_BIG
    if ((addr % mBusByteWidth) + size > mBusByteWidth) return false;
    #endif

    bool ret_val = false;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(p_data != NULL);
    #else
    sc_assert(p_data != NULL);
    #endif
    ret_val = reg_wr_process (addr, p_data, size, true);
    return ret_val;
}

/// Read the register value of requested module
/// @return true if reading transaction is finished normally
bool Catu5010_timerb_regif::reg_rd_dbg(cuint addr,              ///< [in]  Reading address
                                    unsigned char *p_data,   ///< [out] Reading data
                                    cuint size)              ///< [in]  Data size (byte)
{
    if(size == 0) return false;
    #ifdef IS_MODELED_ENDIAN_BIG
    if ((addr % mBusByteWidth) + size > mBusByteWidth) return false;
    #endif

    bool ret_val = false;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(p_data != NULL);
    #else
    sc_assert(p_data != NULL);
    #endif
    ret_val = reg_rd_process (addr, p_data, size, true);
    return ret_val;
}

/// Write the value to requested module register
/// @return true if writing transaction is finished normally
bool Catu5010_timerb_regif::reg_wr_process(cuint addr,                   ///< [in] Writting address
                                        const unsigned char *p_data,  ///< [in] Writing data
                                        cuint size,                   ///< [in] Data size (byte)
                                        bool IsDbgFunc)               ///< [in] flag indicate reg_rd or reg_rd_dbg
{
    if (mIsReset == true) {
        re_printf("warning", "Cannot write during reset period\n");
        return true;
    }
    uint tmp_addr = addr;
    #ifdef IS_MODELED_ENDIAN_BIG
    if (size < mBusByteWidth) {
        tmp_addr = addr ^ (mBusByteWidth - size);
    }
    #endif
    bool ret_val = false;
    bool valid_addr = false;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(p_data != NULL);
    #else
    sc_assert(p_data != NULL);
    #endif
    std::list<uint> list_index;
    uint masked_addr = bit_select(tmp_addr, 0, 9-1);
    uint access_addr = masked_addr;
    while (masked_addr + size > access_addr) {
        int reg_index = get_reg_index(access_addr);
        if (reg_index != -1) {
            vpcl::re_register *reg_p = mRegArray[reg_index]->my_p; 
            if ((IsDbgFunc == true) || (valid_addr == true) || (ChkSize(mRegArray[reg_index]->wacc_size, size, tmp_addr))) {
                valid_addr = true;
                list_index.push_back(reg_index);
            }
            else {
                re_printf("error", "Writing access size to %s at address 0x%08X is wrong: %d byte(s).\n", reg_p->name().c_str(), tmp_addr, size);
                return false;
            }
            access_addr = reg_p->addr() + mRegArray[reg_index]->length;
        } else {
            access_addr += 1;
        }
    }
    if (valid_addr == true) {
        std::list<uint>::iterator it;
        for (it=list_index.begin() ; it!=list_index.end() ; it++) {
            access_addr = masked_addr;
            uint d_size = size;
            uint index = 0;
            if (masked_addr < mRegArray[(*it)]->my_p->addr()) { // adjust access address & index
                access_addr = mRegArray[(*it)]->my_p->addr();
                index = mRegArray[(*it)]->my_p->addr() - masked_addr;
            }
            if ((masked_addr + size) < (mRegArray[(*it)]->my_p->addr() + mRegArray[(*it)]->length)) { // adjust access size
                d_size = masked_addr + size - access_addr;
            } else { // adjust access size
                d_size = (mRegArray[(*it)]->my_p->addr() + mRegArray[(*it)]->length) - access_addr;
            }
            if (size > mRegArray[(*it)]->length) { // adjust index for big endianess
                #ifdef IS_MODELED_ENDIAN_BIG
                index = index ^ (size - mRegArray[(*it)]->length);
                #endif
            }
            ret_val = reg_wr_func(tmp_addr - masked_addr + access_addr, &(p_data[index]), d_size, (*it), IsDbgFunc);
        }
    } else {
        if (IsDbgFunc == false) {
            re_printf("error", "Invalid access address 0x%08X\n", tmp_addr);
        } else {
            ret_val = true;
        }
    }
    return ret_val;
}

/// Read the register value of requested module
/// @return true if reading transaction is finished normally
bool Catu5010_timerb_regif::reg_rd_process(cuint addr,              ///< [in]  Reading address
                                        unsigned char *p_data,   ///< [out] Reading data
                                        cuint size,              ///< [in]  Data size (byte)
                                        bool IsDbgFunc)          ///< [in] flag indicate reg_rd or reg_rd_dbg
{
    uint tmp_addr = addr;
    #ifdef IS_MODELED_ENDIAN_BIG
    if (size < mBusByteWidth) {
        tmp_addr = addr ^ (mBusByteWidth - size);
    }
    #endif
    bool ret_val = false;
    bool valid_addr = false;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(p_data != NULL);
    #else
    sc_assert(p_data != NULL);
    #endif
    std::list<uint> list_index;
    uint masked_addr = bit_select(tmp_addr, 0, 9-1);
    uint access_addr = masked_addr;
    while (masked_addr + size > access_addr) {
        int reg_index = get_reg_index(access_addr);
        if (reg_index != -1) {
            vpcl::re_register *reg_p = mRegArray[reg_index]->my_p; 
            if ((IsDbgFunc == true) || (valid_addr == true) || (ChkSize(mRegArray[reg_index]->racc_size, size, tmp_addr))) {
                valid_addr = true;
                list_index.push_back(reg_index);
            }
            else {
                re_printf("error", "Reading access size to %s at address 0x%08X is wrong: %d byte(s).\n", reg_p->name().c_str(), tmp_addr, size);
                return false;
            }
            access_addr = reg_p->addr() + mRegArray[reg_index]->length;
        } else {
            access_addr += 1;
        }
    }
    if (valid_addr == true) {
        std::list<uint>::iterator it;
        for (it=list_index.begin() ; it!=list_index.end() ; it++) {
            access_addr = masked_addr;
            uint d_size = size;
            uint index = 0;
            if (masked_addr < mRegArray[(*it)]->my_p->addr()) { // adjust access address & index
                access_addr = mRegArray[(*it)]->my_p->addr();
                index = mRegArray[(*it)]->my_p->addr() - masked_addr;
            }
            if ((masked_addr + size) < (mRegArray[(*it)]->my_p->addr() + mRegArray[(*it)]->length)) { // adjust access size
                d_size = masked_addr + size - access_addr;
            } else { // adjust access size
                d_size = (mRegArray[(*it)]->my_p->addr() + mRegArray[(*it)]->length) - access_addr;
            }
            if (size > mRegArray[(*it)]->length) { // adjust index for big endianess
                #ifdef IS_MODELED_ENDIAN_BIG
                index = index ^ (size - mRegArray[(*it)]->length);
                #endif
            }
            ret_val = reg_rd_func(tmp_addr - masked_addr + access_addr, &(p_data[index]), d_size, (*it), IsDbgFunc);
        }
    } else {
        if (IsDbgFunc == false) {
            re_printf("error", "Invalid access address 0x%08X\n", tmp_addr);
        } else {
            memset(p_data, 0, size);
            ret_val = true;
        }
    }
    return ret_val;
}

/// Process reading function
/// @return true if reading successfully
bool Catu5010_timerb_regif::reg_rd_func(cuint addr,                     ///< [in]  Reading address
                                     unsigned char *p_data,          ///< [out] Reading data
                                     cuint size,                     ///< [in]  Data size (byte)
                                     cuint reg_index,                ///< [in] Register index
                                     bool IsDbgFunc)                 ///< [in] flag indicate reg_rd or reg_rd_dbg
{
    vpcl::re_register* Register = mRegArray[reg_index]->my_p;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(Register != NULL);
    #else
    sc_assert(Register != NULL);
    #endif
    
    uint pst_data = 0;
    #if 1 // always 1 since any size can be accessed in debug mode 
    uint reg_length = mRegArray[reg_index]->length;
    uint start_pos = 0;
    uint mask_size = (1 << (reg_length/2)) - 1;
    if (size < reg_length) {
        #ifdef IS_MODELED_ENDIAN_BIG
        start_pos =  (reg_length - 1)*8 - (addr & mask_size)*8; // Start bit position
        #else
        start_pos =  (addr & mask_size)*8;  // Start bit position
        #endif
    }
    #endif
    if (IsDbgFunc == false) {
        if (mIsReset == true) {
            re_printf("warning", "Cannot launch call-back function during reset period\n");
        }else {
            #if 1 // always 1 since any size can be accessed in debug mode 
            if (size < reg_length) {
                re_printf("warning","Should read all bit in a register\n");
            }
            #endif
            
            pst_data = Register->read();
            
        }
    }
    pst_data = (uint)(*Register);
    #if 1 // always 1 since any size can be accessed in debug mode 
    if (size < reg_length) {
        uint read_data = 0;
        if (((reg_length%2 == 0) && (reg_length%size == 0) && ((addr&mask_size)%size == 0)) 
         || (IsDbgFunc == false)) {
            for (uint i = start_pos; i < (8*size + start_pos); i++) {
                read_data |= (pst_data & (1 << i)) >> start_pos;
            }
            pst_data = read_data;
        }
    }
    #endif

    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(p_data != NULL);
    #else
    sc_assert(p_data != NULL);
    #endif
    memcpy(p_data, &pst_data, size);
    DumpRegMsg("R", Register->name(), "", size, addr, 0, 0, pst_data, mRegArray[reg_index]->length*8);
    for (vpcl::bit_info *it=Register->mBitInfo ; it!=NULL ; it=it->next) {
        uint val = (uint)(*Register);
        val = bit_select(val, it->mStartAddr, it->mEndAddr);
        DumpRegMsg("R", Register->name(), it->name(), size, addr, 0, 0, val, it->mEndAddr - it->mStartAddr + 1);
    }
    return true;
}

/// Process writing function
/// @return true if writing successfully
bool Catu5010_timerb_regif::reg_wr_func(cuint addr,                       ///< [in] Writting address
                                     const unsigned char *p_data,      ///< [in] Writing data
                                     cuint size,                       ///< [in] Data size (byte)
                                     cuint reg_index,                  ///< [in] Register index
                                     bool IsDbgFunc)                   ///< [in] flag indicate reg_wr or reg_wr_dbg
{
    vpcl::re_register* Register = mRegArray[reg_index]->my_p;
    uint pre_data = 0;
    uint data = 0;
    #if 1 // always 1 since any size can be accessed in debug mode 
    uint reg_length = mRegArray[reg_index]->length;
    uint start_pos = 0;
    #endif
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert ((p_data != NULL) && (Register != NULL));
    #else
    sc_assert ((p_data != NULL) && (Register != NULL));
    #endif
    memcpy(&data, p_data, size);
    #if 1 // always 1 since any size can be accessed in debug mode 
    if (size < reg_length) {
        uint mask_size = (1 << (reg_length/2)) - 1;
        if (((reg_length%2 == 0) && (reg_length%size == 0) && ((addr&mask_size)%size == 0)) 
         || (IsDbgFunc == false)) {
            uint new_data = (uint)(*Register);  // For writing to register
            uint written_data = 0;         // For transferring to callback function
            #ifdef IS_MODELED_ENDIAN_BIG
            start_pos =  (reg_length - 1)*8 - (addr & mask_size)*8; // Start bit position
            #else
            start_pos =  (addr & mask_size)*8;  // Start bit position
            #endif
            for (uint i = start_pos; i < (8*size + start_pos); i++) {
                new_data = (new_data & (~(1 << i))) | ((data << start_pos) & (1 << i));
                written_data = (written_data & (~(1 << i))) | ((data << start_pos) & (1 << i));
            }
            data = new_data;
        }
    }
    #endif

    if ((mRegArray[reg_index]->block == false) || (IsDbgFunc == true)){
        pre_data = (uint)(*Register);
        if (IsDbgFunc == true) {
            bool backup_warning = Register->mMessageLevel["warning"];
            bool backup_error = Register->mMessageLevel["error"];
            Register->mMessageLevel["warning"]   = false;
            Register->mMessageLevel["error"]   = false;

            Register->write(data);

            Register->mMessageLevel["warning"]   = backup_warning;
            Register->mMessageLevel["error"]   = backup_error;
        } else {
            Register->write(data);
        }
        UpdateLocalVal(Register->addr());
        DumpRegMsg("W", Register->name(), "", size, addr, data, pre_data, (uint)(*Register), mRegArray[reg_index]->length*8);
        for (vpcl::bit_info *it=Register->mBitInfo ; it!=NULL ; it=it->next) {
            uint val = (uint)(*Register);
            val = bit_select(val, it->mStartAddr, it->mEndAddr);
            uint pre_val = pre_data;
            pre_val = bit_select(pre_val, it->mStartAddr, it->mEndAddr);
            DumpRegMsg("W", Register->name(), it->name(), size, addr, 0, pre_val, val, it->mEndAddr - it->mStartAddr + 1);
            if ((mWrCbAPI[Register->name()][it->name()]) != NULL) {
                (this->*(mWrCbAPI[Register->name()][it->name()]))(RegCBstr(mRegArray[reg_index]->channel, true, size, pre_data, data));
            }
        }
    }
    else {
        re_printf("warning","%s is blocked writing from Bus I/F.\n", Register->name().c_str());
    }
    return true;
}

/// Check access size
/// @@return true if detect_size equal expect_size
bool Catu5010_timerb_regif::ChkSize(std::string expect_size, cuint detect_size, cuint addr)
{
    std::vector<std::string> arg_vec = Str2Vec(expect_size, '|');
    std::vector<std::string>::iterator it;
    char *err_p = NULL;
    uint size = 0;
    if (detect_size > mBusByteWidth) {
        re_printf("error", "Invalid access size: %d bytes\n", detect_size);
        return false;
    }
    if(addr%detect_size != 0) {
        re_printf("error", "Invalid access address 0x%08X with access size %d bytes\n", addr, detect_size);
        return false;
    }
    for (it = arg_vec.begin(); it != arg_vec.end(); it++) {
        errno = 0; size = (uint) strtoul((*it).c_str(), &err_p, 0);
        #ifdef REGIF_NOT_USE_SYSTEMC
        assert(err_p != NULL);
        #else
        sc_assert(err_p != NULL);
        #endif
        if (errno != ERANGE && *err_p == '\0') {
            if ((size/8) == detect_size) {
                return true;
            }
        }
    }
    return false;
}

/// Initialize reg_handle_command variables
/// @return none
void Catu5010_timerb_regif::CommandInit()
{
    mDumpRegisterRW = false;
    mMessageLevel["fatal"]   = true;
    mMessageLevel["error"]   = true;
    mMessageLevel["warning"] = false;
    mMessageLevel["info"]    = false;
}

/// Process reg_handle_command command
/// @return string
std::string Catu5010_timerb_regif::reg_handle_command(const std::vector<std::string>& args)
{
    std::string ret = "";
    std::string err_msg = "Error ("   + mInstName + ") ";   // error message
    if (args[0] == "reg") {
        if (args[1] == "help") {
            ret += "    --- reg ---\n";
            ret += "    reg MessageLevel <fatal|error|warning|info> Select debug message level (Default: fatal,error)\n";
            ret += "    reg DumpRegisterRW <true/false>             Select dump register access information  (Default: false)\n";
            ret += "    reg <register_name> MessageLevel <fatal|error|warning|info> Select debug message level for register (Default: fatal,error)\n";
            ret += "    reg <register_name> force <value>           Force register with setting value\n";
            ret += "    reg <register_name> release                 Release register from force value\n";
            ret += "    reg <register_name> <value>                 Write a value into register\n";
            ret += "    reg <register_name>                         Read value of register\n";
            ret += "    reg help                                    Show a direction\n";
        }
        else if (args[1] == "DumpRegisterRW") {
            if (args.size() == 2) {
                ret = (mDumpRegisterRW)? "true" : "false";
            }
            else if (args.size() == 3) {
                if (args[2] == "true") {
                    mDumpRegisterRW = true;
                }
                else if (args[2] == "false") {
                    mDumpRegisterRW = false;
                } else {
                    ret = err_msg + "DumpRegisterRW command needs an argument [true/false]\n";
                }
            } else {
                ret = err_msg + "DumpRegisterRW has too much arguments\n";
            }
        }
        else if (args[1] == "MessageLevel") {
            // read mode
            if (args.size() == 2) {
                std::map<std::string, bool>::iterator it;
                for (it = mMessageLevel.begin(); it != mMessageLevel.end(); it++) {
                    if ( it->second == true ) {
                        ret += " " + it->first;
                    }
                }
            // write mode
            } else if (args.size() == 3) {
                std::vector<std::string> arg_vec = Str2Vec(args[2], '|');
                std::map<std::string, bool>::iterator msgit;
                for (msgit =mMessageLevel.begin(); msgit != mMessageLevel.end(); msgit++) {
                    msgit->second = false;
                }
                std::vector<std::string>::iterator it;
                for (it = arg_vec.begin(); it != arg_vec.end(); it++) {
                    mMessageLevel[*it] = true;
                }
            } else {
                ret = err_msg + "MessageLevel has too much arguments\n";
            }
        } else {
            bool matched = false;
            for (uint i = 0; i < mTotalRegNum; i++) {
                if (args[1] == mRegArray[i]->my_p->name()) {
                    ret = AccessRegCommand(args, mRegArray[i]->my_p, mRegArray[i]->block);
                    matched = true;
                    break;
                }
            }
            if (!matched) {
                ret = err_msg + "Register name " + (std::string)args[1] + " is invalid\n";
            }
        }
    }
    return ret;
}

/// process reg_handle_command of "reg" parameter
/// @return string
std::string Catu5010_timerb_regif::AccessRegCommand(const std::vector<std::string>& args, vpcl::re_register *Register, bool &BlockReg)
{
    std::string ret = "";
    char *err_p = NULL;
    std::string err_msg = "Error ("   + mInstName + ") ";   // error message
    uint data = 0;
    std::ostringstream str_tmp;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(Register != NULL);
    #else
    sc_assert(Register != NULL);
    #endif
    if (args.size() == 2) {
        data = (uint)(*Register);
        str_tmp<<std::setw(14)<<std::left<<(Register->name());
        str_tmp<<"0x"<<std::setw(8)<<std::hex<<std::uppercase<<std::left<<data<<"\n";
        ret = str_tmp.str();
    } else if ((args.size() == 3) && (args[2] == "release")) {
        BlockReg = false;
    } else if ((args.size() == 4) && (args[2] == "force")) {
        errno = 0; data = (uint) strtoul(args[3].c_str(), &err_p, 0);
        #ifdef REGIF_NOT_USE_SYSTEMC
        assert(err_p != NULL);
        #else
        sc_assert(err_p != NULL);
        #endif
        if (errno != ERANGE && *err_p == '\0') {
            *Register = data;
            BlockReg = true;
            UpdateLocalVal(Register->addr());
        } else {
            ret = err_msg + "[" + Register->name() + "] Invalid force value\n";
        }
    } else if ((args.size() >= 3) && (args[2] == "MessageLevel")) {
        if (args.size() == 3) {
            ret = Register->name() + " ";
            ret += Register->GetMessageLevel();
        } else if (args.size() == 4) {
            std::map<std::string, bool> MessageLevel;
            std::vector<std::string> arg_vec = Str2Vec(args[3], '|');
            std::vector<std::string>::iterator it;
            for (it = arg_vec.begin(); it != arg_vec.end(); it++) {
                MessageLevel[*it] = true;
            }
            Register->SetMessageLevel(MessageLevel);
        } else {
            ret = err_msg + "[" + Register->name() + "] MessageLevel has too much arguments\n";
        }
    } else if ((args.size() == 3) && (args[2] != "release")) {
        errno = 0; data = (uint) strtoul(args[2].c_str(), &err_p, 0);
        if (errno != ERANGE && *err_p == '\0') {
            *Register = data;
            UpdateLocalVal(Register->addr());
        } else {
            ret = err_msg + "[" + Register->name() + "] Invalid write value\n";
        }
    } else {
        ret = err_msg + "Wrong command : ";
        for (uint index = 0; index < args.size(); index ++) {
            ret += args[index] + " ";
        }
    }
    return ret;
}

/// Initialize local variables
/// @return none
void Catu5010_timerb_regif::InitLocalVal()
{
    // Initialize local variables
    TCRB_CKSELB = 0x0;
    TCRB_CLRB1SEL = 0x0;
    TCRB_CLRB3SEL = 0x0;
    TCRB_CLRB1  = 0x0;
    TCRB_CLRB3  = 0x0;
    TCRB_PIMRSEL = 0x0;
    TIORB_IOB6  = 0x0;
    TIORB_CCS   = 0x0;
    TIORB_LDEN  = 0x0;
    TIORB_EVCNTB = 0x0;
    TIORB_CTCNTB5 = 0x0;
    TIORB_LDSEL = 0x0;
    TSRB_CMFB0  = 0x0;
    TSRB_ICFB0  = 0x0;
    TSRB_CMFB1  = 0x0;
    TSRB_CMFB6  = 0x0;
    TSRB_CMFB10 = 0x0;
    TSRB_CMFB11 = 0x0;
    TSRB_CMFB12 = 0x0;
    TSRB_CMFB6M = 0x0;
    TSRB_CMFB6E = 0x0;
    TSCRB_CMFCB0 = 0x0;
    TSCRB_ICFCB0 = 0x0;
    TSCRB_CMFCB1 = 0x0;
    TSCRB_CMFCB6 = 0x0;
    TSCRB_CMFCB10 = 0x0;
    TSCRB_CMFCB11 = 0x0;
    TSCRB_CMFCB12 = 0x0;
    TSCRB_CMFCB6M = 0x0;
    TSCRB_CMFCB6E = 0x0;
    TICRB_IREGB6 = 0x0;
    TICRB_IREGB6E = 0x0;
    TIERB_CMFB0IE = 0x0;
    TIERB_ICFB0IE = 0x0;
    TIERB_CMFB1IE = 0x0;
    TIERB_CMFB6IE = 0x0;
    TIERB_CMFB10IE = 0x0;
    TIERB_CMFB11IE = 0x0;
    TIERB_CMFB12IE = 0x0;
    TIERB_CMFB6MIE = 0x0;
    TIERB_CMFB6EIE = 0x0;
    CHSELBR_CHSELB = 0x0;
    TCNT4CRB_CU4SEL = 0x0;
    TCRBS1_CLRB1SELS1 = 0x0;
    TCRBS1_CLRB1S1 = 0x0;
    TCRBS2_CLRB1SELS2 = 0x0;
    TCRBS2_CLRB1S2 = 0x0;
    TCNTB0S1_CNTB0S1 = 0x1;
    ICRB0S1_ICB0S1 = 0x0;
    OCRB0S1_OCB0S1 = 0xFFFFFFFF;
    TCNTB1S1_CNTB1S1 = 0x0;
    OCRB1S1_OCB1S1 = 0xFF;
    OCRB10S1_OCB10S1 = 0xFF;
    OCRB11S1_OCB11S1 = 0xFF;
    OCRB12S1_OCB12S1 = 0xFF;
    ICRB1S1_ICB1S1 = 0x0;
    ICRB2S1_ICB2S1 = 0x0;
    TCNTB0S2_CNTB0S2 = 0x1;
    ICRB0S2_ICB0S2 = 0x0;
    OCRB0S2_OCB0S2 = 0xFFFFFFFF;
    TCNTB1S2_CNTB1S2 = 0x0;
    OCRB1S2_OCB1S2 = 0xFF;
    OCRB10S2_OCB10S2 = 0xFF;
    OCRB11S2_OCB11S2 = 0xFF;
    OCRB12S2_OCB12S2 = 0xFF;
    ICRB1S2_ICRB1S2 = 0x0;
    ICRB2S2_ICRB2S2 = 0x0;
    TCNTB0_CNTB0 = 0x1;
    ICRB0_ICB0  = 0x0;
    for(uint i = 0; i < emNUM_RECRB;     i++) {
        RECRB_RECRB[mFactorIndexRECRB[i]] = 0x0;
    }
    for(uint i = 0; i < emNUM_RBURB;     i++) {
        RBURB_RBURB[i] = 0x0;
    }
    OCRB0_OCB0  = 0xFFFFFFFF;
    MIICRB0_ICB0 = 0x0;
    TCNTB1_CNTB1 = 0x0;
    OCRB1_OCB1  = 0xFF;
    OCRB10_OCB10 = 0xFF;
    OCRB11_OCB11 = 0xFF;
    OCRB12_OCB12 = 0xFF;
    ICRB1_ICB1  = 0x0;
    ICRB2_ICB2  = 0x0;
    for(uint i = 0; i < emNUM_ICRB;      i++) {
        ICRB_ICB   [mFactorIndexICRB[i]] = 0x0;
    }
    for(uint i = 0; i < emNUM_OCRB;      i++) {
        OCRB_OCB   [mFactorIndexOCRB[i]] = 0xFF;
    }
    LDB_LDVAL   = 0x0;
    RLDB_RLDVAL = 0x0;
    TCNTB2_CNTB2 = 0x0;
    PIMR1_PIM1  = 0x1;
    PIMR2_PIM2  = 0x1;
    TCNTB6_CNTB6 = 0x0;
    ICRB6_ICB6  = 0x0;
    RARB6_RARB6 = 0x40;
    TCNTB6M_CNTB6M = 0x0;
    OCRB6_OCB6  = 0xFFFFF;
    OCRB7_OCB7  = 0xFFFFF;
    TSEQCRB_EVSEQENB = 0x0;
    TSEQRB_SEQB = 0x0;
    TSEQRB_FONS = 0x0;
    for(uint i = 0; i < emNUM_TSEQENB;   i++) {
        TSEQENB_TSEQNENB[i] = 0x0;
    }
    for(uint i = 0; i < emNUM_TEPCFB;    i++) {
        TEPCFB_CRFIT2[i] = 0x0;
        TEPCFB_CRFIT1[i] = 0x0;
        TEPCFB_COEFF[i] = 0x3;
        TEPCFB_HALFEN[i] = 0x0;
    }
    for(uint i = 0; i < emNUM_TEPCFENB;  i++) {
        TEPCFENB_FON[i] = 0x0;
    }
    TCNTB3_CNTB3 = 0x0;
    TCNTB4_CNTB4 = 0x0;
    TCNTB5_CNTB5 = 0x1;
    TCCLFRB_TCCLFB = 0x0;
    TCCLFSRB_TCCLFSB = 0x0;
    TCCLFCRB_TCCLFCB = 0x0;
    TCCLRB_CCLRB = 0x0;
    OCRB8_OCB8  = 0xFFFFF;
    DICRB0_ICB0 = 0x0;
    DRECRB1_RECRB1 = 0x0;
    TEPCRECRB1_TEPCRECRB1 = 0x0;
    TEPCVALRB0_TEPCVALRB0 = 0x0;
}

/// Update bit value to local value
/// @return None
void Catu5010_timerb_regif::UpdateLocalVal(cuint addr)
{
    if (addr == 0x0000) {
        TCRB_CKSELB                    = (*TCRB      )["CKSELB"    ];
        TCRB_CLRB1SEL                  = (*TCRB      )["CLRB1SEL"  ];
        TCRB_CLRB3SEL                  = (*TCRB      )["CLRB3SEL"  ];
        TCRB_CLRB1                     = (*TCRB      )["CLRB1"     ];
        TCRB_CLRB3                     = (*TCRB      )["CLRB3"     ];
        TCRB_PIMRSEL                   = (*TCRB      )["PIMRSEL"   ];
        return;
    }
    if (addr == 0x0002) {
        TIORB_IOB6                     = (*TIORB     )["IOB6"      ];
        TIORB_CCS                      = (*TIORB     )["CCS"       ];
        TIORB_LDEN                     = (*TIORB     )["LDEN"      ];
        TIORB_EVCNTB                   = (*TIORB     )["EVCNTB"    ];
        TIORB_CTCNTB5                  = (*TIORB     )["CTCNTB5"   ];
        TIORB_LDSEL                    = (*TIORB     )["LDSEL"     ];
        return;
    }
    if (addr == 0x0004) {
        TSRB_CMFB0                     = (*TSRB      )["CMFB0"     ];
        TSRB_ICFB0                     = (*TSRB      )["ICFB0"     ];
        TSRB_CMFB1                     = (*TSRB      )["CMFB1"     ];
        TSRB_CMFB6                     = (*TSRB      )["CMFB6"     ];
        TSRB_CMFB10                    = (*TSRB      )["CMFB10"    ];
        TSRB_CMFB11                    = (*TSRB      )["CMFB11"    ];
        TSRB_CMFB12                    = (*TSRB      )["CMFB12"    ];
        TSRB_CMFB6M                    = (*TSRB      )["CMFB6M"    ];
        TSRB_CMFB6E                    = (*TSRB      )["CMFB6E"    ];
        return;
    }
    if (addr == 0x0006) {
        TSCRB_CMFCB0                   = (*TSCRB     )["CMFCB0"    ];
        TSCRB_ICFCB0                   = (*TSCRB     )["ICFCB0"    ];
        TSCRB_CMFCB1                   = (*TSCRB     )["CMFCB1"    ];
        TSCRB_CMFCB6                   = (*TSCRB     )["CMFCB6"    ];
        TSCRB_CMFCB10                  = (*TSCRB     )["CMFCB10"   ];
        TSCRB_CMFCB11                  = (*TSCRB     )["CMFCB11"   ];
        TSCRB_CMFCB12                  = (*TSCRB     )["CMFCB12"   ];
        TSCRB_CMFCB6M                  = (*TSCRB     )["CMFCB6M"   ];
        TSCRB_CMFCB6E                  = (*TSCRB     )["CMFCB6E"   ];
        return;
    }
    if (addr == 0x0008) {
        TICRB_IREGB6                   = (*TICRB     )["IREGB6"    ];
        TICRB_IREGB6E                  = (*TICRB     )["IREGB6E"   ];
        return;
    }
    if (addr == 0x000A) {
        TIERB_CMFB0IE                  = (*TIERB     )["CMFB0IE"   ];
        TIERB_ICFB0IE                  = (*TIERB     )["ICFB0IE"   ];
        TIERB_CMFB1IE                  = (*TIERB     )["CMFB1IE"   ];
        TIERB_CMFB6IE                  = (*TIERB     )["CMFB6IE"   ];
        TIERB_CMFB10IE                 = (*TIERB     )["CMFB10IE"  ];
        TIERB_CMFB11IE                 = (*TIERB     )["CMFB11IE"  ];
        TIERB_CMFB12IE                 = (*TIERB     )["CMFB12IE"  ];
        TIERB_CMFB6MIE                 = (*TIERB     )["CMFB6MIE"  ];
        TIERB_CMFB6EIE                 = (*TIERB     )["CMFB6EIE"  ];
        return;
    }
    if (addr == 0x000C) {
        CHSELBR_CHSELB                 = (*CHSELBR   )["CHSELB"    ];
        return;
    }
    if (addr == 0x000E) {
        TCNT4CRB_CU4SEL                = (*TCNT4CRB  )["CU4SEL"    ];
        return;
    }
    if (addr == 0x0010) {
        TCRBS1_CLRB1SELS1              = (*TCRBS1    )["CLRB1SELS1"];
        TCRBS1_CLRB1S1                 = (*TCRBS1    )["CLRB1S1"   ];
        return;
    }
    if (addr == 0x0014) {
        TCRBS2_CLRB1SELS2              = (*TCRBS2    )["CLRB1SELS2"];
        TCRBS2_CLRB1S2                 = (*TCRBS2    )["CLRB1S2"   ];
        return;
    }
    if (addr == 0x0040) {
        TCNTB0S1_CNTB0S1               = (*TCNTB0S1  )["CNTB0S1"   ];
        return;
    }
    if (addr == 0x0044) {
        ICRB0S1_ICB0S1                 = (*ICRB0S1   )["ICB0S1"    ];
        return;
    }
    if (addr == 0x0048) {
        OCRB0S1_OCB0S1                 = (*OCRB0S1   )["OCB0S1"    ];
        return;
    }
    if (addr == 0x004C) {
        TCNTB1S1_CNTB1S1               = (*TCNTB1S1  )["CNTB1S1"   ];
        return;
    }
    if (addr == 0x004E) {
        OCRB1S1_OCB1S1                 = (*OCRB1S1   )["OCB1S1"    ];
        return;
    }
    if (addr == 0x0050) {
        OCRB10S1_OCB10S1               = (*OCRB10S1  )["OCB10S1"   ];
        return;
    }
    if (addr == 0x0052) {
        OCRB11S1_OCB11S1               = (*OCRB11S1  )["OCB11S1"   ];
        return;
    }
    if (addr == 0x0054) {
        OCRB12S1_OCB12S1               = (*OCRB12S1  )["OCB12S1"   ];
        return;
    }
    if (addr == 0x0058) {
        ICRB1S1_ICB1S1                 = (*ICRB1S1   )["ICB1S1"    ];
        return;
    }
    if (addr == 0x005C) {
        ICRB2S1_ICB2S1                 = (*ICRB2S1   )["ICB2S1"    ];
        return;
    }
    if (addr == 0x0060) {
        TCNTB0S2_CNTB0S2               = (*TCNTB0S2  )["CNTB0S2"   ];
        return;
    }
    if (addr == 0x0064) {
        ICRB0S2_ICB0S2                 = (*ICRB0S2   )["ICB0S2"    ];
        return;
    }
    if (addr == 0x0068) {
        OCRB0S2_OCB0S2                 = (*OCRB0S2   )["OCB0S2"    ];
        return;
    }
    if (addr == 0x006C) {
        TCNTB1S2_CNTB1S2               = (*TCNTB1S2  )["CNTB1S2"   ];
        return;
    }
    if (addr == 0x006E) {
        OCRB1S2_OCB1S2                 = (*OCRB1S2   )["OCB1S2"    ];
        return;
    }
    if (addr == 0x0070) {
        OCRB10S2_OCB10S2               = (*OCRB10S2  )["OCB10S2"   ];
        return;
    }
    if (addr == 0x0072) {
        OCRB11S2_OCB11S2               = (*OCRB11S2  )["OCB11S2"   ];
        return;
    }
    if (addr == 0x0074) {
        OCRB12S2_OCB12S2               = (*OCRB12S2  )["OCB12S2"   ];
        return;
    }
    if (addr == 0x0078) {
        ICRB1S2_ICRB1S2                = (*ICRB1S2   )["ICRB1S2"   ];
        return;
    }
    if (addr == 0x007C) {
        ICRB2S2_ICRB2S2                = (*ICRB2S2   )["ICRB2S2"   ];
        return;
    }
    if (addr == 0x0080) {
        TCNTB0_CNTB0                   = (*TCNTB0    )["CNTB0"     ];
        return;
    }
    if (addr == 0x0084) {
        ICRB0_ICB0                     = (*ICRB0     )["ICB0"      ];
        return;
    }
    if ((0x0088 <= addr) && (addr <= (0x0088)+(4*5)) && ((addr-0x0088)%4 == 0)) {
        uint i = (addr - 0x0088)/4 + 1;
        RECRB_RECRB                   [i] = (*(RECRB     [i]))["RECRB"     ];
        return;
    }
    if ((0x00A0 <= addr) && (addr <= (0x00A0)+(4*6)) && ((addr-0x00A0)%4 == 0)) {
        uint i = (addr - 0x00A0)/4;
        RBURB_RBURB                   [i] = (*(RBURB     [i]))["RBURB"     ];
        return;
    }
    if (addr == 0x00BC) {
        OCRB0_OCB0                     = (*OCRB0     )["OCB0"      ];
        return;
    }
    if (addr == 0x00C0) {
        MIICRB0_ICB0                   = (*MIICRB0   )["ICB0"      ];
        return;
    }
    if (addr == 0x00C4) {
        TCNTB1_CNTB1                   = (*TCNTB1    )["CNTB1"     ];
        return;
    }
    if (addr == 0x00C6) {
        OCRB1_OCB1                     = (*OCRB1     )["OCB1"      ];
        return;
    }
    if (addr == 0x00C8) {
        OCRB10_OCB10                   = (*OCRB10    )["OCB10"     ];
        return;
    }
    if (addr == 0x00CA) {
        OCRB11_OCB11                   = (*OCRB11    )["OCB11"     ];
        return;
    }
    if (addr == 0x00CC) {
        OCRB12_OCB12                   = (*OCRB12    )["OCB12"     ];
        return;
    }
    if (addr == 0x00D0) {
        ICRB1_ICB1                     = (*ICRB1     )["ICB1"      ];
        return;
    }
    if (addr == 0x00D4) {
        ICRB2_ICB2                     = (*ICRB2     )["ICB2"      ];
        return;
    }
    if ((0x00D8 <= addr) && (addr <= (0x00D8)+(1*7)) && ((addr-0x00D8)%1 == 0)) {
        uint i = (addr - 0x00D8)/1 + 30;
        ICRB_ICB                      [i] = (*(ICRB      [i]))["ICB"       ];
        return;
    }
    if ((0x00E0 <= addr) && (addr <= (0x00E0)+(1*23)) && ((addr-0x00E0)%1 == 0)) {
        uint i = (addr - 0x00E0)/1 + 20;
        OCRB_OCB                      [i] = (*(OCRB      [i]))["OCB"       ];
        return;
    }
    if (addr == 0x0100) {
        LDB_LDVAL                      = (*LDB       )["LDVAL"     ];
        return;
    }
    if (addr == 0x0104) {
        RLDB_RLDVAL                    = (*RLDB      )["RLDVAL"    ];
        return;
    }
    if (addr == 0x0108) {
        TCNTB2_CNTB2                   = (*TCNTB2    )["CNTB2"     ];
        return;
    }
    if (addr == 0x010C) {
        PIMR1_PIM1                     = (*PIMR1     )["PIM1"      ];
        return;
    }
    if (addr == 0x010E) {
        PIMR2_PIM2                     = (*PIMR2     )["PIM2"      ];
        return;
    }
    if (addr == 0x0110) {
        TCNTB6_CNTB6                   = (*TCNTB6    )["CNTB6"     ];
        return;
    }
    if (addr == 0x0114) {
        ICRB6_ICB6                     = (*ICRB6     )["ICB6"      ];
        return;
    }
    if (addr == 0x0118) {
        RARB6_RARB6                    = (*RARB6     )["RARB6"     ];
        return;
    }
    if (addr == 0x011C) {
        TCNTB6M_CNTB6M                 = (*TCNTB6M   )["CNTB6M"    ];
        return;
    }
    if (addr == 0x0120) {
        OCRB6_OCB6                     = (*OCRB6     )["OCB6"      ];
        return;
    }
    if (addr == 0x0124) {
        OCRB7_OCB7                     = (*OCRB7     )["OCB7"      ];
        return;
    }
    if (addr == 0x0140) {
        TSEQCRB_EVSEQENB               = (*TSEQCRB   )["EVSEQENB"  ];
        return;
    }
    if (addr == 0x0142) {
        TSEQRB_SEQB                    = (*TSEQRB    )["SEQB"      ];
        TSEQRB_FONS                    = (*TSEQRB    )["FONS"      ];
        return;
    }
    if ((0x0144 <= addr) && (addr <= (0x0144)+(1*2)) && ((addr-0x0144)%1 == 0)) {
        uint i = (addr - 0x0144)/1;
        TSEQENB_TSEQNENB              [i] = (*(TSEQENB   [i]))["TSEQNENB"  ];
        return;
    }
    if ((0x0148 <= addr) && (addr <= (0x0148)+(2*23)) && ((addr-0x0148)%2 == 0)) {
        uint i = (addr - 0x0148)/2;
        TEPCFB_CRFIT2                 [i] = (*(TEPCFB    [i]))["CRFIT2"    ];
        TEPCFB_CRFIT1                 [i] = (*(TEPCFB    [i]))["CRFIT1"    ];
        TEPCFB_COEFF                  [i] = (*(TEPCFB    [i]))["COEFF"     ];
        TEPCFB_HALFEN                 [i] = (*(TEPCFB    [i]))["HALFEN"    ];
        return;
    }
    if ((0x0178 <= addr) && (addr <= (0x0178)+(1*2)) && ((addr-0x0178)%1 == 0)) {
        uint i = (addr - 0x0178)/1;
        TEPCFENB_FON                  [i] = (*(TEPCFENB  [i]))["FON"       ];
        return;
    }
    if (addr == 0x0180) {
        TCNTB3_CNTB3                   = (*TCNTB3    )["CNTB3"     ];
        return;
    }
    if (addr == 0x0184) {
        TCNTB4_CNTB4                   = (*TCNTB4    )["CNTB4"     ];
        return;
    }
    if (addr == 0x0188) {
        TCNTB5_CNTB5                   = (*TCNTB5    )["CNTB5"     ];
        return;
    }
    if (addr == 0x018C) {
        TCCLFRB_TCCLFB                 = (*TCCLFRB   )["TCCLFB"    ];
        return;
    }
    if (addr == 0x018D) {
        TCCLFSRB_TCCLFSB               = (*TCCLFSRB  )["TCCLFSB"   ];
        return;
    }
    if (addr == 0x018E) {
        TCCLFCRB_TCCLFCB               = (*TCCLFCRB  )["TCCLFCB"   ];
        return;
    }
    if (addr == 0x0190) {
        TCCLRB_CCLRB                   = (*TCCLRB    )["CCLRB"     ];
        return;
    }
    if (addr == 0x0194) {
        OCRB8_OCB8                     = (*OCRB8     )["OCB8"      ];
        return;
    }
    if (addr == 0x01C0) {
        DICRB0_ICB0                    = (*DICRB0    )["ICB0"      ];
        return;
    }
    if (addr == 0x01C4) {
        DRECRB1_RECRB1                 = (*DRECRB1   )["RECRB1"    ];
        return;
    }
    if (addr == 0x01C8) {
        TEPCRECRB1_TEPCRECRB1          = (*TEPCRECRB1)["TEPCRECRB1"];
        return;
    }
    if (addr == 0x01CC) {
        TEPCVALRB0_TEPCVALRB0          = (*TEPCVALRB0)["TEPCVALRB0"];
        return;
    }
}

/// Update local value to bit value
/// @return None
void Catu5010_timerb_regif::UpdateRegVal(cuint addr)
{
    if (addr == 0x0000) {
        (*TCRB      )["CKSELB"    ] = TCRB_CKSELB;
        (*TCRB      )["CLRB1SEL"  ] = TCRB_CLRB1SEL;
        (*TCRB      )["CLRB3SEL"  ] = TCRB_CLRB3SEL;
        (*TCRB      )["CLRB1"     ] = TCRB_CLRB1;
        (*TCRB      )["CLRB3"     ] = TCRB_CLRB3;
        (*TCRB      )["PIMRSEL"   ] = TCRB_PIMRSEL;
        return;
    }
    if (addr == 0x0002) {
        (*TIORB     )["IOB6"      ] = TIORB_IOB6;
        (*TIORB     )["CCS"       ] = TIORB_CCS;
        (*TIORB     )["LDEN"      ] = TIORB_LDEN;
        (*TIORB     )["EVCNTB"    ] = TIORB_EVCNTB;
        (*TIORB     )["CTCNTB5"   ] = TIORB_CTCNTB5;
        (*TIORB     )["LDSEL"     ] = TIORB_LDSEL;
        return;
    }
    if (addr == 0x0004) {
        (*TSRB      )["CMFB0"     ] = TSRB_CMFB0;
        (*TSRB      )["ICFB0"     ] = TSRB_ICFB0;
        (*TSRB      )["CMFB1"     ] = TSRB_CMFB1;
        (*TSRB      )["CMFB6"     ] = TSRB_CMFB6;
        (*TSRB      )["CMFB10"    ] = TSRB_CMFB10;
        (*TSRB      )["CMFB11"    ] = TSRB_CMFB11;
        (*TSRB      )["CMFB12"    ] = TSRB_CMFB12;
        (*TSRB      )["CMFB6M"    ] = TSRB_CMFB6M;
        (*TSRB      )["CMFB6E"    ] = TSRB_CMFB6E;
        return;
    }
    if (addr == 0x0006) {
        (*TSCRB     )["CMFCB0"    ] = TSCRB_CMFCB0;
        (*TSCRB     )["ICFCB0"    ] = TSCRB_ICFCB0;
        (*TSCRB     )["CMFCB1"    ] = TSCRB_CMFCB1;
        (*TSCRB     )["CMFCB6"    ] = TSCRB_CMFCB6;
        (*TSCRB     )["CMFCB10"   ] = TSCRB_CMFCB10;
        (*TSCRB     )["CMFCB11"   ] = TSCRB_CMFCB11;
        (*TSCRB     )["CMFCB12"   ] = TSCRB_CMFCB12;
        (*TSCRB     )["CMFCB6M"   ] = TSCRB_CMFCB6M;
        (*TSCRB     )["CMFCB6E"   ] = TSCRB_CMFCB6E;
        return;
    }
    if (addr == 0x0008) {
        (*TICRB     )["IREGB6"    ] = TICRB_IREGB6;
        (*TICRB     )["IREGB6E"   ] = TICRB_IREGB6E;
        return;
    }
    if (addr == 0x000A) {
        (*TIERB     )["CMFB0IE"   ] = TIERB_CMFB0IE;
        (*TIERB     )["ICFB0IE"   ] = TIERB_ICFB0IE;
        (*TIERB     )["CMFB1IE"   ] = TIERB_CMFB1IE;
        (*TIERB     )["CMFB6IE"   ] = TIERB_CMFB6IE;
        (*TIERB     )["CMFB10IE"  ] = TIERB_CMFB10IE;
        (*TIERB     )["CMFB11IE"  ] = TIERB_CMFB11IE;
        (*TIERB     )["CMFB12IE"  ] = TIERB_CMFB12IE;
        (*TIERB     )["CMFB6MIE"  ] = TIERB_CMFB6MIE;
        (*TIERB     )["CMFB6EIE"  ] = TIERB_CMFB6EIE;
        return;
    }
    if (addr == 0x000C) {
        (*CHSELBR   )["CHSELB"    ] = CHSELBR_CHSELB;
        return;
    }
    if (addr == 0x000E) {
        (*TCNT4CRB  )["CU4SEL"    ] = TCNT4CRB_CU4SEL;
        return;
    }
    if (addr == 0x0010) {
        (*TCRBS1    )["CLRB1SELS1"] = TCRBS1_CLRB1SELS1;
        (*TCRBS1    )["CLRB1S1"   ] = TCRBS1_CLRB1S1;
        return;
    }
    if (addr == 0x0014) {
        (*TCRBS2    )["CLRB1SELS2"] = TCRBS2_CLRB1SELS2;
        (*TCRBS2    )["CLRB1S2"   ] = TCRBS2_CLRB1S2;
        return;
    }
    if (addr == 0x0040) {
        (*TCNTB0S1  )["CNTB0S1"   ] = TCNTB0S1_CNTB0S1;
        return;
    }
    if (addr == 0x0044) {
        (*ICRB0S1   )["ICB0S1"    ] = ICRB0S1_ICB0S1;
        return;
    }
    if (addr == 0x0048) {
        (*OCRB0S1   )["OCB0S1"    ] = OCRB0S1_OCB0S1;
        return;
    }
    if (addr == 0x004C) {
        (*TCNTB1S1  )["CNTB1S1"   ] = TCNTB1S1_CNTB1S1;
        return;
    }
    if (addr == 0x004E) {
        (*OCRB1S1   )["OCB1S1"    ] = OCRB1S1_OCB1S1;
        return;
    }
    if (addr == 0x0050) {
        (*OCRB10S1  )["OCB10S1"   ] = OCRB10S1_OCB10S1;
        return;
    }
    if (addr == 0x0052) {
        (*OCRB11S1  )["OCB11S1"   ] = OCRB11S1_OCB11S1;
        return;
    }
    if (addr == 0x0054) {
        (*OCRB12S1  )["OCB12S1"   ] = OCRB12S1_OCB12S1;
        return;
    }
    if (addr == 0x0058) {
        (*ICRB1S1   )["ICB1S1"    ] = ICRB1S1_ICB1S1;
        return;
    }
    if (addr == 0x005C) {
        (*ICRB2S1   )["ICB2S1"    ] = ICRB2S1_ICB2S1;
        return;
    }
    if (addr == 0x0060) {
        (*TCNTB0S2  )["CNTB0S2"   ] = TCNTB0S2_CNTB0S2;
        return;
    }
    if (addr == 0x0064) {
        (*ICRB0S2   )["ICB0S2"    ] = ICRB0S2_ICB0S2;
        return;
    }
    if (addr == 0x0068) {
        (*OCRB0S2   )["OCB0S2"    ] = OCRB0S2_OCB0S2;
        return;
    }
    if (addr == 0x006C) {
        (*TCNTB1S2  )["CNTB1S2"   ] = TCNTB1S2_CNTB1S2;
        return;
    }
    if (addr == 0x006E) {
        (*OCRB1S2   )["OCB1S2"    ] = OCRB1S2_OCB1S2;
        return;
    }
    if (addr == 0x0070) {
        (*OCRB10S2  )["OCB10S2"   ] = OCRB10S2_OCB10S2;
        return;
    }
    if (addr == 0x0072) {
        (*OCRB11S2  )["OCB11S2"   ] = OCRB11S2_OCB11S2;
        return;
    }
    if (addr == 0x0074) {
        (*OCRB12S2  )["OCB12S2"   ] = OCRB12S2_OCB12S2;
        return;
    }
    if (addr == 0x0078) {
        (*ICRB1S2   )["ICRB1S2"   ] = ICRB1S2_ICRB1S2;
        return;
    }
    if (addr == 0x007C) {
        (*ICRB2S2   )["ICRB2S2"   ] = ICRB2S2_ICRB2S2;
        return;
    }
    if (addr == 0x0080) {
        (*TCNTB0    )["CNTB0"     ] = TCNTB0_CNTB0;
        return;
    }
    if (addr == 0x0084) {
        (*ICRB0     )["ICB0"      ] = ICRB0_ICB0;
        return;
    }
    if ((0x0088 <= addr) && (addr <= (0x0088)+(4*5)) && ((addr-0x0088)%4 == 0)) {
        uint i = (addr - 0x0088)/4 + 1;
        (*(RECRB     [i]))["RECRB"     ] = RECRB_RECRB[i];
        return;
    }
    if ((0x00A0 <= addr) && (addr <= (0x00A0)+(4*6)) && ((addr-0x00A0)%4 == 0)) {
        uint i = (addr - 0x00A0)/4;
        (*(RBURB     [i]))["RBURB"     ] = RBURB_RBURB[i];
        return;
    }
    if (addr == 0x00BC) {
        (*OCRB0     )["OCB0"      ] = OCRB0_OCB0;
        return;
    }
    if (addr == 0x00C0) {
        (*MIICRB0   )["ICB0"      ] = MIICRB0_ICB0;
        return;
    }
    if (addr == 0x00C4) {
        (*TCNTB1    )["CNTB1"     ] = TCNTB1_CNTB1;
        return;
    }
    if (addr == 0x00C6) {
        (*OCRB1     )["OCB1"      ] = OCRB1_OCB1;
        return;
    }
    if (addr == 0x00C8) {
        (*OCRB10    )["OCB10"     ] = OCRB10_OCB10;
        return;
    }
    if (addr == 0x00CA) {
        (*OCRB11    )["OCB11"     ] = OCRB11_OCB11;
        return;
    }
    if (addr == 0x00CC) {
        (*OCRB12    )["OCB12"     ] = OCRB12_OCB12;
        return;
    }
    if (addr == 0x00D0) {
        (*ICRB1     )["ICB1"      ] = ICRB1_ICB1;
        return;
    }
    if (addr == 0x00D4) {
        (*ICRB2     )["ICB2"      ] = ICRB2_ICB2;
        return;
    }
    if ((0x00D8 <= addr) && (addr <= (0x00D8)+(1*7)) && ((addr-0x00D8)%1 == 0)) {
        uint i = (addr - 0x00D8)/1 + 30;
        (*(ICRB      [i]))["ICB"       ] = ICRB_ICB[i];
        return;
    }
    if ((0x00E0 <= addr) && (addr <= (0x00E0)+(1*23)) && ((addr-0x00E0)%1 == 0)) {
        uint i = (addr - 0x00E0)/1 + 20;
        (*(OCRB      [i]))["OCB"       ] = OCRB_OCB[i];
        return;
    }
    if (addr == 0x0100) {
        (*LDB       )["LDVAL"     ] = LDB_LDVAL;
        return;
    }
    if (addr == 0x0104) {
        (*RLDB      )["RLDVAL"    ] = RLDB_RLDVAL;
        return;
    }
    if (addr == 0x0108) {
        (*TCNTB2    )["CNTB2"     ] = TCNTB2_CNTB2;
        return;
    }
    if (addr == 0x010C) {
        (*PIMR1     )["PIM1"      ] = PIMR1_PIM1;
        return;
    }
    if (addr == 0x010E) {
        (*PIMR2     )["PIM2"      ] = PIMR2_PIM2;
        return;
    }
    if (addr == 0x0110) {
        (*TCNTB6    )["CNTB6"     ] = TCNTB6_CNTB6;
        return;
    }
    if (addr == 0x0114) {
        (*ICRB6     )["ICB6"      ] = ICRB6_ICB6;
        return;
    }
    if (addr == 0x0118) {
        (*RARB6     )["RARB6"     ] = RARB6_RARB6;
        return;
    }
    if (addr == 0x011C) {
        (*TCNTB6M   )["CNTB6M"    ] = TCNTB6M_CNTB6M;
        return;
    }
    if (addr == 0x0120) {
        (*OCRB6     )["OCB6"      ] = OCRB6_OCB6;
        return;
    }
    if (addr == 0x0124) {
        (*OCRB7     )["OCB7"      ] = OCRB7_OCB7;
        return;
    }
    if (addr == 0x0140) {
        (*TSEQCRB   )["EVSEQENB"  ] = TSEQCRB_EVSEQENB;
        return;
    }
    if (addr == 0x0142) {
        (*TSEQRB    )["SEQB"      ] = TSEQRB_SEQB;
        (*TSEQRB    )["FONS"      ] = TSEQRB_FONS;
        return;
    }
    if ((0x0144 <= addr) && (addr <= (0x0144)+(1*2)) && ((addr-0x0144)%1 == 0)) {
        uint i = (addr - 0x0144)/1;
        (*(TSEQENB   [i]))["TSEQNENB"  ] = TSEQENB_TSEQNENB[i];
        return;
    }
    if ((0x0148 <= addr) && (addr <= (0x0148)+(2*23)) && ((addr-0x0148)%2 == 0)) {
        uint i = (addr - 0x0148)/2;
        (*(TEPCFB    [i]))["CRFIT2"    ] = TEPCFB_CRFIT2[i];
        (*(TEPCFB    [i]))["CRFIT1"    ] = TEPCFB_CRFIT1[i];
        (*(TEPCFB    [i]))["COEFF"     ] = TEPCFB_COEFF[i];
        (*(TEPCFB    [i]))["HALFEN"    ] = TEPCFB_HALFEN[i];
        return;
    }
    if ((0x0178 <= addr) && (addr <= (0x0178)+(1*2)) && ((addr-0x0178)%1 == 0)) {
        uint i = (addr - 0x0178)/1;
        (*(TEPCFENB  [i]))["FON"       ] = TEPCFENB_FON[i];
        return;
    }
    if (addr == 0x0180) {
        (*TCNTB3    )["CNTB3"     ] = TCNTB3_CNTB3;
        return;
    }
    if (addr == 0x0184) {
        (*TCNTB4    )["CNTB4"     ] = TCNTB4_CNTB4;
        return;
    }
    if (addr == 0x0188) {
        (*TCNTB5    )["CNTB5"     ] = TCNTB5_CNTB5;
        return;
    }
    if (addr == 0x018C) {
        (*TCCLFRB   )["TCCLFB"    ] = TCCLFRB_TCCLFB;
        return;
    }
    if (addr == 0x018D) {
        (*TCCLFSRB  )["TCCLFSB"   ] = TCCLFSRB_TCCLFSB;
        return;
    }
    if (addr == 0x018E) {
        (*TCCLFCRB  )["TCCLFCB"   ] = TCCLFCRB_TCCLFCB;
        return;
    }
    if (addr == 0x0190) {
        (*TCCLRB    )["CCLRB"     ] = TCCLRB_CCLRB;
        return;
    }
    if (addr == 0x0194) {
        (*OCRB8     )["OCB8"      ] = OCRB8_OCB8;
        return;
    }
    if (addr == 0x01C0) {
        (*DICRB0    )["ICB0"      ] = DICRB0_ICB0;
        return;
    }
    if (addr == 0x01C4) {
        (*DRECRB1   )["RECRB1"    ] = DRECRB1_RECRB1;
        return;
    }
    if (addr == 0x01C8) {
        (*TEPCRECRB1)["TEPCRECRB1"] = TEPCRECRB1_TEPCRECRB1;
        return;
    }
    if (addr == 0x01CC) {
        (*TEPCVALRB0)["TEPCVALRB0"] = TEPCVALRB0_TEPCVALRB0;
        return;
    }
}

/// convert string to vector
/// @return vector
std::vector<std::string> Catu5010_timerb_regif::Str2Vec(std::string str, const char sep)
{
    std::vector<std::string> buf;
    std::string::size_type index = 0;
    for (uint i=0 ; i<str.size() ; i++) {
        if (str[i] == sep) {
            buf.push_back(str.substr(index, i-index));
            index = i+1;
        }
    }
    buf.push_back(str.substr(index));
    return buf;
}

/// Align nuber to hexadecimal format
/// @return aligned number
std::string Catu5010_timerb_regif::Num2HexStr(cuint num, cuint num_length, bool space_strip)
{
    std::ostringstream str_tmp;
    #ifdef MSG_WO_WR_DATA
    str_tmp<<"0x"<<std::hex<<std::uppercase<<std::right<<num;
    str_tmp<<std::setfill(' ')<<std::setw(10-str_tmp.str().length())<<"";
    #else
    uint total_length = (num_length + 3)/4; // Calculate number of hexadecimal number
    str_tmp<<"0x"<<std::setfill('0')<<std::setw(total_length)<<std::hex<<std::uppercase<<std::right<<num;
    if (!space_strip) {
        str_tmp<<std::setfill(' ')<<std::setw(10-str_tmp.str().length())<<"";   
    }
    #endif
    return str_tmp.str();
}

/// Dump register access information
/// @return none
void Catu5010_timerb_regif::DumpRegMsg(const std::string operation, const std::string RegName, const std::string BitName, cuint size, cuint addr, cuint wr_data, cuint pre_data, cuint data, cuint reg_length)
{
    if(mDumpRegisterRW == true) {
        std::string reg_name = RegName;
        std::ostringstream str_tmp;
        if (BitName != "") {
            reg_name += ":" + BitName;
        }
        str_tmp<<"REG ["<<std::setw(15)<<std::left<<reg_name<<"] ";
        str_tmp<<operation;
        str_tmp<<" Size= "<<size;
        str_tmp<<" Addr= "<<Num2HexStr(addr,9, false);
        if (operation == "R") {
            str_tmp<<" Data= "<<Num2HexStr(data    , reg_length, true);
        } else {
            #ifdef MSG_WO_WR_DATA
            str_tmp<<" Data= "<<Num2HexStr(pre_data, reg_length, false);
            #else
            str_tmp<<" Data= "<<Num2HexStr(wr_data , reg_length, false);
            str_tmp<<" : "    <<Num2HexStr(pre_data, reg_length, false);
            #endif
            str_tmp<<" => "   <<Num2HexStr(data    , reg_length, true);
        }
        re_printf("DumpRegMsg", "%s\n", str_tmp.str().c_str());
    }
}

/// find register pointer based on accessed address
/// @return accessed register pointer
int Catu5010_timerb_regif::get_reg_index(cuint access_addr)
{
    if (mRegMap[access_addr] != (1<<9)) {
        return mRegMap[access_addr];
    } else {
        return -1;
    }
}

/// find first register pointer
/// @return first register pointer
vpcl::re_register *Catu5010_timerb_regif::first_reg_object()
{
    mCurReg = mRegList;
    return mCurReg->my_p;
}

/// find next register pointer
/// @return next register pointer
vpcl::re_register *Catu5010_timerb_regif::next_reg_object()
{
    if (mCurReg != NULL) {
        mCurReg = mCurReg->prev;
        if (mCurReg != NULL) {
            return mCurReg->my_p;
        }
    }
    return NULL;
}

/// write callback function of CoWare
/// @return none
void Catu5010_timerb_regif::wr_cb(cuint addr, uint data)
{
    #ifdef CWR_SYSTEMC
    cwmem.put(data, addr&0xFFFF);
    #else
    array[addr&0xFFFF] = data;
    #endif
}

/// read callback function of CoWare
/// @return read data
Catu5010_timerb_regif::uint Catu5010_timerb_regif::rd_cb(cuint addr)
{
    #ifdef CWR_SYSTEMC
    return cwmem.get(addr&0xFFFF);
    #else
    return array[addr&0xFFFF];
    #endif
}

/// print message function
/// @return none
void Catu5010_timerb_regif::_re_printf(std::string group, const char *message, ...)
{
    // message group check
    if (group == "DumpRegMsg") {
        group = "info";
    } else {
        #ifndef REGIF_SC_REPORT
        if (mMessageLevel[group] == false) return;
        #endif//REGIF_SC_REPORT
    }

    if (message == NULL) return;

    // print header
    #ifndef REGIF_NOT_USE_SYSTEMC
    std::stringstream t_stream;
    std::string cur_time;

    double tu_value = 0;
    std::string tu_name = "";
    if (sc_get_time_resolution() < sc_time(1, SC_PS)) {
        tu_value = 1000000000000000LL;
        tu_name = " fs";
    }
    else if (sc_get_time_resolution() < sc_time(1, SC_NS)) {
        tu_value = 1000000000000LL;
        tu_name = " ps";
    }
    else if (sc_get_time_resolution() < sc_time(1, SC_US)) {
        tu_value = 1000000000;
        tu_name = " ns";
    }
    else if (sc_get_time_resolution() < sc_time(1, SC_MS)) {
        tu_value = 1000000;
        tu_name = " us";
    }
    else if (sc_get_time_resolution() < sc_time(1, SC_SEC)) {
        tu_value = 1000;
        tu_name = " ms";
    }
    else {
        tu_value = 1;
        tu_name = " s";
    }
    t_stream << sc_time_stamp().value() * (uint64) (sc_get_time_resolution().to_seconds() * tu_value) << tu_name;

    cur_time = t_stream.str();
    #else
    std::string cur_time = "";
    #endif

    #ifndef REGIF_SC_REPORT
    #ifdef MSG_COLOR
    // color setting
    //
    // severity color       color Linux       Windows
    // fatal    RED         RED   \033[0;31m  FOREGROUND_RED
    // error    RED         BLUE  \033[0;34m  FOREGROUND_BLUE
    // warning  RED
    // info     BLUE
    #ifdef _WIN32
    HANDLE hStdout;
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    if (group == "fatal" || group == "error" || group == "warning") {
        SetConsoleTextAttribute(hStdout, FOREGROUND_RED);
    }
    else if (group == "info" ){
        SetConsoleTextAttribute(hStdout, FOREGROUND_BLUE);
    }
    #else
    if (group == "fatal" || group == "error" || group == "warning") {
        printf("\033[0;31m");
    }
    else if (group == "info" ){
        printf("\033[0;34m");
    }
    #endif
    #endif //MSG_COLOR
    printf("%8s [%20s] (%10s) ", group.c_str(), cur_time.c_str(), mInstName.c_str());
    #endif//REGIF_SC_REPORT

    // print body
    va_list argptr;
    va_start(argptr, message);
    if (argptr == NULL) return;
    #ifdef REGIF_SC_REPORT
    char str[1024];
    sprintf(str, "[%20s] ", cur_time.c_str());
    vsprintf(str+23, message, argptr);
    if (group == "fatal") {
        SC_REPORT_FATAL(mInstName.c_str(), str);
    }
    else if (group == "error") {
        SC_REPORT_ERROR(mInstName.c_str(), str);
    }
    else if (group == "warning") {
        SC_REPORT_WARNING(mInstName.c_str(), str);
    }
    else if (group == "info") {
        SC_REPORT_INFO(mInstName.c_str(), str);
    }
    #else //REGIF_SC_REPORT
    vprintf(message, argptr);
    #endif//REGIF_SC_REPORT

    #ifndef REGIF_SC_REPORT
    #ifdef DumpFileNameLineNum
    // print footer
    if (group == "fatal" || group == "error") {
        printf(" [%s:%d]\n", mFileName.c_str(), mLineNum);
    }
    #endif//DumpFileNameLineNum
    #endif//REGIF_SC_REPORT
    va_end(argptr);

    #ifndef REGIF_SC_REPORT
    #ifdef MSG_COLOR
    #ifdef _WIN32
    SetConsoleTextAttribute(hStdout, csbi.wAttributes);
    #else
    printf("\033[m");
    #endif
    #endif //MSG_COLOR
    #endif//REGIF_SC_REPORT

    fflush(stdout);
    fflush(stderr);

    if (group == "fatal") {
        exit(1);
    }
}

/// Get file name and line number
/// @return none
void Catu5010_timerb_regif::get_fileline(std::string filename, int line_number)
{
    mFileName = filename;
    mLineNum  = line_number;
}

/// API for instance registration
/// @return none
void Catu5010_timerb_regif::set_instance_name(std::string InstName)
{
    mInstName = InstName;
}

/// Method to change value of mIsReset
/// @return none
void Catu5010_timerb_regif::EnableReset(const bool is_active)
{
    // update register IF class's reset status
    mIsReset = is_active;

    // update re_register's reset status
    for (uint i = 0; i < mTotalRegNum; i++) {
        mRegArray[i]->my_p->EnableReset(is_active);
        if (is_active) {
            re_printf("info", "Initialize %s (%08x)\n", mRegArray[i]->my_p->name().c_str(), (uint)(*mRegArray[i]->my_p));
        }
    }

    if(is_active) {
        InitLocalVal(); // Initialize local variable
    }
}

#ifdef CWR_SYSTEMC
uint Catu5010_timerb_regif::cw_rd_cb(tlm::tlm_generic_payload& trans, int tag)
{
    unsigned char* ptr = (unsigned char*)trans.get_data_ptr();
    memset(ptr,0,sizeof(uint));
    reg_rd_dbg((cuint)tag, ptr, sizeof(uint));
    return sizeof(uint);
}

uint Catu5010_timerb_regif::cw_wr_cb(tlm::tlm_generic_payload& trans, int tag)
{
    unsigned char* ptr = (unsigned char*)trans.get_data_ptr();
    reg_wr_dbg((cuint)tag, ptr, sizeof(uint));
    return sizeof(uint);
}
void Catu5010_timerb_regif::cw_instantiate_reg(scml2::reg<uint> * reg, std::string reg_name, int offset)
{
    reg = new scml2::reg<uint>(reg_name, cwmem, offset/sizeof(uint));
    scml2::set_debug_write_callback(*reg,SCML2_CALLBACK(cw_wr_cb),offset);
    scml2::set_debug_read_callback(*reg,SCML2_CALLBACK(cw_rd_cb),offset);
}
#endif
