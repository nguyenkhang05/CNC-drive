// -----------------------------------------------------------------------------
//$Id: poc_cmdif.h,v 1.1.1.1 2012/12/19 03:21:02 lamdangpham Exp $
//
// Copyright(c) 2010-2012 Renesas Electronics Corporation
// RENESAS ELECTRONICS CONFIDENTIAL AND PROPRIETARY.
// This program must be used solely for the purpose for which
// it was furnished by Renesas Electronics Corporation. No part of this
// program may be reproduced or disclosed to others, in any
// form, without the prior written permission of Renesas Electronics
// Corporation.
// -----------------------------------------------------------------------------
// This file is generated by Command I/F generator (ver3.0)
//      $Id: poc_cmdif.h,v 1.1.1.1 2012/12/19 03:21:02 lamdangpham Exp $
//      $Id: poc_cmdif.h,v 1.1.1.1 2012/12/19 03:21:02 lamdangpham Exp $
//      $Id: modelinfo_parser.py,v 1.2 2011/03/17 05:08:51 sontran Exp
//
//
// Input file contents
//
//%MODULE poc
// 
//%CMD_NODUMP_API DumpProfile ClearProfile
//%CMD_RW DumpInterrupt      <enable: bool=false>             @ Display interrupt information when interrupt get set[ns]
//%CMD_RW EnableVoltageInfo  <enable: bool=false>             @ Enable/Disable displaying voltage level information
//
//%CMD_RW VCC                <VCC:double=5>                   @ The voltage level of VCC
//%CMD_RW VCCA               <VCCA:double=5>                  @ The voltage level of VCCA
//
//%CMD_RW RefPOCA            <RefPOCA: double=2.8>             @ The reference voltage level of POCA
//%CMD_RW RefCMPL            <RefCMPL: double=2.8>             @ The reference voltage level of CMPL
//%CMD_RW RefPOCB            <RefPOCB: double=2.8>             @ The reference voltage level of POCB
//
//%CMD_RW POCOFFMODE         <POCOFFMODE: bool=false>         @ Select POC off mode
//%CMD_RW SELDETMODE         <SELDET1MODE: bool=true>         @ Select DET mode
//%CMD_RW Tpora              <Tpora: unsigned int=1000>       @ Latency time from detecting VCC level to outputting poradet_n_v50
//%CMD_RW Tpoca              <Tpoca: unsigned int=1500>       @ Latency time from receiving poradet_n_v50 to outputting pocadet_n_v50
//%CMD_RW Tcmpl              <Tcmpl: unsigned int=1000>       @ Latency time from detecting VCC level to updating pocdet_n_v50
//%CMD_RW Tpocb              <Tpocb: unsigned int=1000>       @ Latency time from detecting VCCA level to outputting det0det_v50
//
//%CMD_ACTION DumpStatInfo : void @ Dump the statistical information about voltage level detecting activity
//%CMD_ACTION SetCLKfreq <clk_name: std::string> <frequency: double>: void @ Setup the new clock frequency

#ifndef POC_CMDIF_H
#define POC_CMDIF_H

public:
std::string handleCommand (const std::vector<std::string>& args)
{
  std::vector<std::string> _args = args;
  std::string ret = "";

  if (args[0] == "command") {
    _args.erase(_args.begin());
    ret = this->own_handle_command(_args);
    if (ret != "") {
      ret += "\n";
    }
#if 1 // CommandCB
    // call call back funcion only when return message does not include error keyword
    if (ret.find("is invalid") == std::string::npos    // defined command
     && ret.find("Error") == std::string::npos) {      // correct argument
      std::string cb_msg = this->CommandCB(args);
      if (cb_msg.find("error") != std::string::npos) { // correct usage
        ret += cb_msg + "\n";
      }
    }
#endif // CommandCB
  }

  // send a command to all targets
  else {
    bool cmd_found = false;
    std::string baseid_message;

    baseid_message = this->own_handle_command(_args);
    if (baseid_message.find("is invalid", 0) == std::string::npos) { // defined command
      cmd_found = true;
      if (baseid_message != "") {
        ret += baseid_message + "\n";
      }
#if 1 // CommandCB
      // call call back funcion only when return message does not include error keyword
    if (ret.find("is invalid") == std::string::npos      // defined command
     && ret.find("Error") == std::string::npos) {        // correct argument
        std::string cb_msg = this->CommandCB(args);
        if (cb_msg.find("error") != std::string::npos) { // correct usage
          ret += cb_msg + "\n";
        }
      }
#endif // CommandCB
    }

    if (!cmd_found) {
      ret = "Error (" + mInstName + ") command name \"" + _args[0] + "\" is invalid.\n";
    }
  }
  
  // Insert input command
#if 1 // EnableInsertInput
  if (mEnableInsertInput) {
    std::string header_str = "(" + mInstName + + ":" + mCmdId + ") [ ";
    for (unsigned int i=0 ; i<args.size() ; i++) {
      header_str += (std::string)args[i] + " ";
    }
    header_str += "]";
    ret = header_str + "\n" + ret;
  }
#endif // EnableInsertInput

#if 1 // EnableDumpResult
  if (mEnableDumpResult && mCmdId == "self") {
    printf("%s", ret.c_str());
  }
#endif // EnableDumpResult
  return ret;
}

#if 0 // HWBreak
void setCommandHandler(vpcl::commandHandler * handler) {
  if (handler == NULL) return;
  cmd_handler = handler;
}
void hw_break(std::string break_name) {
  // if specified break point is enable, have commandHandler read a script file
  if (mBreakTable.find(break_name) != mBreakTable.end()) {
    cmd_handler->handleCommand();
  }
}
#endif // HWBreak

private:
std::string own_handle_command(std::vector<std::string>& args)
{
  std::string ret = "";
  std::string err_msg = "Error ("   + mInstName + ") ";   // error message

  std::string specified_cmd = " (";
  std::vector<std::string>::iterator cmd_it;
  for (cmd_it=args.begin() ; cmd_it!=args.end() ; cmd_it++) {
    specified_cmd += " " + *cmd_it;
  }
  specified_cmd += " ) : Type " + mInstName + " help";

  if (args[0] == "help") {
    ret += "    --- command ---\n";
    ret += "    help                                      Show direction\n";
#if 0 // HWBreak
    ret += "    go                                        (Re)Start the simulation\n";
    ret += "    HWBreak <break-name>                      Enable specified break point (Defailt: none)\n";
#endif // HWBreak
#if 1 // MessageLevel
    ret += "    MessageLevel   <fatal|error|warning|info> Select debug message level (Default: fatal,error)\n";
#endif // MessageLevel
#if 1 // EnableInsertInput
    ret += "    EnableInsertInput <true/false>            Display typed command (Default: false)\n";
#endif // EnableInsertInput
#if 0 // DumpProfile
    ret += "    DumpProfile [file_name] [time_unit]       Dump profile information (Default: file_name=stdout, time_unit=SC_NS)\n";
#endif // DumpProfile
#if 0 // ClearProfile
    ret += "    ClearProfile                              Reset profile internal information\n";
#endif // ClearProfile
#if 1 // AssertReset
    ret += "    AssertReset <start_time> <period>         Assert and deassert reset signal to a target model\n";
#endif // AssertReset
#if 1 // EnableDumpResult
    ret += "    EnableDumpResult <status>                 Dump a command return string into standard output too\n";
#endif // EnableDumpResult
    ret += "    DumpInterrupt <arg>                       Display interrupt information when interrupt get set[ns] ( Default:false  )\n";
    ret += "    EnableVoltageInfo <arg>                   Enable/Disable displaying voltage level information ( Default:false  )\n";
    ret += "    VCC <arg>                                 The voltage level of VCC ( Default:5  )\n";
    ret += "    VCCA <arg>                                The voltage level of VCCA ( Default:5  )\n";
    ret += "    RefPOCA <arg>                             The reference voltage level of POCA ( Default:2.8  )\n";
    ret += "    RefCMPL <arg>                             The reference voltage level of CMPL ( Default:2.8  )\n";
    ret += "    RefPOCB <arg>                             The reference voltage level of POCB ( Default:2.8  )\n";
    ret += "    POCOFFMODE <arg>                          Select POC off mode ( Default:false  )\n";
    ret += "    SELDETMODE <arg>                          Select DET mode ( Default:true  )\n";
    ret += "    Tpora <arg>                               Latency time from detecting VCC level to outputting poradet_n_v50 ( Default:1000  )\n";
    ret += "    Tpoca <arg>                               Latency time from receiving poradet_n_v50 to outputting pocadet_n_v50 ( Default:1500  )\n";
    ret += "    Tcmpl <arg>                               Latency time from detecting VCC level to updating pocdet_n_v50 ( Default:1000  )\n";
    ret += "    Tpocb <arg>                               Latency time from detecting VCCA level to outputting det0det_v50 ( Default:1000  )\n";
    ret += "    DumpStatInfo                              Dump the statistical information about voltage level detecting activity\n";
    ret += "    SetCLKfreq <clk_name> <frequency>         Setup the new clock frequency\n";

  }
#if 1 // MessageLevel
  else if (args[0] == "MessageLevel") {
    // read mode
    if ((int)args.size() == 1) {
      std::map<std::string, bool>::iterator it;
      for (it = mMessageLevel.begin(); it != mMessageLevel.end(); it++) {
        if (it->second) {
          ret += " " + it->first;
        }
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      // update to new setting
      mMessageLevel.clear();

      std::vector<std::string> arg_vec = str2vec(args[1], '|');
      std::vector<std::string>::iterator it;
      for (it = arg_vec.begin(); it != arg_vec.end(); it++) {
        mMessageLevel[*it] = true;
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
#endif // MessageLevel
#if 0 // HWBreak
  else if (args[0] == "go") {
    if ((int)args.size() == 1) {
      cmd_handler->setContinue();
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "HWBreak") {
    // read mode
    if ((int)args.size() == 1) {
      std::map<std::string, bool>::iterator it;
      for (it = mBreakTable.begin(); it != mBreakTable.end(); it++) {
        if (it->second) {
          ret += " " + it->first;
        }
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      // update to new setting
      mBreakTable.clear();
      std::vector<std::string> arg_vec = str2vec(args[1], '|');
      std::vector<std::string>::iterator it;
      for (it = arg_vec.begin(); it != arg_vec.end(); it++) {
        mBreakTable[*it] = true;
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
#endif // HWBreak
#if 1 // EnableInsertInput
  else if (args[0] == "EnableInsertInput") {
    // read mode
    if ((int)args.size() == 1) {
      if (mEnableInsertInput) {
        ret = "true";
      }
      else if (!mEnableInsertInput) {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      if (args[1] == "true") {
        mEnableInsertInput = true;
      }
      else if (args[1] == "false") {
        mEnableInsertInput = false;
      }
      else {
        ret = err_msg + "wrong argument" + specified_cmd;
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
#endif // EnableInsertInput
#if 0 // DumpProfile
  else if (args[0] == "DumpProfile") {
    if ((int)args.size() >= 4) {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
      return ret;
    }
  
    sc_time_unit time_unit = SC_NS;
    if ((int)args.size() >= 3) {
           if (args[2] == "SC_SEC") time_unit = SC_SEC;
      else if (args[2] == "SC_MS" ) time_unit = SC_MS;
      else if (args[2] == "SC_US" ) time_unit = SC_US;
      else if (args[2] == "SC_NS" ) time_unit = SC_NS;
      else if (args[2] == "SC_PS" ) time_unit = SC_PS;
      else if (args[2] == "SC_FS" ) time_unit = SC_FS;
      else {
        ret = err_msg + "wrong argument" + specified_cmd;
        return ret;
      }
    }
  
    FILE *fp = stdout;
    if ((int)args.size() >= 2) {
#ifdef __RE_SEQURITY_H
      if (fopen_s( &fp, args[1].c_str(), "a" ) != 0 )
#else
      fp = fopen(args[1].c_str(), "a");
      if (fp == NULL)
#endif
      {
        ret = "Cannot dump profile to " + (std::string)args[1];
        return ret;
      }
    }
  
    DumpProfile(fp, time_unit); // not check return value
    if (fp != stdout && fp != NULL) {
      fclose(fp);
    }
  }
#endif // DumpProfile
#if 0 // ClearProfile
  else if (args[0] == "ClearProfile") {
    if ((int)args.size() == 1) {
      ClearProfile();
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
#endif // ClearProfile
#if 1 // AssertReset
  else if (args[0] == "AssertReset") {
    if ((int)args.size() == 3) {
      double start_time, period;
      bool IsTranslateCorrect = true;
      std::istringstream str_start_time(args[1]);
      std::istringstream str_period    (args[2]);

      str_start_time >> start_time;
      if (((unsigned int)str_start_time.rdstate() & (unsigned int)std::istringstream::failbit) != 0) {
        IsTranslateCorrect = false;
      }
      
      str_period >> period;
      if (((unsigned int)str_period.rdstate() & (unsigned int)std::istringstream::failbit) != 0) {
        IsTranslateCorrect = false;
      }

      if (start_time < 0 || period <= 0) {
        IsTranslateCorrect = false;
      }

      if (IsTranslateCorrect) {
        AssertReset(start_time, period);
      }
      else {
        ret = err_msg + "wrong argument: " + args[1] + " " + args[2]
            + specified_cmd;
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
#endif // AssertReset
#if 1 // EnableDumpResult
  else if (args[0] == "EnableDumpResult") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      if (mEnableDumpResult) {
        ret = "true";
      }
      else {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      if (args[1] == "true") {
        mEnableDumpResult = true;
      }
      else if (args[1] == "false") {
        mEnableDumpResult = false;
      }
      else {
        ret = err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
#endif // EnableDumpResult
  else  {
    ret = user_def_command(args);
  }

  return ret;
}

std::string user_def_command(std::vector<std::string>& args)
{
  std::string ret = "";
  std::string err_msg = "Error ("   + mInstName + ") ";   // error message

  std::string specified_cmd = " (";
  std::vector<std::string>::iterator cmd_it;
  for (cmd_it=args.begin() ; cmd_it!=args.end() ; cmd_it++) {
    specified_cmd += " " + *cmd_it;
  }
  specified_cmd += " ) : Type " + mInstName + " help";

  if (0) {}
  else if (args[0] == "DumpInterrupt") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      if (DumpInterrupt) {
        ret = "true";
      }
      else {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      if (args[1] == "true") {
        DumpInterrupt = true;
      }
      else if (args[1] == "false") {
        DumpInterrupt = false;
      }
      else {
        ret = err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "EnableVoltageInfo") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      if (EnableVoltageInfo) {
        ret = "true";
      }
      else {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      if (args[1] == "true") {
        EnableVoltageInfo = true;
      }
      else if (args[1] == "false") {
        EnableVoltageInfo = false;
      }
      else {
        ret = err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "VCC") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      std::ostringstream stream;
      stream << VCC;
      ret = stream.str();
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        std::istringstream is(args[1]);
        double backup = VCC;
        is >> VCC;
        
        if (is.fail() || !is.eof()) {
          VCC = backup;
          ret += err_msg + "wrong argument: " + args[1] + specified_cmd;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "VCCA") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      std::ostringstream stream;
      stream << VCCA;
      ret = stream.str();
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        std::istringstream is(args[1]);
        double backup = VCCA;
        is >> VCCA;
        
        if (is.fail() || !is.eof()) {
          VCCA = backup;
          ret += err_msg + "wrong argument: " + args[1] + specified_cmd;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "RefPOCA") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      std::ostringstream stream;
      stream << RefPOCA;
      ret = stream.str();
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        std::istringstream is(args[1]);
        double backup = RefPOCA;
        is >> RefPOCA;
        
        if (is.fail() || !is.eof()) {
          RefPOCA = backup;
          ret += err_msg + "wrong argument: " + args[1] + specified_cmd;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "RefCMPL") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      std::ostringstream stream;
      stream << RefCMPL;
      ret = stream.str();
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        std::istringstream is(args[1]);
        double backup = RefCMPL;
        is >> RefCMPL;
        
        if (is.fail() || !is.eof()) {
          RefCMPL = backup;
          ret += err_msg + "wrong argument: " + args[1] + specified_cmd;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "RefPOCB") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      std::ostringstream stream;
      stream << RefPOCB;
      ret = stream.str();
    }
    // write mode
    else if ((int)args.size() == 2) {
      {
        std::istringstream is(args[1]);
        double backup = RefPOCB;
        is >> RefPOCB;
        
        if (is.fail() || !is.eof()) {
          RefPOCB = backup;
          ret += err_msg + "wrong argument: " + args[1] + specified_cmd;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "POCOFFMODE") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      if (POCOFFMODE) {
        ret = "true";
      }
      else {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      if (args[1] == "true") {
        POCOFFMODE = true;
      }
      else if (args[1] == "false") {
        POCOFFMODE = false;
      }
      else {
        ret = err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "SELDETMODE") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      if (SELDETMODE) {
        ret = "true";
      }
      else {
        ret = "false";
      }
    }
    // write mode
    else if ((int)args.size() == 2) {
      if (args[1] == "true") {
        SELDETMODE = true;
      }
      else if (args[1] == "false") {
        SELDETMODE = false;
      }
      else {
        ret = err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "Tpora") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      std::ostringstream stream;
      stream << Tpora;
      ret = stream.str();
    }
    // write mode
    else if ((int)args.size() == 2) {
      if (args[1].substr(0, 1) == "-") {
          ret += err_msg + "wrong value: " + (std::string)args[1] + specified_cmd;
      }
      else {
        std::istringstream is(args[1]);
        unsigned int backup = Tpora;
        if (args[1].substr(0, 2) == "0x") {
            is >> std::hex >> Tpora;
        }
        else if (args[1].substr(0, 1) == "0") {
            is >> std::oct >> Tpora;
        }
        else {
            is >> std::dec >> Tpora;
        }
        if (is.fail() || !is.eof()) {
          Tpora = backup;
          ret += err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "Tpoca") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      std::ostringstream stream;
      stream << Tpoca;
      ret = stream.str();
    }
    // write mode
    else if ((int)args.size() == 2) {
      if (args[1].substr(0, 1) == "-") {
          ret += err_msg + "wrong value: " + (std::string)args[1] + specified_cmd;
      }
      else {
        std::istringstream is(args[1]);
        unsigned int backup = Tpoca;
        if (args[1].substr(0, 2) == "0x") {
            is >> std::hex >> Tpoca;
        }
        else if (args[1].substr(0, 1) == "0") {
            is >> std::oct >> Tpoca;
        }
        else {
            is >> std::dec >> Tpoca;
        }
        if (is.fail() || !is.eof()) {
          Tpoca = backup;
          ret += err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "Tcmpl") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      std::ostringstream stream;
      stream << Tcmpl;
      ret = stream.str();
    }
    // write mode
    else if ((int)args.size() == 2) {
      if (args[1].substr(0, 1) == "-") {
          ret += err_msg + "wrong value: " + (std::string)args[1] + specified_cmd;
      }
      else {
        std::istringstream is(args[1]);
        unsigned int backup = Tcmpl;
        if (args[1].substr(0, 2) == "0x") {
            is >> std::hex >> Tcmpl;
        }
        else if (args[1].substr(0, 1) == "0") {
            is >> std::oct >> Tcmpl;
        }
        else {
            is >> std::dec >> Tcmpl;
        }
        if (is.fail() || !is.eof()) {
          Tcmpl = backup;
          ret += err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "Tpocb") {
    // read mode
    if (0) {;}
    else if ((int)args.size() == 1) {
      std::ostringstream stream;
      stream << Tpocb;
      ret = stream.str();
    }
    // write mode
    else if ((int)args.size() == 2) {
      if (args[1].substr(0, 1) == "-") {
          ret += err_msg + "wrong value: " + (std::string)args[1] + specified_cmd;
      }
      else {
        std::istringstream is(args[1]);
        unsigned int backup = Tpocb;
        if (args[1].substr(0, 2) == "0x") {
            is >> std::hex >> Tpocb;
        }
        else if (args[1].substr(0, 1) == "0") {
            is >> std::oct >> Tpocb;
        }
        else {
            is >> std::dec >> Tpocb;
        }
        if (is.fail() || !is.eof()) {
          Tpocb = backup;
          ret += err_msg + "wrong argument: " + (std::string)args[1] + specified_cmd;
        }
      }
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "DumpStatInfo") {
    if ((int)args.size() > 0 && (int)args.size() <= 1) {
      DumpStatInfo();
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }
  else if (args[0] == "SetCLKfreq") {
    if ((int)args.size() > 2 && (int)args.size() <= 3) {
      std::string clk_name;
      if ((int)args.size() >= 2) {
        clk_name = (std::string)args[1];
      }
      double frequency;
      if ((int)args.size() >= 3) {
        if (args[2][0] == '-') {
          ret = err_msg + "wrong argument" + specified_cmd;
          return ret;
        }
        if (!str2dbl(args[2], frequency)) {
          ret = err_msg + "wrong argument" + specified_cmd;
          return ret;
        }
      }
      SetCLKfreq(clk_name, frequency);
    }
    else {
      ret = err_msg + "wrong number of arguments" + specified_cmd;
    }
  }

  else {
    ret = err_msg + "command name \"command " + (std::string)args[0] + "\" is invalid.";
  }

  return ret;
}

#if 0 // reg
std::string regif_handle_command(std::vector<std::string>& args)
{
  std::string ret = "";
  std::string err_msg = "Error ("   + mInstName + ") ";   // error message

  std::string specified_cmd = " (";
  std::vector<std::string>::iterator cmd_it;
  for (cmd_it=args.begin() ; cmd_it!=args.end() ; cmd_it++) {
    specified_cmd += " " + *cmd_it;
  }
  specified_cmd += " ) : Type " + mInstName + " help";

  // dump register list
  if ((int)args.size() == 1) {
    vpcl::re_register *reg_p = first_reg_object();
    while (reg_p != NULL) {
      printf("%s\n", reg_p->name().c_str());
      reg_p = next_reg_object();
    }
  }
  else {
    bool reg_found = false;
    vpcl::re_register *reg_p = first_reg_object();
    std::vector<std::string> args_updated;
    std::copy( args.begin(), args.end(), back_inserter( args_updated ) );
    while (reg_p != NULL) {
      if (strmatch(args[1].c_str(), reg_p->name().c_str())) {
        reg_found = true;
        args_updated[1] = reg_p->name();
        ret += this->reg_handle_command(args_updated) + "\n";
      }
      reg_p = next_reg_object();
    }
    if (!reg_found) {
      ret = this->reg_handle_command(args_updated);
    }
  }

  return ret;
}
#endif

#if 0 // port
#define PORT_READ_WRITE(port_name, port_val)                                     \
        if (port_obj != NULL) {                                                  \
          if ((int)args.size() == 1) {                                           \
            find_success = true;                                                 \
            printf("%-10s %s = %d\n", mInstName.c_str(), #port_name, port_val);  \
          }                                                                      \
          else if ((int)args.size() == 2) {                                      \
            unsigned int write_val;                                              \
            if (str2num(args[1], write_val)) {                                   \
              find_success = true;                                               \
              port_obj->write(write_val);                                        \
            }                                                                    \
            else {                                                               \
              ret = err_msg + args.at(1) + " is wrong argument" + specified_cmd; \
            }                                                                    \
          }                                                                      \
        }                                                                        \

#define PORT_READ(port_name, port_val)                                           \
        if (port_obj != NULL) {                                                  \
          if ((int)args.size() == 1) {                                           \
            find_success = true;                                                 \
            printf("%-10s %s = %d\n", mInstName.c_str(), #port_name, port_val);  \
          }                                                                      \
        }

std::string port_handle_command(std::vector<std::string> args)
{
  std::string ret = "";
  std::string err_msg = "Error ("   + mInstName + ") ";   // error message

  std::string specified_cmd = " (";
  std::vector<std::string>::iterator cmd_it;
  for (cmd_it=args.begin() ; cmd_it!=args.end() ; cmd_it++) {
    specified_cmd += " " + *cmd_it;
  }
  specified_cmd += " ) : Type " + mInstName + " help";

  // dump all port information
  if ((int)args.size() == 0) {
    std::vector<sc_object *> child_obj = get_child_objects();
    std::vector<sc_object *>::iterator it;

    for (it=child_obj.begin() ; it!=child_obj.end() ; it++) {
      std::string target = (*it)->name();
      if (target.find(mInstName) != std::string::npos
       && (!strcmp((*it)->kind(), "sc_in") || !strcmp((*it)->kind(), "sc_out"))) {
        printf("%-10s <sc_out> %s\n", mInstName.c_str(), (*it)->basename());
      }
    }
  }

  // Dump help message
  else if (args[0] == "help") {
    ret += "    --- port ---\n";
    ret += "    <port> <value>                     Set value to <port> output port\n";
  }

  // port write / read
  else if ((int)args.size() == 1 || (int)args.size() == 2) {
    std::vector<sc_object *> child_obj = get_child_objects();
    std::vector<sc_object *>::iterator it;
    bool find_success = false;

    for (it=child_obj.begin() ; it!=child_obj.end() ; it++) {
      std::string obj_name = (*it)->name();
      std::string arg_name = mInstName + "." + (std::string)args[0];
      if (strmatch(arg_name.c_str(), obj_name.c_str())) {

      }
    }

    if (!find_success) {
      ret = err_msg + "is invalid command name";
    }
  }
  else {
    ret = err_msg + "The argument number of " + args.at(0) + " is invalid" + specified_cmd;
  }

  return ret;
}
#undef PORT_READ_WRITE
#undef PORT_READ
#endif // port

template<typename T>
bool str2num(std::string str, T &num)
{
  std::istringstream is(str);
  int tmp;

  if (str.substr(0, 2) == "0x") {
      is >> std::hex >> tmp;
  }
  else if (str.substr(0, 1) == "0") {
      is >> std::oct >> tmp;
  }
  else {
      is >> std::dec >> tmp;
  }

  if (is.fail() || !is.eof()) {
    return false;
  }
  else {
    num = (T)tmp;
    return true;
  }
}

bool str2dbl(std::string str, double &num)
{
  std::istringstream is(str);
  double tmp;

  is >> tmp;

  if (is.fail() || !is.eof()) {
    return false;
  }
  else {
    num = tmp;
    return true;
  }
}

void CommandInit(std::string name = "") {
  // initialize internal variables
  mInstName = name;
  mLineNum = 0;
  mFileName = "";
  mCmdId = "self";

#if 1 // EnableDumpResult
  mEnableDumpResult = false;
#endif // EnableDumpResult

  // initialize pre-defined command
#if 1 // EnableInsertInput
  mEnableInsertInput = false;
#endif // EnableInsertInput
#if 1 // MessageLevel
  mMessageLevel.insert(std::pair<std::string, bool>("fatal",   true ));
  mMessageLevel.insert(std::pair<std::string, bool>("error",   true ));
  mMessageLevel.insert(std::pair<std::string, bool>("warning", false));
  mMessageLevel.insert(std::pair<std::string, bool>("info",    false));
#endif // MessageLevel
#if 0 // HWBreak
  mBreakTable["none"] = true;
  cmd_handler = NULL;
#endif // HWBreak

  // initialize user define command
  DumpInterrupt = false;
  EnableVoltageInfo = false;
  VCC = 5;
  VCCA = 5;
  RefPOCA = 2.8;
  RefCMPL = 2.8;
  RefPOCB = 2.8;
  POCOFFMODE = false;
  SELDETMODE = true;
  Tpora = 1000;
  Tpoca = 1500;
  Tcmpl = 1000;
  Tpocb = 1000;

}

std::vector<std::string> str2vec(std::string str, const char sep)
{
  std::vector<std::string> buf;
  int index = 0;

  for (int i=0 ; i<(int)str.size() ; i++) {
    if (str[i] == sep) {
      if (i > index) {
        buf.push_back(str.substr((unsigned int)index, (unsigned int)(i-index)));
      }
      index = i+1;
    }
  }
  if (index < (int)str.size()) {
    buf.push_back(str.substr((unsigned int)index));
  }
  return buf;
}

void _re_printf(std::string group, const char *message, ...) {
  // message group check
#if 1 // MessageLevel
  if (!mMessageLevel[group]) return;
#endif // MessageLevel

  if (message == NULL) return;

  // print header
  #ifdef SYSTEMC_H
  std::stringstream t_stream;
  std::string cur_time;

  double tu_value = 0;
  std::string tu_name = "";
  if (sc_get_time_resolution() < sc_time(1, SC_PS)) {
    tu_value = 1000000000000000LL;
    tu_name = " fs";
  }
  else if (sc_get_time_resolution() < sc_time(1, SC_NS)) {
    tu_value = 1000000000000LL;
    tu_name = " ps";
  }
  else if (sc_get_time_resolution() < sc_time(1, SC_US)) {
    tu_value = 1000000000;
    tu_name = " ns";
  }
  else if (sc_get_time_resolution() < sc_time(1, SC_MS)) {
    tu_value = 1000000;
    tu_name = " us";
  }
  else if (sc_get_time_resolution() < sc_time(1, SC_SEC)) {
    tu_value = 1000;
    tu_name = " ms";
  }
  else {
    tu_value = 1;
    tu_name = " s";
  }
  t_stream << sc_time_stamp().value() * (uint64) (sc_get_time_resolution().to_seconds() * tu_value) << tu_name;

  cur_time = t_stream.str();
  #else
  std::string cur_time = "";
  #endif

  #ifdef REGIF_MSG_COLOR
  // color setting
  //
  // severity color       color Linux       Windows
  // fatal    RED         RED   \033[0;31m  FOREGROUND_RED
  // error    RED         BLUE  \033[0;34m  FOREGROUND_BLUE
  // warning  RED
  // info     BLUE
  #ifdef _WIN32
  HANDLE hStdout;
  CONSOLE_SCREEN_BUFFER_INFO csbi;
  if (group == "fatal" || group == "error" || group == "warning") {
    SetConsoleTextAttribute(hStdout, FOREGROUND_RED);
  }
  else if (group == "info" ){
    SetConsoleTextAttribute(hStdout, FOREGROUND_BLUE);
  }
  #else
  if (group == "fatal" || group == "error" || group == "warning") {
    printf("\033[0;31m");
  }
  else if (group == "info" ){
    printf("\033[0;34m");
  }
  #endif
  #endif
  printf("%8s [%20s] (%10s) ", group.c_str(), cur_time.c_str(), mInstName.c_str());

  // print body
  va_list argptr;
  va_start(argptr, message);
  if (argptr == NULL) return;
  vprintf(message, argptr);

  #ifdef DumpFileNameLineNum
  // print footer
  if (group == "fatal" || group == "error") {
    printf(" [%s:%d]\n", mFileName.c_str(), mLineNum);
  }
  // legacy code
  //else {
  //  printf("\n");
  //}
  #endif//DumpFileNameLineNum
  va_end(argptr);

  #ifdef REGIF_MSG_COLOR
  #ifdef _WIN32
  SetConsoleTextAttribute(hStdout, csbi.wAttributes);
  #else
  printf("\033[m");
  #endif
  #endif

  fflush(stdout);
  fflush(stderr);

  if (group == "fatal") {
    exit(1);
  }
}

void get_fileline(std::string filename, int line_number) {
#ifdef _WIN32
  filename = filename.substr(filename.rfind("\\")+1);
#else
  filename = filename.substr(filename.rfind("/")+1);
#endif
  mFileName = filename;
  mLineNum  = line_number;
}

#ifndef re_printf
#define re_printf get_fileline(__FILE__, __LINE__); _re_printf
#endif//re_printf

bool strmatch(const char *ptn, const char *str) {
  bool ret;

  if (ptn == NULL || str == NULL) return false;

  switch( *ptn ) {
  case '\0':
    ret = '\0' == *str;
    break;
  case '*' :
    ret = strmatch( &ptn[1], str ) || (('\0' != *str) && strmatch( ptn, &str[1] ));
    break;
  case '?' :
    ret = ('\0' != *str) && strmatch( &ptn[1], &str[1] );
    break;
  default  :
    ret = ((unsigned char)*ptn == (unsigned char)*str) && strmatch( &ptn[1], &str[1] );
    break;
  }
  return ret;
}


// declare handleCommand relative members
#if 1 // EnableInsertInput
bool mEnableInsertInput;
#endif // EnableInsertInput
#if 1 // MessageLevel
std::map<std::string, bool> mMessageLevel;
#endif // MessageLevel
#if 0 // HWBreak
std::map<std::string, bool> mBreakTable;
vpcl::commandHandler* cmd_handler;
#endif // HWBreak

std::string mInstName;
std::string mFileName;
std::string mCmdId;
int mLineNum;
#if 1 // EnableDumpResult
bool mEnableDumpResult;
#endif // EnableDumpResult

bool DumpInterrupt;
bool EnableVoltageInfo;
double VCC;
double VCCA;
double RefPOCA;
double RefCMPL;
double RefPOCB;
bool POCOFFMODE;
bool SELDETMODE;
unsigned int Tpora;
unsigned int Tpoca;
unsigned int Tcmpl;
unsigned int Tpocb;

#endif//POC_CMDIF_H
