/// This file is generated by Register I/F generator (ver3.0)
////////////////////////////////////////////////////////////////////////////////////////////////////
/// Input file : substitute_info.txt
/// %MODULE substitute
///     #              name     offset_size  
///     %%REG_INSTANCE reg_def  15           
/// 
/// %REG_CHANNEL   reg_def
///      %%TITLE    name        reg_name     size    length   offset   factor_start   factor_end    factor_index    factor_step  init        access  support  callback
///      %%REG      CTRL         CTRL         32      32       0x7FF0      -             -               -              -          0          W|R      TRUE      -   
///      %%REG      PARAM1       PARAM1       32      32       0x7FF4      -             -               -              -          0          W|R      TRUE      - 
///      %%REG      PARAM2       PARAM2       16      16       0x7FF8      -             -               -              -          0          W|R      TRUE      -
///      %%REG      JUDGE        JUDGE        16      16       0x7FFC      -             -               -              -          0          W|R      TRUE      W    
///      %%REG      END          END          16      16       0x7FFF      -             -               -              -          0          W|R      TRUE      W    
/// 
/// 
/// 
/// %REG_NAME      CTRL 
///    %%TITLE     name       upper   lower     init    access      support     callback    
///    %%BIT       CTRL0       0        0        0        W|R        TRUE           W
///    %%BIT       CTRL1        1       1        0        W|R        TRUE           -
///    %%BIT       CTRL2        2       2        0        W|R        TRUE           -
///    %%BIT       CTRL3        3       3        0        W|R        TRUE           -
///    %%BIT       CTRL4        4       4        0        W|R        TRUE           -
///    %%BIT       CTRL5        5       5        0        W|R        TRUE           -
///    %%BIT       CTRL6        6       6        0        W|R        TRUE           -
///    %%BIT       CTRL7        7       7        0        W|R        TRUE           -
///    %%BIT       CTRL8        8       8        0        W|R        TRUE           -
///    %%BIT       CTRL9        9       9        0        W|R        TRUE           -
///    %%BIT       CTRL10       10      10       0        W|R        TRUE           -
///    %%BIT       CTRL11       11      11       0        W|R        TRUE           -
///    %%BIT       CTRL12       12      12       0        W|R        TRUE           -
///    %%BIT       CTRL13       13      13       0        W|R        TRUE           -
///    %%BIT       CTRL14       14      14       0        W|R        TRUE           -
///    %%BIT       CTRL15       15      15       0        W|R        TRUE           -
///    %%BIT       CTRL16       16      16       0        W|R        TRUE           -
///    %%BIT       CTRL17       17      17       0        W|R        TRUE           -
///    %%BIT       CTRL18       18      18       0        W|R        TRUE           -
///    %%BIT       CTRL19       19      19       0        W|R        TRUE           -
///    %%BIT       CTRL20       20      20       0        W|R        TRUE           -
///    %%BIT       CTRL21       21      21       0        W|R        TRUE           -
///    %%BIT       CTRL22       22      22       0        W|R        TRUE           -
///    %%BIT       CTRL23       23      23       0        W|R        TRUE           -
///    %%BIT       CTRL24       24      24       0        W|R        TRUE           -
///    %%BIT       CTRL25       25      25       0        W|R        TRUE           -
///    %%BIT       CTRL26       26      26       0        W|R        TRUE           -
///    %%BIT       CTRL27       27      27       0        W|R        TRUE           -
///    %%BIT       CTRL28       28      28       0        W|R        TRUE           -
///    %%BIT       CTRL29       29      29       0        W|R        TRUE           -
///    %%BIT       CTRL30       30      30       0        W|R        TRUE           -
///    %%BIT       CTRL31       31      31       0        W|R        TRUE           -
/// 
///  
/// %CMD_BASEID  tgt reg
/// %CMD_NODUMP_API CommandCB AssertReset DumpProfile ClearProfile
/// 
////////////////////////////////////////////////////////////////////////////////////////////////////
/// @file substitute_regif.cpp
/// @brief Implementation file of Register IF for SUBSTITUTE model
/// @Id $Id: substitute_regif.cpp,v 1.1.1.1 2012/10/15 02:47:27 chaunguyen Exp $
/// @date $Date: 2012/10/15 02:47:27 $  $Revision: 1.1.1.1 $
/// @author $Author: chaunguyen $

#include "substitute_regif.h"
#ifndef re_printf
#define re_printf get_fileline(__FILE__, __LINE__); _re_printf
#endif//re_printf

/// Constructor of Register IF class: define registers and bits
/// @return none
Csubstitute_regif::Csubstitute_regif(std::string name, unsigned int buswidth)
    :vpcl::reg_super()
#ifdef CWR_SYSTEMC
    , cwmem("register", scml_memsize(0x8000))
#endif
{
    CommandInit();
    CTRL     = new vpcl::re_register(0x7FF0, this, "CTRL"    , name.c_str());
    PARAM1   = new vpcl::re_register(0x7FF4, this, "PARAM1"  , name.c_str());
    PARAM2   = new vpcl::re_register(0x7FF8, this, "PARAM2"  , name.c_str());
    JUDGE    = new vpcl::re_register(0x7FFC, this, "JUDGE"   , name.c_str());
    END      = new vpcl::re_register(0x7FFE, this, "END"     , name.c_str());

    // Construct the register pointer list
    SRegList *TempReg;
    mCurReg = NULL;

#ifdef CWR_SYSTEMC
    mCurReg = TempReg = new SRegList(END       , mCurReg, 0 ,  2,      "16", &cwmem);
    mCurReg = TempReg = new SRegList(JUDGE     , mCurReg, 0 ,  2,      "16", &cwmem);
    mCurReg = TempReg = new SRegList(PARAM2    , mCurReg, 0 ,  2,      "16", &cwmem);
    mCurReg = TempReg = new SRegList(PARAM1    , mCurReg, 0 ,  4,      "32", &cwmem);
    mCurReg = TempReg = new SRegList(CTRL      , mCurReg, 0 ,  4,      "32", &cwmem);
#else
    mCurReg = TempReg = new SRegList(END       , mCurReg, 0 ,  2,      "16");
    mCurReg = TempReg = new SRegList(JUDGE     , mCurReg, 0 ,  2,      "16");
    mCurReg = TempReg = new SRegList(PARAM2    , mCurReg, 0 ,  2,      "16");
    mCurReg = TempReg = new SRegList(PARAM1    , mCurReg, 0 ,  4,      "32");
    mCurReg = TempReg = new SRegList(CTRL      , mCurReg, 0 ,  4,      "32");
#endif

    mRegList = mCurReg;

    (*CTRL  ) ( 0,  0, "CTRL0"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*CTRL  ) ( 1,  1, "CTRL1"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*CTRL  ) ( 2,  2, "CTRL2"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*CTRL  ) ( 3,  3, "CTRL3"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*CTRL  ) ( 4,  4, "CTRL4"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*CTRL  ) ( 5,  5, "CTRL5"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*CTRL  ) ( 6,  6, "CTRL6"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*CTRL  ) ( 7,  7, "CTRL7"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*CTRL  ) ( 8,  8, "CTRL8"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*CTRL  ) ( 9,  9, "CTRL9"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*CTRL  ) (10, 10, "CTRL10"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*CTRL  ) (11, 11, "CTRL11"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*CTRL  ) (12, 12, "CTRL12"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*CTRL  ) (13, 13, "CTRL13"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*CTRL  ) (14, 14, "CTRL14"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*CTRL  ) (15, 15, "CTRL15"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*CTRL  ) (16, 16, "CTRL16"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*CTRL  ) (17, 17, "CTRL17"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*CTRL  ) (18, 18, "CTRL18"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*CTRL  ) (19, 19, "CTRL19"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*CTRL  ) (20, 20, "CTRL20"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*CTRL  ) (21, 21, "CTRL21"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*CTRL  ) (22, 22, "CTRL22"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*CTRL  ) (23, 23, "CTRL23"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*CTRL  ) (24, 24, "CTRL24"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*CTRL  ) (25, 25, "CTRL25"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*CTRL  ) (26, 26, "CTRL26"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*CTRL  ) (27, 27, "CTRL27"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*CTRL  ) (28, 28, "CTRL28"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*CTRL  ) (29, 29, "CTRL29"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*CTRL  ) (30, 30, "CTRL30"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*CTRL  ) (31, 31, "CTRL31"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PARAM1) (31,  0, "PARAM1"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*PARAM2) (15,  0, "PARAM2"  , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*JUDGE ) (15,  0, "JUDGE"   , 0x0       , "W|R"   , vpcl::SPP_ENABLE);
    (*END   ) (15,  0, "END"     , 0x0       , "W|R"   , vpcl::SPP_ENABLE);

    mFileName = "";
    mInstName = name;
    mLineNum = 0;
    mBusWidth = buswidth;
    mBusByteWidth = mBusWidth/8;   // using in BIG ENDIAN
    mIsReset = false;

    // Constructor the mBlock variable of each register
    vpcl::re_register *reg_p = first_reg_object();
    while (reg_p != NULL) {
        mBlock[reg_p->name()] = false;
        mWrCbAPI[reg_p->name()][reg_p->name()] = NULL;
        mRdCbAPI[reg_p->name()][reg_p->name()] = NULL;
        reg_p = next_reg_object();
    }

    //Constructor the mWrCbAPI, mRdCbAPI variable of each register
    mWrCbAPI["END" ]["END" ] = &Csubstitute_regif::cb_END_END;
    mWrCbAPI["CTRL"]["CTRL0"] = &Csubstitute_regif::cb_CTRL_CTRL0;
    mWrCbAPI["JUDGE"]["JUDGE"] = &Csubstitute_regif::cb_JUDGE_JUDGE;



    //Constructor the mAccSize, mChannel variable of each register
    for (TempReg = mRegList ; TempReg!=NULL; TempReg=TempReg->prev) {
        mAccSize[TempReg->my_p->name()] = TempReg->acc_size;
        mChannel[TempReg->my_p->name()] = TempReg->channel;
        mLength [TempReg->my_p->name()] = TempReg->length;
    }
}

/// Destructor: delete pointers
/// @return none
Csubstitute_regif::~Csubstitute_regif()
{
    // Delete registers' pointer
    vpcl::re_register *reg_p = first_reg_object();
    while (reg_p != NULL) {
        delete reg_p;
        reg_p = NULL;
        reg_p = next_reg_object();
    }

    SRegList *TempReg = NULL;
    while (mRegList != NULL) {
        TempReg = mRegList->prev;
        delete mRegList;
        if (TempReg != NULL) {
            mRegList = TempReg;
        } else {
            mRegList = NULL;
        }
    }
}

/// Write the value to requested module register
/// @return true if writing transaction is finished normally
bool Csubstitute_regif::reg_wr(cuint addr,                    ///< [in] Writting address
                               const unsigned char *p_data,   ///< [in] Writing data
                               cuint size)                    ///< [in] Data size (byte)
{
    if(size == 0){
        return false;
    }
    #ifdef IS_MODELED_ENDIAN_BIG
    else{
        if ((addr % mBusByteWidth) + size > mBusByteWidth) {
            return false;
        }
    }
    #endif

    bool ret_val = false;
    if (p_data != NULL) {
        ret_val = reg_wr_process (addr, p_data, size, false);
    }
    return ret_val;
}

/// Read the register value of requested module
/// @return true if reading transaction is finished normally
bool Csubstitute_regif::reg_rd(cuint addr,              ///< [in]  Reading address
                               unsigned char *p_data,   ///< [out] Reading data
                               cuint size)              ///< [in]  Data size (byte)
{
    if(size == 0){
        return false;
    }
    #ifdef IS_MODELED_ENDIAN_BIG
    else{
        if ((addr % mBusByteWidth) + size > mBusByteWidth) {
            return false;
        }
    }
    #endif

    bool ret_val = false;
    if (p_data != NULL) {
        ret_val = reg_rd_process (addr, p_data, size, false);
    }
    return ret_val;
}

/// Write the value to requested module register
/// @return true if writing transaction is finished normally
bool Csubstitute_regif::reg_wr_dbg(cuint addr,                    ///< [in] Writting address
                                   const unsigned char *p_data,   ///< [in] Writing data
                                   cuint size)                    ///< [in] Data size (byte)
{
    if(size == 0){
        return false;
    }
    #ifdef IS_MODELED_ENDIAN_BIG
    else{
        if ((addr % mBusByteWidth) + size > mBusByteWidth) {
            return false;
        }
    }
    #endif

    bool ret_val = false;
    if (p_data != NULL) {
        ret_val = reg_wr_process (addr, p_data, size, true);
    }
    return ret_val;
}

/// Read the register value of requested module
/// @return true if reading transaction is finished normally
bool Csubstitute_regif::reg_rd_dbg(cuint addr,              ///< [in]  Reading address
                                   unsigned char *p_data,   ///< [out] Reading data
                                   cuint size)              ///< [in]  Data size (byte)
{
    if(size == 0){
        return false;
    }
    #ifdef IS_MODELED_ENDIAN_BIG
    else{
        if ((addr % mBusByteWidth) + size > mBusByteWidth) {
            return false;
        }
    }
    #endif

    bool ret_val = false;
    if (p_data != NULL) {
        ret_val = reg_rd_process (addr, p_data, size, true);
    }
    return ret_val;
}

/// Write the value to requested module register
/// @return true if writing transaction is finished normally
bool Csubstitute_regif::reg_wr_process(cuint addr,                   ///< [in] Writting address
                                       const unsigned char *p_data,  ///< [in] Writing data
                                       cuint size,                   ///< [in] Data size (byte)
                                       bool IsDbgFunc)               ///< [in] flag indicate reg_rd or reg_rd_dbg
{
    if (mIsReset == true) {
        re_printf("warning", "Cannot write during reset period\n");
        return true;
    }
    uint tmp_addr = addr;
    #ifdef IS_MODELED_ENDIAN_BIG
    if (size < mBusByteWidth) {
        tmp_addr = addr ^ (mBusByteWidth - size);
    }
    #endif
    bool ret_val = false;
    bool valid_addr = false;
    if (p_data != NULL) {
        std::list<vpcl::re_register *> reg_list;
        vpcl::re_register *reg_p = first_reg_object();
        uint masked_addr = tmp_addr & ((1 << 15) - 1);
        while( reg_p != NULL ) {
            if ((reg_p->addr() <= masked_addr && masked_addr+size <= reg_p->addr()+mLength[reg_p->name()])    // access size <= bus width
             || (masked_addr <= reg_p->addr() && reg_p->addr()+mLength[reg_p->name()] <= masked_addr+size)) { // bus width <= access size
                if ((ChkSize(mAccSize[reg_p->name().c_str()], size, tmp_addr)) || (valid_addr == true)) {
                    valid_addr = true;
                    reg_list.push_back(reg_p);
                }
                else {
                    re_printf("error", "Writing access size to %s at address 0x%08X is wrong: %d byte(s).\n", reg_p->name().c_str(), tmp_addr, size);
                    return false;
                }
            }
            reg_p = next_reg_object();
        }
        if (valid_addr == true) {
            std::list<vpcl::re_register *>::iterator it;
            for (it=reg_list.begin() ; it!=reg_list.end() ; it++) {
                uint d_size = size;
                if (d_size > mLength[(*it)->name()]) {
                    d_size = mLength[(*it)->name()];
                }
                if (size > mLength[(*it)->name()]) { // access size > register size
                    ret_val = reg_wr_func(tmp_addr, &(p_data[((*it)->addr())-masked_addr]), d_size, (*it), IsDbgFunc);
                } else {                                // access size <= register size
                    ret_val = reg_wr_func(tmp_addr, p_data, d_size, (*it), IsDbgFunc);
                }
            }
        } else {
            re_printf("error", "Invalid access address 0x%08X\n", tmp_addr);
        }
    }
    return ret_val;
}

/// Read the register value of requested module
/// @return true if reading transaction is finished normally
bool Csubstitute_regif::reg_rd_process (cuint addr,              ///< [in]  Reading address
                                        unsigned char *p_data,   ///< [out] Reading data
                                        cuint size,              ///< [in]  Data size (byte)
                                        bool IsDbgFunc)          ///< [in] flag indicate reg_rd or reg_rd_dbg
{
    uint tmp_addr = addr;
    #ifdef IS_MODELED_ENDIAN_BIG
    if (size < mBusByteWidth) {
        tmp_addr = addr ^ (mBusByteWidth - size);
    }
    #endif
    bool ret_val = false;
    bool valid_addr = false;
    if (p_data != NULL) {
        std::list<vpcl::re_register *> reg_list;
        vpcl::re_register *reg_p = first_reg_object();
        uint masked_addr = tmp_addr & ((1 << 15) - 1);
        while( reg_p != NULL ) {
            if ((reg_p->addr() <= masked_addr && masked_addr+size <= reg_p->addr()+mLength[reg_p->name()])    // access size <= bus width
             || (masked_addr <= reg_p->addr() && reg_p->addr()+mLength[reg_p->name()] <= masked_addr+size)) { // bus width <= access size
                if ((ChkSize(mAccSize[reg_p->name().c_str()], size, tmp_addr)) || (valid_addr == true)) {
                    valid_addr = true;
                    reg_list.push_back(reg_p);
                }
                else {
                    re_printf("error", "Reading access size to %s at address 0x%08X is wrong: %d byte(s).\n", reg_p->name().c_str(), tmp_addr, size);
                    return false;
                }
            }
            reg_p = next_reg_object();
        }
        if (valid_addr == true) {
            std::list<vpcl::re_register *>::iterator it;
            for (it=reg_list.begin() ; it!=reg_list.end() ; it++) {
                uint d_size = size;
                if (d_size > mLength[(*it)->name()]) {
                    d_size = mLength[(*it)->name()];
                }
                if (size > mLength[(*it)->name()]) { // access size > register size
                    ret_val = reg_rd_func(tmp_addr, &(p_data[((*it)->addr())-masked_addr]), d_size, (*it), IsDbgFunc);
                } else {                                // access size <= register size
                    ret_val = reg_rd_func(tmp_addr, p_data, d_size, (*it), IsDbgFunc);
                }
            }
        } else {
            re_printf("error", "Invalid access address 0x%08X\n", tmp_addr);
        }
    }
    return ret_val;
}

/// Process reading function
/// @return true if reading successfully
bool Csubstitute_regif::reg_rd_func(cuint addr,                     ///< [in]  Reading address
                                    unsigned char *p_data,          ///< [out] Reading data
                                    cuint size,                     ///< [in]  Data size (byte)
                                    vpcl::re_register *Register,    ///< [in] Register
                                    bool IsDbgFunc)                 ///< [in] flag indicate reg_rd or reg_rd_dbg
{
    uint pre_data = 0;
    uint pst_data = 0;
    uint start_pos = 0;
    if ((IsDbgFunc == false) && (Register != NULL)){
        if (mIsReset == true) {
            re_printf("warning", "Cannot launch call-back function during reset period\n");
        }else {
#if 0 //Access size less than the register's length
            if (size < mLength[Register->name()]){
                re_printf("warning","Should read all bit in a register\n");
    #if 0 // Register length = 2 bytes, access size = 1 byte
                if( mLength[Register->name()] == 2 && size == 1){
                    switch (addr & 0x1){
        #ifdef IS_MODELED_ENDIAN_BIG
                        case 0: start_pos = 8; break;
                        case 1: start_pos = 0; break;
        #else
                        case 0: start_pos = 0; break;
                        case 1: start_pos = 8; break;
        #endif
                        default: break;
                    }
                }
    #else
                if(false){}// always false
    #endif
    #if 0 // Register length = 4 bytes, access size = 2 bytes
                else if (mLength[Register->name()] == 4 && size == 2) {
                    switch(addr&0x3) {
        #ifdef IS_MODELED_ENDIAN_BIG
                        case  0: start_pos = 16; break;
                        case  2: start_pos = 0; break;
        #else
                        case  0: start_pos = 0; break;
                        case  2: start_pos = 16; break;
        #endif
                        default: break;
                    }
                }
    #endif
    #if 0 // Register length = 4 bytes, access size = 1 byte
                else if (mLength[Register->name()] == 4 && size == 1) {
                    switch(addr&0x3) {
        #ifdef IS_MODELED_ENDIAN_BIG
                        case  0: start_pos = 24; break;
                        case  1: start_pos = 16; break;
                        case  2: start_pos = 8; break;
                        case  3: start_pos = 0; break;
        #else
                        case  0: start_pos = 0; break;
                        case  1: start_pos = 8; break;
                        case  2: start_pos = 16; break;
                        case  3: start_pos = 24; break;
        #endif
                        default: break;
                    }
                }
    #endif
            }
#endif
            pre_data = (uint)(*Register);
            pst_data = Register->read();
            
        }
    }
    pst_data = (uint)(*Register);

    if (p_data != NULL) {
        memcpy(p_data, &pst_data, size);
    }
    DumpRegMsg("R", Register->name(), "", size, addr, 0, pst_data);
    for (vpcl::bit_info *it=Register->mBitInfo ; it!=NULL ; it=it->next) {
        uint val = (unsigned int)(*Register);
        val = (val>>it->mStartAddr)&(unsigned int)((1<<(it->mEndAddr-it->mStartAddr+1))-1);
        DumpRegMsg("R", Register->name(), it->name(), size, addr, 0, val);
    }
    return true;
}

/// Process writing function
/// @return true if writing successfully
bool Csubstitute_regif::reg_wr_func(cuint addr,                       ///< [in] Writting address
                                    const unsigned char *p_data,      ///< [in] Writing data
                                    cuint size,                       ///< [in] Data size (byte)
                                    vpcl::re_register *Register,      ///< [in] Register
                                    bool IsDbgFunc)                   ///< [in] flag indicate reg_wr or reg_wr_dbg
{
    uint pre_data = 0;
    uint data = 0;
    if ((p_data != NULL) && (Register != NULL)){
        memcpy(&data, p_data, size);
#if 0 //Access size less than the register's length
        if (size < mLength[Register->name()]){
    #if 0 // Register length = 2 bytes, access size = 1 byte
            if( mLength[Register->name()] == 2 && size == 1){
                uint new_data = data & 0xFF;
                switch (addr & 0x1){
        #ifdef IS_MODELED_ENDIAN_BIG
                    case 0: new_data <<= 8; break;
                    case 1: new_data <<= 0; break;
        #else
                    case 0: new_data <<= 0; break;
                    case 1: new_data <<= 8; break;
        #endif
                    default: break;
                }
                data = new_data;
            }
    #else
            if(false){}// always false
    #endif
    #if 0 // Register length = 4 bytes, access size = 2 bytes
            else if (mLength[Register->name()] == 4 && size == 2) {
                uint new_data = data&0xFFFF;
                switch(addr&0x3) {
        #ifdef IS_MODELED_ENDIAN_BIG
                    case  0: new_data <<= 16; break;
                    case  2: new_data <<=  0; break;
        #else
                    case  0: new_data <<=  0; break;
                    case  2: new_data <<= 16; break;
        #endif
                    default: break;
                }
                data = new_data;
            }
    #endif
    #if 0 // Register length = 4 bytes, access size = 1 byte
            else if (mLength[Register->name()] == 4 && size == 1) {
                uint new_data = data&0xFF;
                switch(addr&0x3) {
        #ifdef IS_MODELED_ENDIAN_BIG
                    case  0: new_data <<= 24; break;
                    case  1: new_data <<= 16; break;
                    case  2: new_data <<=  8; break;
                    case  3: new_data <<=  0; break;
        #else
                    case  0: new_data <<=  0; break;
                    case  1: new_data <<=  8; break;
                    case  2: new_data <<= 16; break;
                    case  3: new_data <<= 24; break;
        #endif
                    default: break;
                }
                data = new_data;
            }
    #endif
        }
#endif
    }
    if (Register != NULL) {
        if ((mBlock[Register->name()] == false) || (IsDbgFunc == true)){
            pre_data = (uint)(*Register);
            if (IsDbgFunc == true) {
                *Register = data;
            } else {
                Register->write(data);
            }
            DumpRegMsg("W", Register->name(), "", size, addr, pre_data, (uint)(*Register));
            for (vpcl::bit_info *it=Register->mBitInfo ; it!=NULL ; it=it->next) {
                uint val = (unsigned int)(*Register);
                val = (val>>it->mStartAddr)&(unsigned int)((1<<(it->mEndAddr-it->mStartAddr+1))-1);
                uint pre_val = pre_data;
                pre_val = (pre_val>>it->mStartAddr)&(unsigned int)((1<<(it->mEndAddr-it->mStartAddr+1))-1);
                DumpRegMsg("W", Register->name(), it->name(), size, addr, pre_val, val);
                if (IsDbgFunc == false) {
                    if ((mWrCbAPI[Register->name()][it->name()]) != NULL) {
                        (this->*(mWrCbAPI[Register->name()][it->name()]))(RegCBstr(mChannel[Register->name()], true, size, pre_data, data));
                    }
                }
            }
        }
        else {
            re_printf("warning","%s is blocked writing from Bus I/F.\n", Register->name().c_str());
        }
    }
    return true;
}

/// Check access size
/// @@return true if detect_size equal expect_size
bool Csubstitute_regif::ChkSize(std::string expect_size, cuint detect_size, cuint addr)
{
    std::vector<std::string> arg_vec = Str2Vec(expect_size, '|');
    std::vector<std::string>::iterator it;
    char *err_p = NULL;
    uint size = 0;
    if (detect_size > mBusByteWidth) {
        re_printf("error", "Invalid access size: %d bytes\n", detect_size);
        return false;
    }
    if(addr%detect_size != 0) {
        re_printf("error", "Invalid access address 0x%08X with access size %d bytes\n", addr, detect_size);
        return false;
    }
    for (it = arg_vec.begin(); it != arg_vec.end(); it++) {
        size = (uint) strtoul((*it).c_str(), &err_p, 0);
        if (err_p != NULL) {
            if (errno != ERANGE && *err_p == '\0') {
                if ((size/8) == detect_size) {
                    return true;
                }
            }
        }
    }
    return false;
}

/// Initialize reg_handle_command variables
/// @return none
void Csubstitute_regif::CommandInit()
{
    mDumpRegisterRW = false;
    mDumpFileNameLineNum = false;
    mMessageLevel["fatal"]   = true;
    mMessageLevel["error"]   = true;
    mMessageLevel["warning"] = false;
    mMessageLevel["info"]    = false;
}

/// Process reg_handle_command command
/// @return string
std::string Csubstitute_regif::reg_handle_command (const std::vector<std::string>& args)
{
    std::string ret = "";
    std::string err_msg = "Error ("   + mInstName + ") ";   // error message
    if (args[0] == "reg") {
        if (args[1] == "help") {
            ret += "    --- reg ---\n";
            ret += "    reg MessageLevel <fatal|error|warning|info> Select debug message level (Default: fatal,error)\n";
            ret += "    reg DumpRegisterRW <true/false>             Select dump register access information  (Default: false)\n";
            ret += "    reg DumpFileNameLineNum <true/false>        Select dump information about file name and line number (Default: false)\n";
            ret += "    reg <register_name> MessageLevel <fatal|error|warning|info> Select debug message level for register (Default: fatal,error)\n";
            ret += "    reg <register_name> force <value>           Force register with setting value\n";
            ret += "    reg <register_name> release                 Release register from force value\n";
            ret += "    reg <register_name> <value>                 Write a value into register\n";
            ret += "    reg <register_name>                         Read value of register\n";
            ret += "    reg help                                    Show a direction\n";
        }
        else if (args[1] == "DumpRegisterRW") {
            if (args.size() == 2) {
                ret = (mDumpRegisterRW)? "true" : "false";
            }
            else if (args.size() == 3) {
                if (args[2] == "true") {
                    mDumpRegisterRW = true;
                }
                else if (args[2] == "false") {
                    mDumpRegisterRW = false;
                } else {
                    ret = err_msg + "DumpRegisterRW command needs an argument [true/false]\n";
                }
            } else {
                ret = err_msg + "DumpRegisterRW has too much arguments\n";
            }
        }
        else if (args[1] == "DumpFileNameLineNum") {
            if (args.size() == 2) {
                ret = (mDumpFileNameLineNum)? "true" : "false";
            }
            else if (args.size() == 3) {
                if (args[2] == "true") {
                    mDumpFileNameLineNum = true;
                }
                else if (args[2] == "false") {
                    mDumpFileNameLineNum = false;
                } else {
                    ret = err_msg + "DumpFileNameLineNum command needs an argument [true/false]\n";
                }
            } else {
                ret = err_msg + "DumpFileNameLineNum has too much arguments\n";
            }
        }
        else if (args[1] == "MessageLevel") {
            // read mode
            if (args.size() == 2) {
                std::map<std::string, bool>::iterator it;
                for (it = mMessageLevel.begin(); it != mMessageLevel.end(); it++) {
                    if ( it->second == true ) {
                        ret += " " + it->first;
                    }
                }
            // write mode
            } else if (args.size() == 3) {
                std::vector<std::string> arg_vec = Str2Vec(args[2], '|');
                std::map<std::string, bool>::iterator msgit;
                for (msgit =mMessageLevel.begin(); msgit != mMessageLevel.end(); msgit++) {
                    msgit->second = false;
                }
                std::vector<std::string>::iterator it;
                for (it = arg_vec.begin(); it != arg_vec.end(); it++) {
                    mMessageLevel[*it] = true;
                }
            } else {
                ret = err_msg + "MessageLevel has too much arguments\n";
            }
        } else {
            vpcl::re_register *reg_p = first_reg_object();
            bool matched = false;
            while (reg_p != NULL) {
                if (args[1] == reg_p->name()) {
                    ret = AccessRegCommand(args, reg_p, mBlock[args[1]]);
                    matched = true;
                    break;
                }
                reg_p = next_reg_object();
            }
            if (!matched) {
                ret = err_msg + "Register name " + (std::string)args[1] + " is invalid\n";
            }
        }
    }
    return ret;
}

/// process reg_handle_command of "reg" parameter
/// @return string
std::string Csubstitute_regif::AccessRegCommand (const std::vector<std::string>& args, vpcl::re_register *Register, bool &BlockReg)
{
    std::string ret = "";
    char *err_p = NULL;
    std::string err_msg = "Error ("   + mInstName + ") ";   // error message
    uint data = 0;
    std::ostringstream str_tmp;
    if (Register != NULL) {
        if (args.size() == 2) {
            data = (uint)(*Register);
            str_tmp<<std::setw(14)<<std::left<<(Register->name());
            str_tmp<<"0x"<<std::setw(8)<<std::hex<<std::uppercase<<std::left<<data<<"\n";
            ret = str_tmp.str();
        } else if ((args.size() == 3) && (args[2] == "release")) {
            BlockReg = false;
        } else if ((args.size() == 4) && (args[2] == "force")) {
            data = (uint) strtoul(args[3].c_str(), &err_p, 0);
            if (err_p != NULL) {
                if (errno != ERANGE && *err_p == '\0') {
                    *Register = data;
                } else {
                    ret = err_msg + "[" + Register->name() + "] Invalid force value\n";
                }
            }
            BlockReg = true;
        } else if ((args.size() >= 3) && (args[2] == "MessageLevel")) {
            if (args.size() == 3) {
                ret = Register->name() + " ";
                ret += Register->GetMessageLevel();
            } else if (args.size() == 4) {
                std::map<std::string, bool> MessageLevel;
                std::vector<std::string> arg_vec = Str2Vec(args[3], '|');
                std::vector<std::string>::iterator it;
                for (it = arg_vec.begin(); it != arg_vec.end(); it++) {
                    MessageLevel[*it] = true;
                }
                Register->SetMessageLevel(MessageLevel);
            } else {
                ret = err_msg + "[" + Register->name() + "] MessageLevel has too much arguments\n";
            }
        } else if ((args.size() == 3) && (args[2] != "release")) {
            data = (uint) strtoul(args[2].c_str(), &err_p, 0);
            if (errno != ERANGE && *err_p == '\0') {
                *Register = data;
            } else {
                ret = err_msg + "[" + Register->name() + "] Invalid write value\n";
            }
        } else {
            ret = err_msg + "Wrong command : ";
            for (uint index = 0; index < args.size(); index ++) {
                ret += args[index] + " ";
            }
        }
    }
    return ret;
}

/// convert string to vector
/// @return vector
std::vector<std::string> Csubstitute_regif::Str2Vec(std::string str, const char sep)
{
    std::vector<std::string> buf;
    std::string::size_type index = 0;
    for (uint i=0 ; i<str.size() ; i++) {
        if (str[i] == sep) {
            buf.push_back(str.substr(index, i-index));
            index = i+1;
        }
    }
    buf.push_back(str.substr(index));
    return buf;
}

/// Dump register access information
/// @return none
void Csubstitute_regif::DumpRegMsg(const std::string operation, const std::string RegName, const std::string BitName, cuint size, cuint addr, cuint pre_data, cuint data)
{
    if(mDumpRegisterRW == true) {
        std::string reg_name = RegName;
        std::string pre_data_str;
        if (operation == "R") {
            if (BitName == ""){
                re_printf("DumpRegMsg", "REG [%-15s] R Size= %-1d Addr= 0x%-8X Data= 0x%-8X\n", reg_name.c_str(), size, addr, data);
            } else {
                reg_name += ":" +  BitName;
                re_printf("DumpRegMsg", "REG [%-15s] R Size= %-1d Addr= 0x%-8X Data= 0x%-8X\n", reg_name.c_str(), size, addr, data);
            }
        } else {
            if (BitName == "") {
                re_printf("DumpRegMsg", "REG [%-15s] W Size= %-1d Addr= 0x%-8X Data= 0x%-08X => 0x%-8X\n", reg_name.c_str(), size, addr, pre_data, data);
            } else {
                reg_name += ":" +  BitName;
                re_printf("DumpRegMsg", "REG [%-15s] W Size= %-1d Addr= 0x%-8X Data= 0x%-08X => 0x%-8X\n", reg_name.c_str(), size, addr, pre_data, data);
            }
        }
    }
}

/// find first register pointer
/// @return first register pointer
vpcl::re_register *Csubstitute_regif::first_reg_object()
{
    mCurReg = mRegList;
    return mCurReg->my_p;
}

/// find next register pointer
/// @return next register pointer
vpcl::re_register *Csubstitute_regif::next_reg_object()
{
    if (mCurReg != NULL) {
        mCurReg = mCurReg->prev;
        if (mCurReg != NULL) {
            return mCurReg->my_p;
        }
    }
    return NULL;
}

/// write callback function of CoWare
/// @return none
void Csubstitute_regif::wr_cb(cuint addr, uint data)
{
    #ifdef CWR_SYSTEMC
    for (SRegList *TempReg = mRegList ; TempReg!=NULL; TempReg=TempReg->prev) {
        if (TempReg->my_p->addr() == addr) {
            cwmem.put(data, addr&0xFFFF);
            break;
        }
    }
    #else
    array[addr&0xFFFF] = data;
    #endif
}

/// read callback function of CoWare
/// @return read data
unsigned int Csubstitute_regif::rd_cb(cuint addr)
{
    #ifdef CWR_SYSTEMC
    uint ret = 0;
    for (SRegList *TempReg = mRegList ; TempReg!=NULL; TempReg=TempReg->prev) {
        if (TempReg->my_p->addr() == addr) {
            ret = cwmem.get(addr&0xFFFF);
            break;
        }
    }
    return ret;
    #else
    return array[addr&0xFFFF];
    #endif
}

/// print message function
/// @return none
void Csubstitute_regif::_re_printf(std::string group, const char *message, ...)
{
    // message group check
    if (group == "DumpRegMsg") {
        group = "info";
    } else {
        if (mMessageLevel[group] == false) return;
    }

    if (message == NULL) return;

    // print header
#ifdef SYSTEMC_H
    std::stringstream t_stream;
    std::string cur_time;
                                                                                                                  
    double tu_value = 0;
    std::string tu_name = "";
    if (sc_get_time_resolution() < sc_time(1, SC_PS)) {
      tu_value = 1000000000000000LL;
      tu_name = " fs";
    }
    else if (sc_get_time_resolution() < sc_time(1, SC_NS)) {
      tu_value = 1000000000000LL;
      tu_name = " ps";
    }
    else if (sc_get_time_resolution() < sc_time(1, SC_US)) {
      tu_value = 1000000000;
      tu_name = " ns";
    }
    else if (sc_get_time_resolution() < sc_time(1, SC_MS)) {
      tu_value = 1000000;
      tu_name = " us";
    }
    else if (sc_get_time_resolution() < sc_time(1, SC_SEC)) {
      tu_value = 1000;
      tu_name = " ms";
    }
    else {
      tu_value = 1;
      tu_name = " s";
    }
    t_stream << sc_time_stamp().value() * (uint64) (sc_get_time_resolution().to_seconds() * tu_value) << tu_name;
                                                                                                                  
    cur_time = t_stream.str();
#else
    std::string cur_time = "";
#endif
    printf("%8s [%20s] (%10s) ", group.c_str(), cur_time.c_str(), mInstName.c_str());

    // print body
    va_list argptr;
    va_start(argptr, message);
    if (argptr != NULL) {
        vprintf(message, argptr);
    }

    // print footer
    if ((group == "fatal" || group == "error") && (mDumpFileNameLineNum == true)) {
        printf(" [%s:%d]\n", mFileName.c_str(), mLineNum);
    }
    va_end(argptr);

    fflush(stdout);
    fflush(stderr);
}

/// Get file name and line number
/// @return none
void Csubstitute_regif::get_fileline(std::string filename, int line_number)
{
    mFileName = filename;
    mLineNum  = line_number;
}

/// API for instance registration
/// @return none
void Csubstitute_regif::set_instance_name(std::string InstName)
{
    mInstName = InstName;
}

/// Method to change value of mIsReset
/// @return none
void Csubstitute_regif::EnableReset(const bool is_active)
{
    // update register IF class's reset status
    mIsReset = is_active;

    // update re_register's reset status
    vpcl::re_register *reg_p = first_reg_object();

    while( reg_p != NULL ) {
        reg_p->EnableReset(is_active);

        if (is_active) {
            re_printf("info", "Initialize %s (%08x)\n", reg_p->name().c_str(), (uint)(*reg_p));
        }
        reg_p = next_reg_object();
    }
}
