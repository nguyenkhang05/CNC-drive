// -----------------------------------------------------------------------------
// $Id: intc2g_u2_regif.cpp,v 1.10 2020/03/23 08:55:16 synguyen Exp $
//
// Copyright(c) 2018-2020 Renesas Electronics Corporation
// Copyright(c) 2018-2020 Renesas Design Vietnam Co., Ltd.
// RENESAS ELECTRONICS CONFIDENTIAL AND PROPRIETARY.
// This program must be used solely for the purpose for which
// it was furnished by Renesas Electronics Corporation. No part of this
// program may be reproduced or disclosed to others, in any
// form, without the prior written permission of Renesas Electronics
// Corporation.
// -----------------------------------------------------------------------------
// This file is generated by Register I/F generator
//    gen_regif.py 1.9 2013/12/04 09:51:36 sontran
//    gen_regif_class.py 1.60 2014/10/24 09:42:15 ducduong
//    regif_cpp.skl 1.53 2014/10/13 03:19:16 sontran
//
// Input file : input/intc2g/intc2g_u2_regif.txt
////////////////////////////////////////////////////////////////////////////////
// %MODULE INTC2G_U2
// 
// %%REG_INSTANCE  reg_def 14
// 
// %REG_CHANNEL reg_def
//     %%TITLE     name                reg_name           wsize     rsize     length      offset      access      init           factor_start    factor_end      factor_step     support     callback
//     %%REG       INTC2GOVFCLR        INTC2GOVFCLR       8|32      8|16|32   32          0x0         R|W1:0      0x00000000     -               -               -               TRUE        W
//     %%REG       INTC2GOVFSTAT       INTC2GOVFSTAT      -         8|16|32   32          0x4         R           0x00000000     -               -               -               TRUE        -
//     %%REG       INTC2GERRADDR       INTC2GERRADDR      -         8|16|32   32          0x8         R           0x00000000     -               -               -               TRUE        -
//     %%REG       INTC2GERRTYPE       INTC2GERRTYPE      -         8|16|32   32          0xC         R           0x00000000     -               -               -               TRUE        -
//     %%REG       INTC2GSPIDERRCLR    INTC2GSPIDERRCLR   32        8|16|32   32          0x10        W1:0        0x00000000     -               -               -               TRUE        W
//     %%REG       INTC2GSPIDERRSTAT   INTC2GSPIDERRSTAT  -         8|16|32   32          0x14        R           0x00000000     -               -               -               TRUE        -
//     %%REG       INTC2GKCPROT        INTC2GKCPROT       32        8|16|32   32          0x18        R|W         0x00000000     -               -               -               TRUE        W
//     %%REG       INTC2GMPID          INTC2GMPID         8|32      8|16|32   32          0x40        R|W         0x00000000     0               15              -               TRUE        -
//     %%REG       INTC2GPROT_GR       INTC2GPROT_GR      32        8|16|32   32          0xF0        R|W         0x00000000     -               -               -               TRUE        -
//     %%REG       INTC2GPROT_IMR      INTC2GPROT_IMR     32        8|16|32   32          0xF4        R|W         0x00000000     -               -               -               TRUE        -
//     %%REG       INTC2GPROT_         INTC2GPROT_        32        8|16|32   32          0x100       R|W         0x00000000     32              2047            0x04            TRUE        -
//     
// 
// 
// %REG_NAME INTC2GOVFCLR
//     %%TITLE     name        upper   lower   init    access  support     callback
//     %%BIT       CLRO        1       1       0       R|W1:0  TRUE        W
// 
// %REG_NAME INTC2GOVFSTAT
//     %%TITLE     name        upper   lower   init    access  support     callback
//     %%BIT       OVF         1       1       0       R       TRUE        -
// 
// %REG_NAME INTC2GERRADDR
//     %%TITLE     name        upper   lower   init    access  support     callback
//     %%BIT       ADDR        31      0       0       R       TRUE        -
// 
// %REG_NAME INTC2GERRTYPE
//     %%TITLE     name        upper   lower   init    access  support     callback
//     %%BIT       SEC         13      13      0       R       TRUE        -
//     %%BIT       DBG         12      12      0       R       TRUE        -
//     %%BIT       UM          11      11      0       R       TRUE        -
//     %%BIT       SPID        10      6       0       R       TRUE        -
//     %%BIT       WRITE       0       0       0       R       TRUE        -
//     
// %REG_NAME INTC2GSPIDERRCLR
//     %%TITLE     name        upper   lower   init    access  support     callback
//     %%BIT       SPIDCLR     31       0       0       W1:0      TRUE        W
// 
// %REG_NAME INTC2GSPIDERRSTAT
//     %%TITLE     name        upper   lower   init    access  support     callback
//     %%BIT       SPIDERR     31       0       0       R      TRUE        -
// 
// 
// %REG_NAME INTC2GKCPROT
//     %%TITLE     name        upper   lower   init    access  support     callback
//     %%BIT       KCPROT      31      1       0       R|W     TRUE        W
//     %%BIT       KCE         0       0       0       R|W     TRUE        -
// 
// %REG_NAME INTC2GMPID
//     %%TITLE     name        upper   lower   init    access  support     callback
//     %%BIT       SPID        4       0       0       R|W     TRUE        W|R
// 
// %REG_NAME INTC2GPROT_GR
//     %%TITLE     name        upper   lower   init    access  support     callback
//     %%BIT       MPID        31      16      0       R|W     TRUE        W
//     %%BIT       GEN         8       8       0       R|W     TRUE        -
//     %%BIT       DBG         6       6       0       R|W     TRUE        -
//     %%BIT       UM          4       4       0       R|W     TRUE        -
//     %%BIT       WG          1       1       0       R|W     TRUE        -
//     %%BIT       RG          0       0       0       R|W     TRUE        -
// 
// %REG_NAME INTC2GPROT_IMR
//     %%TITLE     name        upper   lower   init    access  support     callback
//     %%BIT       MPID        31      16      0       R|W     TRUE        W
//     %%BIT       GEN         8       8       0       R|W     TRUE        -
//     %%BIT       DBG         6       6       0       R|W     TRUE        -
//     %%BIT       UM          4       4       0       R|W     TRUE        -
//     %%BIT       WG          1       1       0       R|W     TRUE        -
//     %%BIT       RG          0       0       0       R|W     TRUE        -
// 
// %REG_NAME INTC2GPROT_
//     %%TITLE     name        upper   lower   init    access  support     callback
//     %%BIT       MPID        31      16      0       R|W     TRUE        W
//     %%BIT       GEN         8       8       0       R|W     TRUE        -
//     %%BIT       DBG         6       6       0       R|W     TRUE        -
//     %%BIT       UM          4       4       0       R|W     TRUE        -
//     %%BIT       WG          1       1       0       R|W     TRUE        -
//     %%BIT       RG          0       0       0       R|W     TRUE        -
////////////////////////////////////////////////////////////////////////////////
/// @file intc2g_u2_regif.cpp
/// @brief Register IF class of model INTC2G_U2
/// $Id: intc2g_u2_regif.cpp,v 1.10 2020/03/23 08:55:16 synguyen Exp $
/// $Date: 2020/03/23 08:55:16 $
/// $Revison$
/// $Author: synguyen $
////////////////////////////////////////////////////////////////////////////////
#include "intc2g_u2_regif.h"
#ifndef re_printf
#define re_printf get_fileline(__FILE__, __LINE__); _re_printf
#endif//re_printf

/// Constructor of Register IF class: define registers and bits
/// @return none
Cintc2g_u2_regif::Cintc2g_u2_regif(std::string name, uint buswidth, uint numOfCh)
    :vpcl::reg_super()
    #ifdef USR_CWR_SYSTEMC
    , cwmem("register", scml_memsize(0x2080/4))
    #endif
{
    mNumOfCh = numOfCh;
    uint FactorIndex_INTC2GPROT__tmp[emNUM_INTC2GPROT_] = {  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,  45,  46, 
                                                     47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61, 
                                                     62,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76, 
                                                     77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91, 
                                                     92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106, 
                                                    107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 
                                                    122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 
                                                    137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 
                                                    152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 
                                                    167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 
                                                    182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 
                                                    197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 
                                                    212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 
                                                    227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 
                                                    242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 
                                                    257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 
                                                    272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 
                                                    287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 
                                                    302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 
                                                    317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 
                                                    332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 
                                                    347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 
                                                    362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 
                                                    377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 
                                                    392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 
                                                    407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 
                                                    422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 
                                                    437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 
                                                    452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 
                                                    467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 
                                                    482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 
                                                    497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 
                                                    512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 
                                                    527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 
                                                    542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 
                                                    557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 
                                                    572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 
                                                    587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 
                                                    602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 
                                                    617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 
                                                    632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 
                                                    647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 
                                                    662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 
                                                    677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 
                                                    692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 
                                                    707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 
                                                    722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 
                                                    737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 
                                                    752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 
                                                    767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 
                                                    782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 
                                                    797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 
                                                    812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 
                                                    827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 
                                                    842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 
                                                    857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 
                                                    872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 
                                                    887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 
                                                    902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 
                                                    917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 
                                                    932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 
                                                    947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 
                                                    962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 
                                                    977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 
                                                    992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 
                                                    1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 
                                                    1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 
                                                    1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 
                                                    1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 
                                                    1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 
                                                    1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 
                                                    1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 
                                                    1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 
                                                    1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 
                                                    1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 
                                                    1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 
                                                    1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 
                                                    1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 
                                                    1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 
                                                    1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 
                                                    1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 
                                                    1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 
                                                    1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 
                                                    1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 
                                                    1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 
                                                    1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 
                                                    1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 
                                                    1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 
                                                    1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 
                                                    1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 1381, 
                                                    1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 
                                                    1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 
                                                    1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 
                                                    1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 
                                                    1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455, 1456, 
                                                    1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 
                                                    1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 
                                                    1487, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 
                                                    1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 
                                                    1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 
                                                    1532, 1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 
                                                    1547, 1548, 1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 
                                                    1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 
                                                    1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 
                                                    1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 
                                                    1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 
                                                    1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1632, 1633, 1634, 1635, 1636, 
                                                    1637, 1638, 1639, 1640, 1641, 1642, 1643, 1644, 1645, 1646, 1647, 1648, 1649, 1650, 1651, 
                                                    1652, 1653, 1654, 1655, 1656, 1657, 1658, 1659, 1660, 1661, 1662, 1663, 1664, 1665, 1666, 
                                                    1667, 1668, 1669, 1670, 1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1680, 1681, 
                                                    1682, 1683, 1684, 1685, 1686, 1687, 1688, 1689, 1690, 1691, 1692, 1693, 1694, 1695, 1696, 
                                                    1697, 1698, 1699, 1700, 1701, 1702, 1703, 1704, 1705, 1706, 1707, 1708, 1709, 1710, 1711, 
                                                    1712, 1713, 1714, 1715, 1716, 1717, 1718, 1719, 1720, 1721, 1722, 1723, 1724, 1725, 1726, 
                                                    1727, 1728, 1729, 1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738, 1739, 1740, 1741, 
                                                    1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749, 1750, 1751, 1752, 1753, 1754, 1755, 1756, 
                                                    1757, 1758, 1759, 1760, 1761, 1762, 1763, 1764, 1765, 1766, 1767, 1768, 1769, 1770, 1771, 
                                                    1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1780, 1781, 1782, 1783, 1784, 1785, 1786, 
                                                    1787, 1788, 1789, 1790, 1791, 1792, 1793, 1794, 1795, 1796, 1797, 1798, 1799, 1800, 1801, 
                                                    1802, 1803, 1804, 1805, 1806, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 1815, 1816, 
                                                    1817, 1818, 1819, 1820, 1821, 1822, 1823, 1824, 1825, 1826, 1827, 1828, 1829, 1830, 1831, 
                                                    1832, 1833, 1834, 1835, 1836, 1837, 1838, 1839, 1840, 1841, 1842, 1843, 1844, 1845, 1846, 
                                                    1847, 1848, 1849, 1850, 1851, 1852, 1853, 1854, 1855, 1856, 1857, 1858, 1859, 1860, 1861, 
                                                    1862, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1871, 1872, 1873, 1874, 1875, 1876, 
                                                    1877, 1878, 1879, 1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 
                                                    1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 
                                                    1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 
                                                    1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 
                                                    1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 
                                                    1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 
                                                    1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 
                                                    1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 
                                                    1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 
                                                    2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 
                                                    2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 2039, 2040, 2041, 
                                                    2042, 2043, 2044, 2045, 2046, 2047};
    for(uint i = 0; i < mNumOfCh; i++) {
        mFactorIndexINTC2GPROT_[i] = FactorIndex_INTC2GPROT__tmp[i];
    }

    CommandInit();
    INTC2GOVFCLR      = new vpcl::re_register(0x0000, this, "INTC2GOVFCLR"     , name.c_str());
    INTC2GOVFSTAT     = new vpcl::re_register(0x0004, this, "INTC2GOVFSTAT"    , name.c_str());
    INTC2GERRADDR     = new vpcl::re_register(0x0008, this, "INTC2GERRADDR"    , name.c_str());
    INTC2GERRTYPE     = new vpcl::re_register(0x000C, this, "INTC2GERRTYPE"    , name.c_str());
    INTC2GSPIDERRCLR  = new vpcl::re_register(0x0010, this, "INTC2GSPIDERRCLR" , name.c_str());
    INTC2GSPIDERRSTAT = new vpcl::re_register(0x0014, this, "INTC2GSPIDERRSTAT", name.c_str());
    INTC2GKCPROT      = new vpcl::re_register(0x0018, this, "INTC2GKCPROT"     , name.c_str());
    INTC2GPROT_GR     = new vpcl::re_register(0x00F0, this, "INTC2GPROT_GR"    , name.c_str());
    INTC2GPROT_IMR    = new vpcl::re_register(0x00F4, this, "INTC2GPROT_IMR"   , name.c_str());
    std::ostringstream str_tmp;
    for(uint i = 0; i < emNUM_INTC2GMPID; i++) {
        str_tmp.str("");
        str_tmp<<"INTC2GMPID"<< i;
        INTC2GMPID       [i] = new vpcl::re_register((0x0040) + 4*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < mNumOfCh; i++) {
        str_tmp.str("");
        str_tmp<<"INTC2GPROT_"<< mFactorIndexINTC2GPROT_[i];
        INTC2GPROT_      [mFactorIndexINTC2GPROT_[i]] = new vpcl::re_register((0x0100) + 4*(mFactorIndexINTC2GPROT_[i]), this, str_tmp.str(), name.c_str());
    }

    // Construct the register pointer list
    mCurReg = NULL;

    uint index = 0;
    mRegMap = new uint [1<<14];
    for (uint i = 0; i < (1<<14); i++) {
        mRegMap[i] = (1<<14);
    }

    mRegMap[0x0000]     = index;
    mRegMap[0x0000 + 1] = index;
    mRegMap[0x0000 + 2] = index;
    mRegMap[0x0000 + 3] = index++;
    mRegMap[0x0004]     = index;
    mRegMap[0x0004 + 1] = index;
    mRegMap[0x0004 + 2] = index;
    mRegMap[0x0004 + 3] = index++;
    mRegMap[0x0008]     = index;
    mRegMap[0x0008 + 1] = index;
    mRegMap[0x0008 + 2] = index;
    mRegMap[0x0008 + 3] = index++;
    mRegMap[0x000C]     = index;
    mRegMap[0x000C + 1] = index;
    mRegMap[0x000C + 2] = index;
    mRegMap[0x000C + 3] = index++;
    mRegMap[0x0010]     = index;
    mRegMap[0x0010 + 1] = index;
    mRegMap[0x0010 + 2] = index;
    mRegMap[0x0010 + 3] = index++;
    mRegMap[0x0014]     = index;
    mRegMap[0x0014 + 1] = index;
    mRegMap[0x0014 + 2] = index;
    mRegMap[0x0014 + 3] = index++;
    mRegMap[0x0018]     = index;
    mRegMap[0x0018 + 1] = index;
    mRegMap[0x0018 + 2] = index;
    mRegMap[0x0018 + 3] = index++;
    for(uint i = 0; i < emNUM_INTC2GMPID;       i++) {
        mRegMap[(0x0040)     + i*4 ] = index;
        mRegMap[(0x0040 + 1) + i*4 ] = index;
        mRegMap[(0x0040 + 2) + i*4 ] = index;
        mRegMap[(0x0040 + 3) + i*4 ] = index++;
    }
    mRegMap[0x00F0]     = index;
    mRegMap[0x00F0 + 1] = index;
    mRegMap[0x00F0 + 2] = index;
    mRegMap[0x00F0 + 3] = index++;
    mRegMap[0x00F4]     = index;
    mRegMap[0x00F4 + 1] = index;
    mRegMap[0x00F4 + 2] = index;
    mRegMap[0x00F4 + 3] = index++;
    for(uint i = 0; i < mNumOfCh;      i++) {
        mRegMap[(0x0100)     + (mFactorIndexINTC2GPROT_[i])*4] = index;
        mRegMap[(0x0100 + 1) + (mFactorIndexINTC2GPROT_[i])*4] = index;
        mRegMap[(0x0100 + 2) + (mFactorIndexINTC2GPROT_[i])*4] = index;
        mRegMap[(0x0100 + 3) + (mFactorIndexINTC2GPROT_[i])*4] = index++;
    }
    mTotalRegNum = index;
    mRegArray = new SRegList* [mTotalRegNum];
    index = 0;
    #ifdef USR_CWR_SYSTEMC
    cw_instantiate_reg(CW_INTC2GOVFCLR       , INTC2GOVFCLR->name()     , INTC2GOVFCLR->addr()     );
    cw_instantiate_reg(CW_INTC2GOVFSTAT      , INTC2GOVFSTAT->name()    , INTC2GOVFSTAT->addr()    );
    cw_instantiate_reg(CW_INTC2GERRADDR      , INTC2GERRADDR->name()    , INTC2GERRADDR->addr()    );
    cw_instantiate_reg(CW_INTC2GERRTYPE      , INTC2GERRTYPE->name()    , INTC2GERRTYPE->addr()    );
    cw_instantiate_reg(CW_INTC2GSPIDERRCLR   , INTC2GSPIDERRCLR->name() , INTC2GSPIDERRCLR->addr() );
    cw_instantiate_reg(CW_INTC2GSPIDERRSTAT  , INTC2GSPIDERRSTAT->name(), INTC2GSPIDERRSTAT->addr());
    cw_instantiate_reg(CW_INTC2GKCPROT       , INTC2GKCPROT->name()     , INTC2GKCPROT->addr()     );
    for(uint i = 0; i < emNUM_INTC2GMPID       ; i++) cw_instantiate_reg(CW_INTC2GMPID         [i], INTC2GMPID       [i]->name(), INTC2GMPID       [i]->addr());
    cw_instantiate_reg(CW_INTC2GPROT_GR      , INTC2GPROT_GR->name()    , INTC2GPROT_GR->addr()    );
    cw_instantiate_reg(CW_INTC2GPROT_IMR     , INTC2GPROT_IMR->name()   , INTC2GPROT_IMR->addr()   );
    for(uint i = 0; i < mNumOfCh      ; i++) cw_instantiate_reg(CW_INTC2GPROT_        [mFactorIndexINTC2GPROT_      [i]], INTC2GPROT_      [mFactorIndexINTC2GPROT_      [i]]->name(), INTC2GPROT_      [mFactorIndexINTC2GPROT_      [i]]->addr());
    #endif
    mCurReg = mRegArray[index++] = new SRegList(INTC2GOVFCLR       , mCurReg, 0,  4,    "8|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(INTC2GOVFSTAT      , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(INTC2GERRADDR      , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(INTC2GERRTYPE      , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(INTC2GSPIDERRCLR   , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(INTC2GSPIDERRSTAT  , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(INTC2GKCPROT       , mCurReg, 0,  4,      "32", "8|16|32");
    for(uint i = 0; i < emNUM_INTC2GMPID       ; i++) mCurReg = mRegArray[index++] = new SRegList(INTC2GMPID         [i], mCurReg, i,  4,    "8|32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(INTC2GPROT_GR      , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(INTC2GPROT_IMR     , mCurReg, 0,  4,      "32", "8|16|32");
    for(uint i = 0; i < mNumOfCh      ; i++) mCurReg = mRegArray[index++] = new SRegList(INTC2GPROT_        [mFactorIndexINTC2GPROT_      [i]], mCurReg, mFactorIndexINTC2GPROT_      [i],  4,      "32", "8|16|32");

    mRegList = mCurReg;

    (*INTC2GOVFCLR       ) ( 1,  1, "CLRO"    , 0x0       , "R|W1:0", vpcl::SPP_ENABLE);
    (*INTC2GOVFSTAT      ) ( 1,  1, "OVF"     , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*INTC2GERRADDR      ) (31,  0, "ADDR"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*INTC2GERRTYPE      ) (13, 13, "SEC"     , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*INTC2GERRTYPE      ) (12, 12, "DBG"     , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*INTC2GERRTYPE      ) (11, 11, "UM"      , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*INTC2GERRTYPE      ) (10,  6, "SPID"    , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*INTC2GERRTYPE      ) ( 0,  0, "WRITE"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*INTC2GSPIDERRCLR   ) (31,  0, "SPIDCLR" , 0x0       , "W1:0"  , vpcl::SPP_ENABLE);
    (*INTC2GSPIDERRSTAT  ) (31,  0, "SPIDERR" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*INTC2GKCPROT       ) (31,  1, "KCPROT"  , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*INTC2GKCPROT       ) ( 0,  0, "KCE"     , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*INTC2GPROT_GR      ) (31, 16, "MPID"    , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*INTC2GPROT_GR      ) ( 8,  8, "GEN"     , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*INTC2GPROT_GR      ) ( 6,  6, "DBG"     , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*INTC2GPROT_GR      ) ( 4,  4, "UM"      , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*INTC2GPROT_GR      ) ( 1,  1, "WG"      , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*INTC2GPROT_GR      ) ( 0,  0, "RG"      , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*INTC2GPROT_IMR     ) (31, 16, "MPID"    , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*INTC2GPROT_IMR     ) ( 8,  8, "GEN"     , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*INTC2GPROT_IMR     ) ( 6,  6, "DBG"     , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*INTC2GPROT_IMR     ) ( 4,  4, "UM"      , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*INTC2GPROT_IMR     ) ( 1,  1, "WG"      , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*INTC2GPROT_IMR     ) ( 0,  0, "RG"      , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    for(uint i = 0; i < emNUM_INTC2GMPID; i++) {
        (*INTC2GMPID         [i]) ( 4,  0, "SPID"    , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < mNumOfCh; i++) {
        (*INTC2GPROT_        [mFactorIndexINTC2GPROT_[i]]) (31, 16, "MPID"    , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
        (*INTC2GPROT_        [mFactorIndexINTC2GPROT_[i]]) ( 8,  8, "GEN"     , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
        (*INTC2GPROT_        [mFactorIndexINTC2GPROT_[i]]) ( 6,  6, "DBG"     , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
        (*INTC2GPROT_        [mFactorIndexINTC2GPROT_[i]]) ( 4,  4, "UM"      , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
        (*INTC2GPROT_        [mFactorIndexINTC2GPROT_[i]]) ( 1,  1, "WG"      , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
        (*INTC2GPROT_        [mFactorIndexINTC2GPROT_[i]]) ( 0,  0, "RG"      , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    }

    mFileName = "";
    mInstName = name;
    mLineNum = 0;
    mBusWidth = buswidth;
    mBusByteWidth = mBusWidth/8;   // using in BIG ENDIAN
    mIsReset = false;

    // Constructor the callback function of each register
    for (uint i = 0; i < mTotalRegNum; i++) {
        mWrCbAPI[mRegArray[i]->my_p->name()][mRegArray[i]->my_p->name()] = NULL;
        mRdCbAPI[mRegArray[i]->my_p->name()][mRegArray[i]->my_p->name()] = NULL;
    }

    //Constructor the mWrCbAPI, mRdCbAPI variable of each register
    mWrCbAPI["INTC2GOVFCLR"   ]["CLRO"           ] = &Cintc2g_u2_regif::cb_INTC2GOVFCLR_CLRO;
    mWrCbAPI["INTC2GSPIDERRCLR"]["SPIDCLR"        ] = &Cintc2g_u2_regif::cb_INTC2GSPIDERRCLR_SPIDCLR;
    mWrCbAPI["INTC2GKCPROT"   ]["KCPROT"         ] = &Cintc2g_u2_regif::cb_INTC2GKCPROT_KCPROT;
    mWrCbAPI["INTC2GPROT_GR"  ]["MPID"           ] = &Cintc2g_u2_regif::cb_INTC2GPROT_GR_MPID;
    mWrCbAPI["INTC2GPROT_IMR" ]["MPID"           ] = &Cintc2g_u2_regif::cb_INTC2GPROT_IMR_MPID;

    for(uint i = 0; i < emNUM_INTC2GMPID; i++) {
        str_tmp.str("");
        str_tmp<<"INTC2GMPID"<< i;
        mWrCbAPI[str_tmp.str()]["SPID"] = &Cintc2g_u2_regif::cb_INTC2GMPID_SPID;
        mRdCbAPI[str_tmp.str()]["SPID"] = &Cintc2g_u2_regif::cb_INTC2GMPID_SPID;
    }
    for(uint i = 0; i < mNumOfCh; i++) {
        str_tmp.str("");
        str_tmp<<"INTC2GPROT_"<< mFactorIndexINTC2GPROT_[i];
        mWrCbAPI[str_tmp.str()]["MPID"] = &Cintc2g_u2_regif::cb_INTC2GPROT__MPID;
    }
    InitLocalVal();
}

/// Destructor: delete pointers
/// @return none
Cintc2g_u2_regif::~Cintc2g_u2_regif()
{
    // Delete registers' pointer
    for (uint i = 0 ; i < mTotalRegNum ; i++) {
        delete mRegArray[i]->my_p;
        mRegArray[i]->prev = NULL;
    }
    delete [] mRegMap;
    delete [] mRegArray;
    delete mRegList;
    mCurReg = NULL;
}

/// Mask unselected bit
/// @return selected value
Cintc2g_u2_regif::uint Cintc2g_u2_regif::bit_select(
                              cuint val,    ///< [in] Writting address
                              cuint start,  ///< [in] start bit position
                              cuint end)    ///< [in] end bit position
{
    uint ret_val = val;
    if (end - start + 1 < 32) {
        ret_val = (val>>start) & (uint)((1<<(end-start+1))-1);
    }
    return ret_val;
}

/// Write the value to requested module register
/// @return true if writing transaction is finished normally
bool Cintc2g_u2_regif::reg_wr(cuint addr,                    ///< [in] Writting address
                              const unsigned char *p_data,   ///< [in] Writing data
                              cuint size)                    ///< [in] Data size (byte)
{
    if(size == 0) return false;
    #ifdef IS_MODELED_ENDIAN_BIG
    if ((addr % mBusByteWidth) + size > mBusByteWidth) return false;
    #endif

    bool ret_val = false;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(p_data != NULL);
    #else
    sc_assert(p_data != NULL);
    #endif
    ret_val = reg_wr_process (addr, p_data, size, false);
    return ret_val;
}

/// Read the register value of requested module
/// @return true if reading transaction is finished normally
bool Cintc2g_u2_regif::reg_rd(cuint addr,              ///< [in]  Reading address
                              unsigned char *p_data,   ///< [out] Reading data
                              cuint size)              ///< [in]  Data size (byte)
{
    if(size == 0) return false;
    #ifdef IS_MODELED_ENDIAN_BIG
    if ((addr % mBusByteWidth) + size > mBusByteWidth) return false;
    #endif

    bool ret_val = false;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(p_data != NULL);
    #else
    sc_assert(p_data != NULL);
    #endif
    ret_val = reg_rd_process (addr, p_data, size, false);
    return ret_val;
}

/// Write the value to requested module register
/// @return true if writing transaction is finished normally
bool Cintc2g_u2_regif::reg_wr_dbg(cuint addr,                    ///< [in] Writting address
                                  const unsigned char *p_data,   ///< [in] Writing data
                                  cuint size)                    ///< [in] Data size (byte)
{
    if(size == 0) return false;
    #ifdef IS_MODELED_ENDIAN_BIG
    if ((addr % mBusByteWidth) + size > mBusByteWidth) return false;
    #endif

    bool ret_val = false;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(p_data != NULL);
    #else
    sc_assert(p_data != NULL);
    #endif
    ret_val = reg_wr_process (addr, p_data, size, true);
    return ret_val;
}

/// Read the register value of requested module
/// @return true if reading transaction is finished normally
bool Cintc2g_u2_regif::reg_rd_dbg(cuint addr,              ///< [in]  Reading address
                                  unsigned char *p_data,   ///< [out] Reading data
                                  cuint size)              ///< [in]  Data size (byte)
{
    if(size == 0) return false;
    #ifdef IS_MODELED_ENDIAN_BIG
    if ((addr % mBusByteWidth) + size > mBusByteWidth) return false;
    #endif

    bool ret_val = false;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(p_data != NULL);
    #else
    sc_assert(p_data != NULL);
    #endif
    ret_val = reg_rd_process (addr, p_data, size, true);
    return ret_val;
}

/// Write the value to requested module register
/// @return true if writing transaction is finished normally
bool Cintc2g_u2_regif::reg_wr_process(cuint addr,                   ///< [in] Writting address
                                      const unsigned char *p_data,  ///< [in] Writing data
                                      cuint size,                   ///< [in] Data size (byte)
                                      bool IsDbgFunc)               ///< [in] flag indicate reg_rd or reg_rd_dbg
{
    if (mIsReset == true) {
        re_printf("warning", "Cannot write during reset period\n");
        return true;
    }
    uint tmp_addr = addr;
    #ifdef IS_MODELED_ENDIAN_BIG
    if (size < mBusByteWidth) {
        tmp_addr = addr ^ (mBusByteWidth - size);
    }
    #endif
    bool ret_val = false;
    bool valid_addr = false;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(p_data != NULL);
    #else
    sc_assert(p_data != NULL);
    #endif
    std::list<uint> list_index;
    uint masked_addr = bit_select(tmp_addr, 0, 14-1);
    uint access_addr = masked_addr;
    while (masked_addr + size > access_addr) {
        int reg_index = get_reg_index(access_addr);
        if (reg_index != -1) {
            vpcl::re_register *reg_p = mRegArray[reg_index]->my_p; 
            if ((IsDbgFunc == true) || (valid_addr == true) || (ChkSize(mRegArray[reg_index]->wacc_size, size, tmp_addr))) {
                valid_addr = true;
                list_index.push_back(reg_index);
            }
            else {
                re_printf("error", "Writing access size to %s at address 0x%08X is wrong: %d byte(s).\n", reg_p->name().c_str(), tmp_addr, size);
                return false;
            }
            access_addr = reg_p->addr() + mRegArray[reg_index]->length;
        } else {
            access_addr += 1;
        }
    }
    if (valid_addr == true) {
        std::list<uint>::iterator it;
        for (it=list_index.begin() ; it!=list_index.end() ; it++) {
            access_addr = masked_addr;
            uint d_size = size;
            uint index = 0;
            if (masked_addr < mRegArray[(*it)]->my_p->addr()) { // adjust access address & index
                access_addr = mRegArray[(*it)]->my_p->addr();
                index = mRegArray[(*it)]->my_p->addr() - masked_addr;
            }
            if ((masked_addr + size) < (mRegArray[(*it)]->my_p->addr() + mRegArray[(*it)]->length)) { // adjust access size
                d_size = masked_addr + size - access_addr;
            } else { // adjust access size
                d_size = (mRegArray[(*it)]->my_p->addr() + mRegArray[(*it)]->length) - access_addr;
            }
            if (size > mRegArray[(*it)]->length) { // adjust index for big endianess
                #ifdef IS_MODELED_ENDIAN_BIG
                index = index ^ (size - mRegArray[(*it)]->length);
                #endif
            }
            ret_val = reg_wr_func(tmp_addr - masked_addr + access_addr, &(p_data[index]), d_size, (*it), IsDbgFunc);
        }
    } else {
        if (IsDbgFunc == false) {
            re_printf("error", "Invalid access address 0x%08X\n", tmp_addr);
        } else {
            ret_val = true;
        }
    }
    return ret_val;
}

/// Read the register value of requested module
/// @return true if reading transaction is finished normally
bool Cintc2g_u2_regif::reg_rd_process(cuint addr,              ///< [in]  Reading address
                                      unsigned char *p_data,   ///< [out] Reading data
                                      cuint size,              ///< [in]  Data size (byte)
                                      bool IsDbgFunc)          ///< [in] flag indicate reg_rd or reg_rd_dbg
{
    uint tmp_addr = addr;
    #ifdef IS_MODELED_ENDIAN_BIG
    if (size < mBusByteWidth) {
        tmp_addr = addr ^ (mBusByteWidth - size);
    }
    #endif
    bool ret_val = false;
    bool valid_addr = false;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(p_data != NULL);
    #else
    sc_assert(p_data != NULL);
    #endif
    std::list<uint> list_index;
    uint masked_addr = bit_select(tmp_addr, 0, 14-1);
    uint access_addr = masked_addr;
    while (masked_addr + size > access_addr) {
        int reg_index = get_reg_index(access_addr);
        if (reg_index != -1) {
            vpcl::re_register *reg_p = mRegArray[reg_index]->my_p; 
            if ((IsDbgFunc == true) || (valid_addr == true) || (ChkSize(mRegArray[reg_index]->racc_size, size, tmp_addr))) {
                valid_addr = true;
                list_index.push_back(reg_index);
            }
            else {
                re_printf("error", "Reading access size to %s at address 0x%08X is wrong: %d byte(s).\n", reg_p->name().c_str(), tmp_addr, size);
                return false;
            }
            access_addr = reg_p->addr() + mRegArray[reg_index]->length;
        } else {
            access_addr += 1;
        }
    }
    if (valid_addr == true) {
        std::list<uint>::iterator it;
        for (it=list_index.begin() ; it!=list_index.end() ; it++) {
            access_addr = masked_addr;
            uint d_size = size;
            uint index = 0;
            if (masked_addr < mRegArray[(*it)]->my_p->addr()) { // adjust access address & index
                access_addr = mRegArray[(*it)]->my_p->addr();
                index = mRegArray[(*it)]->my_p->addr() - masked_addr;
            }
            if ((masked_addr + size) < (mRegArray[(*it)]->my_p->addr() + mRegArray[(*it)]->length)) { // adjust access size
                d_size = masked_addr + size - access_addr;
            } else { // adjust access size
                d_size = (mRegArray[(*it)]->my_p->addr() + mRegArray[(*it)]->length) - access_addr;
            }
            if (size > mRegArray[(*it)]->length) { // adjust index for big endianess
                #ifdef IS_MODELED_ENDIAN_BIG
                index = index ^ (size - mRegArray[(*it)]->length);
                #endif
            }
            ret_val = reg_rd_func(tmp_addr - masked_addr + access_addr, &(p_data[index]), d_size, (*it), IsDbgFunc);
        }
    } else {
        if (IsDbgFunc == false) {
            re_printf("error", "Invalid access address 0x%08X\n", tmp_addr);
        } else {
            memset(p_data, 0, size);
            ret_val = true;
        }
    }
    return ret_val;
}

/// Process reading function
/// @return true if reading successfully
bool Cintc2g_u2_regif::reg_rd_func(cuint addr,                     ///< [in]  Reading address
                                   unsigned char *p_data,          ///< [out] Reading data
                                   cuint size,                     ///< [in]  Data size (byte)
                                   cuint reg_index,                ///< [in] Register index
                                   bool IsDbgFunc)                 ///< [in] flag indicate reg_rd or reg_rd_dbg
{
    vpcl::re_register* Register = mRegArray[reg_index]->my_p;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(Register != NULL);
    #else
    sc_assert(Register != NULL);
    #endif
    uint pre_data = 0;
    uint pst_data = 0;
    #if 1 // always 1 since any size can be accessed in debug mode 
    uint reg_length = mRegArray[reg_index]->length;
    uint start_pos = 0;
    uint mask_size = (1 << (reg_length/2)) - 1;
    if (size < reg_length) {
        #ifdef IS_MODELED_ENDIAN_BIG
        start_pos =  (reg_length - 1)*8 - (addr & mask_size)*8; // Start bit position
        #else
        start_pos =  (addr & mask_size)*8;  // Start bit position
        #endif
    }
    #endif
    if (IsDbgFunc == false) {
        if (mIsReset == true) {
            re_printf("warning", "Cannot launch call-back function during reset period\n");
        }else {
            #if 1 // always 1 since any size can be accessed in debug mode 
            if (size < reg_length) {
                re_printf("warning","Should read all bit in a register\n");
            }
            #endif
            pre_data = (uint)(*Register);
            pst_data = Register->read();
                        for (vpcl::bit_info *it=Register->mBitInfo ; it!=NULL ; it=it->next) {
                if (((mRdCbAPI[Register->name()][it->name()]) != NULL)
                && (((start_pos < it->mStartAddr) && (it->mEndAddr < start_pos + size * 8))
                 || ((it->mStartAddr <= start_pos) && (start_pos <= it->mEndAddr))
                 || ((it->mStartAddr <= start_pos + size * 8) && (start_pos + size * 8 <= it->mEndAddr)) )) {
                    (this->*(mRdCbAPI[Register->name()][it->name()]))(RegCBstr(mRegArray[reg_index]->channel, false, size, pre_data, pst_data));
                }
            }
        }
    }
    pst_data = (uint)(*Register);
    #if 1 // always 1 since any size can be accessed in debug mode 
    if (size < reg_length) {
        uint read_data = 0;
        if (((reg_length%2 == 0) && (reg_length%size == 0) && ((addr&mask_size)%size == 0)) 
         || (IsDbgFunc == false)) {
            for (uint i = start_pos; i < (8*size + start_pos); i++) {
                read_data |= (pst_data & (1 << i)) >> start_pos;
            }
            pst_data = read_data;
        }
    }
    #endif

    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(p_data != NULL);
    #else
    sc_assert(p_data != NULL);
    #endif
    memcpy(p_data, &pst_data, size);
    DumpRegMsg("R", Register->name(), "", size, addr, 0, 0, pst_data, mRegArray[reg_index]->length*8);
    for (vpcl::bit_info *it=Register->mBitInfo ; it!=NULL ; it=it->next) {
        uint val = (uint)(*Register);
        val = bit_select(val, it->mStartAddr, it->mEndAddr);
        DumpRegMsg("R", Register->name(), it->name(), size, addr, 0, 0, val, it->mEndAddr - it->mStartAddr + 1);
    }
    return true;
}

/// Process writing function
/// @return true if writing successfully
bool Cintc2g_u2_regif::reg_wr_func(cuint addr,                       ///< [in] Writting address
                                   const unsigned char *p_data,      ///< [in] Writing data
                                   cuint size,                       ///< [in] Data size (byte)
                                   cuint reg_index,                  ///< [in] Register index
                                   bool IsDbgFunc)                   ///< [in] flag indicate reg_wr or reg_wr_dbg
{
    vpcl::re_register* Register = mRegArray[reg_index]->my_p;
    uint pre_data = 0;
    uint data = 0;
    #if 1 // always 1 since any size can be accessed in debug mode 
    uint reg_length = mRegArray[reg_index]->length;
    uint start_pos = 0;
    #endif
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert ((p_data != NULL) && (Register != NULL));
    #else
    sc_assert ((p_data != NULL) && (Register != NULL));
    #endif
    memcpy(&data, p_data, size);
    #if 1 // always 1 since any size can be accessed in debug mode 
    if (size < reg_length) {
        uint mask_size = (1 << (reg_length/2)) - 1;
        if (((reg_length%2 == 0) && (reg_length%size == 0) && ((addr&mask_size)%size == 0)) 
         || (IsDbgFunc == false)) {
            uint new_data = (uint)(*Register);  // For writing to register
            uint written_data = 0;         // For transferring to callback function
            #ifdef IS_MODELED_ENDIAN_BIG
            start_pos =  (reg_length - 1)*8 - (addr & mask_size)*8; // Start bit position
            #else
            start_pos =  (addr & mask_size)*8;  // Start bit position
            #endif
            for (uint i = start_pos; i < (8*size + start_pos); i++) {
                new_data = (new_data & (~(1 << i))) | ((data << start_pos) & (1 << i));
                written_data = (written_data & (~(1 << i))) | ((data << start_pos) & (1 << i));
            }
            data = new_data;
        }
    }
    #endif

    if ((mRegArray[reg_index]->block == false) || (IsDbgFunc == true)){
        pre_data = (uint)(*Register);
        if (IsDbgFunc == true) {
            bool backup_warning = Register->mMessageLevel["warning"];
            bool backup_error = Register->mMessageLevel["error"];
            Register->mMessageLevel["warning"]   = false;
            Register->mMessageLevel["error"]   = false;

            Register->write(data);

            Register->mMessageLevel["warning"]   = backup_warning;
            Register->mMessageLevel["error"]   = backup_error;
        } else {
            Register->write(data);
        }
        UpdateLocalVal(Register->addr());
        DumpRegMsg("W", Register->name(), "", size, addr, data, pre_data, (uint)(*Register), mRegArray[reg_index]->length*8);
        for (vpcl::bit_info *it=Register->mBitInfo ; it!=NULL ; it=it->next) {
            uint val = (uint)(*Register);
            val = bit_select(val, it->mStartAddr, it->mEndAddr);
            uint pre_val = pre_data;
            pre_val = bit_select(pre_val, it->mStartAddr, it->mEndAddr);
            DumpRegMsg("W", Register->name(), it->name(), size, addr, 0, pre_val, val, it->mEndAddr - it->mStartAddr + 1);
            if ((mWrCbAPI[Register->name()][it->name()]) != NULL) {
                (this->*(mWrCbAPI[Register->name()][it->name()]))(RegCBstr(mRegArray[reg_index]->channel, true, size, pre_data, data));
            }
        }
    }
    else {
        re_printf("warning","%s is blocked writing from Bus I/F.\n", Register->name().c_str());
    }
    return true;
}

/// Check access size
/// @@return true if detect_size equal expect_size
bool Cintc2g_u2_regif::ChkSize(std::string expect_size, cuint detect_size, cuint addr)
{
    std::vector<std::string> arg_vec = Str2Vec(expect_size, '|');
    std::vector<std::string>::iterator it;
    char *err_p = NULL;
    uint size = 0;
    if (detect_size > mBusByteWidth) {
        re_printf("error", "Invalid access size: %d bytes\n", detect_size);
        return false;
    }
    if(addr%detect_size != 0) {
        re_printf("error", "Invalid access address 0x%08X with access size %d bytes\n", addr, detect_size);
        return false;
    }
    for (it = arg_vec.begin(); it != arg_vec.end(); it++) {
        errno = 0; size = (uint) strtoul((*it).c_str(), &err_p, 0);
        #ifdef REGIF_NOT_USE_SYSTEMC
        assert(err_p != NULL);
        #else
        sc_assert(err_p != NULL);
        #endif
        if (errno != ERANGE && *err_p == '\0') {
            if ((size/8) == detect_size) {
                return true;
            }
        }
    }
    return false;
}

/// Initialize reg_handle_command variables
/// @return none
void Cintc2g_u2_regif::CommandInit()
{
    mDumpRegisterRW = false;
    mMessageLevel["fatal"]   = true;
    mMessageLevel["error"]   = true;
    mMessageLevel["warning"] = false;
    mMessageLevel["info"]    = false;
}

/// Process reg_handle_command command
/// @return string
std::string Cintc2g_u2_regif::reg_handle_command(const std::vector<std::string>& args)
{
    std::string ret = "";
    std::string err_msg = "Error ("   + mInstName + ") ";   // error message
    if (args[0] == "reg") {
        if (args[1] == "help") {
            ret += "    --- reg ---\n";
            ret += "    reg MessageLevel <fatal|error|warning|info> Select debug message level (Default: fatal,error)\n";
            ret += "    reg DumpRegisterRW <true/false>             Select dump register access information  (Default: false)\n";
            ret += "    reg <register_name> MessageLevel <fatal|error|warning|info> Select debug message level for register (Default: fatal,error)\n";
            ret += "    reg <register_name> force <value>           Force register with setting value\n";
            ret += "    reg <register_name> release                 Release register from force value\n";
            ret += "    reg <register_name> <value>                 Write a value into register\n";
            ret += "    reg <register_name>                         Read value of register\n";
            ret += "    reg help                                    Show a direction\n";
        }
        else if (args[1] == "DumpRegisterRW") {
            if (args.size() == 2) {
                if(mDumpRegisterRW ==true){
                    ret = "true";
                }
                else{
                    ret = "false";
                }
            }
            else if (args.size() == 3) {
                if (args[2] == "true") {
                    mDumpRegisterRW = true;
                }
                else if (args[2] == "false") {
                    mDumpRegisterRW = false;
                } else {
                    ret = err_msg + "DumpRegisterRW command needs an argument [true/false]\n";
                }
            } else {
                ret = err_msg + "DumpRegisterRW has too much arguments\n";
            }
        }
        else if (args[1] == "MessageLevel") {
            // read mode
            if (args.size() == 2) {
                std::map<std::string, bool>::iterator it;
                for (it = mMessageLevel.begin(); it != mMessageLevel.end(); it++) {
                    if ( it->second == true ) {
                        ret += " " + it->first;
                    }
                }
            // write mode
            } else if (args.size() == 3) {
                std::vector<std::string> arg_vec = Str2Vec(args[2], '|');
                std::map<std::string, bool>::iterator msgit;
                for (msgit =mMessageLevel.begin(); msgit != mMessageLevel.end(); msgit++) {
                    msgit->second = false;
                }
                std::vector<std::string>::iterator it;
                for (it = arg_vec.begin(); it != arg_vec.end(); it++) {
                    mMessageLevel[*it] = true;
                }
            } else {
                ret = err_msg + "MessageLevel has too much arguments\n";
            }
        } else {
            bool matched = false;
            for (uint i = 0; i < mTotalRegNum; i++) {
                if (args[1] == mRegArray[i]->my_p->name()) {
                    ret = AccessRegCommand(args, mRegArray[i]->my_p, mRegArray[i]->block);
                    matched = true;
                    break;
                }
            }
            if (!matched) {
                ret = err_msg + "Register name " + (std::string)args[1] + " is invalid\n";
            }
        }
    }
    return ret;
}

/// process reg_handle_command of "reg" parameter
/// @return string
std::string Cintc2g_u2_regif::AccessRegCommand(const std::vector<std::string>& args, vpcl::re_register *Register, bool &BlockReg)
{
    std::string ret = "";
    char *err_p = NULL;
    std::string err_msg = "Error ("   + mInstName + ") ";   // error message
    uint data = 0;
    std::ostringstream str_tmp;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(Register != NULL);
    #else
    sc_assert(Register != NULL);
    #endif
    if (args.size() == 2) {
        data = (uint)(*Register);
        str_tmp<<std::setw(14)<<std::left<<(Register->name());
        str_tmp<<"0x"<<std::setw(8)<<std::hex<<std::uppercase<<std::left<<data<<"\n";
        ret = str_tmp.str();
    } else if ((args.size() == 3) && (args[2] == "release")) {
        BlockReg = false;
    } else if ((args.size() == 4) && (args[2] == "force")) {
        errno = 0; data = (uint) strtoul(args[3].c_str(), &err_p, 0);
        #ifdef REGIF_NOT_USE_SYSTEMC
        assert(err_p != NULL);
        #else
        sc_assert(err_p != NULL);
        #endif
        if (errno != ERANGE && *err_p == '\0') {
            *Register = data;
            BlockReg = true;
            UpdateLocalVal(Register->addr());
        } else {
            ret = err_msg + "[" + Register->name() + "] Invalid force value\n";
        }
    } else if ((args.size() >= 3) && (args[2] == "MessageLevel")) {
        if (args.size() == 3) {
            ret = Register->name() + " ";
            ret += Register->GetMessageLevel();
        } else if (args.size() == 4) {
            std::map<std::string, bool> MessageLevel;
            std::vector<std::string> arg_vec = Str2Vec(args[3], '|');
            std::vector<std::string>::iterator it;
            for (it = arg_vec.begin(); it != arg_vec.end(); it++) {
                MessageLevel[*it] = true;
            }
            Register->SetMessageLevel(MessageLevel);
        } else {
            ret = err_msg + "[" + Register->name() + "] MessageLevel has too much arguments\n";
        }
    } else if ((args.size() == 3) && (args[2] != "release")) {
        errno = 0; data = (uint) strtoul(args[2].c_str(), &err_p, 0);
        if (errno != ERANGE && *err_p == '\0') {
            *Register = data;
            UpdateLocalVal(Register->addr());
        } else {
            ret = err_msg + "[" + Register->name() + "] Invalid write value\n";
        }
    } else {
        ret = err_msg + "Wrong command : ";
        for (uint index = 0; index < args.size(); index ++) {
            ret += args[index] + " ";
        }
    }
    return ret;
}

/// Initialize local variables
/// @return none
void Cintc2g_u2_regif::InitLocalVal()
{
    // Initialize local variables
    INTC2GOVFCLR_CLRO = 0x0;
    INTC2GOVFSTAT_OVF = 0x0;
    INTC2GERRADDR_ADDR = 0x0;
    INTC2GERRTYPE_SEC = 0x0;
    INTC2GERRTYPE_DBG = 0x0;
    INTC2GERRTYPE_UM  = 0x0;
    INTC2GERRTYPE_SPID = 0x0;
    INTC2GERRTYPE_WRITE = 0x0;
    INTC2GSPIDERRCLR_SPIDCLR = 0x0;
    INTC2GSPIDERRSTAT_SPIDERR = 0x0;
    INTC2GKCPROT_KCPROT = 0x0;
    INTC2GKCPROT_KCE  = 0x0;
    for(uint i = 0; i < emNUM_INTC2GMPID;       i++) {
        INTC2GMPID_SPID  [i] = 0x0;
    }
    INTC2GPROT_GR_MPID = 0x0;
    INTC2GPROT_GR_GEN = 0x0;
    INTC2GPROT_GR_DBG = 0x0;
    INTC2GPROT_GR_UM  = 0x0;
    INTC2GPROT_GR_WG  = 0x0;
    INTC2GPROT_GR_RG  = 0x0;
    INTC2GPROT_IMR_MPID = 0x0;
    INTC2GPROT_IMR_GEN = 0x0;
    INTC2GPROT_IMR_DBG = 0x0;
    INTC2GPROT_IMR_UM = 0x0;
    INTC2GPROT_IMR_WG = 0x0;
    INTC2GPROT_IMR_RG = 0x0;
    for(uint i = 0; i < mNumOfCh;      i++) {
        INTC2GPROT__MPID [mFactorIndexINTC2GPROT_[i]] = 0x0;
        INTC2GPROT__GEN  [mFactorIndexINTC2GPROT_[i]] = 0x0;
        INTC2GPROT__DBG  [mFactorIndexINTC2GPROT_[i]] = 0x0;
        INTC2GPROT__UM   [mFactorIndexINTC2GPROT_[i]] = 0x0;
        INTC2GPROT__WG   [mFactorIndexINTC2GPROT_[i]] = 0x0;
        INTC2GPROT__RG   [mFactorIndexINTC2GPROT_[i]] = 0x0;
    }
}

/// Update bit value to local value
/// @return None
void Cintc2g_u2_regif::UpdateLocalVal(cuint addr)
{
    if (addr == 0x0000) {
        INTC2GOVFCLR_CLRO                     = (*INTC2GOVFCLR     )["CLRO"             ];
        return;
    }
    if (addr == 0x0004) {
        INTC2GOVFSTAT_OVF                     = (*INTC2GOVFSTAT    )["OVF"              ];
        return;
    }
    if (addr == 0x0008) {
        INTC2GERRADDR_ADDR                    = (*INTC2GERRADDR    )["ADDR"             ];
        return;
    }
    if (addr == 0x000C) {
        INTC2GERRTYPE_SEC                     = (*INTC2GERRTYPE    )["SEC"              ];
        INTC2GERRTYPE_DBG                     = (*INTC2GERRTYPE    )["DBG"              ];
        INTC2GERRTYPE_UM                      = (*INTC2GERRTYPE    )["UM"               ];
        INTC2GERRTYPE_SPID                    = (*INTC2GERRTYPE    )["SPID"             ];
        INTC2GERRTYPE_WRITE                   = (*INTC2GERRTYPE    )["WRITE"            ];
        return;
    }
    if (addr == 0x0010) {
        INTC2GSPIDERRCLR_SPIDCLR              = (*INTC2GSPIDERRCLR )["SPIDCLR"          ];
        return;
    }
    if (addr == 0x0014) {
        INTC2GSPIDERRSTAT_SPIDERR             = (*INTC2GSPIDERRSTAT)["SPIDERR"          ];
        return;
    }
    if (addr == 0x0018) {
        INTC2GKCPROT_KCPROT                   = (*INTC2GKCPROT     )["KCPROT"           ];
        INTC2GKCPROT_KCE                      = (*INTC2GKCPROT     )["KCE"              ];
        return;
    }
    if ((0x0040 <= addr) && (addr <= (0x0040)+(4*15)) && ((addr-0x0040)%4 == 0)) {
        uint i = (addr - 0x0040)/4;
        INTC2GMPID_SPID                      [i] = (*(INTC2GMPID       [i]))["SPID"             ];
        return;
    }
    if (addr == 0x00F0) {
        INTC2GPROT_GR_MPID                    = (*INTC2GPROT_GR    )["MPID"             ];
        INTC2GPROT_GR_GEN                     = (*INTC2GPROT_GR    )["GEN"              ];
        INTC2GPROT_GR_DBG                     = (*INTC2GPROT_GR    )["DBG"              ];
        INTC2GPROT_GR_UM                      = (*INTC2GPROT_GR    )["UM"               ];
        INTC2GPROT_GR_WG                      = (*INTC2GPROT_GR    )["WG"               ];
        INTC2GPROT_GR_RG                      = (*INTC2GPROT_GR    )["RG"               ];
        return;
    }
    if (addr == 0x00F4) {
        INTC2GPROT_IMR_MPID                   = (*INTC2GPROT_IMR   )["MPID"             ];
        INTC2GPROT_IMR_GEN                    = (*INTC2GPROT_IMR   )["GEN"              ];
        INTC2GPROT_IMR_DBG                    = (*INTC2GPROT_IMR   )["DBG"              ];
        INTC2GPROT_IMR_UM                     = (*INTC2GPROT_IMR   )["UM"               ];
        INTC2GPROT_IMR_WG                     = (*INTC2GPROT_IMR   )["WG"               ];
        INTC2GPROT_IMR_RG                     = (*INTC2GPROT_IMR   )["RG"               ];
        return;
    }
    if (((0x0100 +(4*32)) <= addr) && (addr <= (0x0100+(4*2047))) && ((addr-(0x0100 +(4*32)))%4 == 0)) {
        uint i = (addr - (0x0100 +(4*32)))/4 + 32;
        INTC2GPROT__MPID                     [i] = (*(INTC2GPROT_      [i]))["MPID"             ];
        INTC2GPROT__GEN                      [i] = (*(INTC2GPROT_      [i]))["GEN"              ];
        INTC2GPROT__DBG                      [i] = (*(INTC2GPROT_      [i]))["DBG"              ];
        INTC2GPROT__UM                       [i] = (*(INTC2GPROT_      [i]))["UM"               ];
        INTC2GPROT__WG                       [i] = (*(INTC2GPROT_      [i]))["WG"               ];
        INTC2GPROT__RG                       [i] = (*(INTC2GPROT_      [i]))["RG"               ];
        return;
    }
}

/// Update local value to bit value
/// @return None
void Cintc2g_u2_regif::UpdateRegVal(cuint addr)
{
    if (addr == 0x0000) {
        (*INTC2GOVFCLR     )["CLRO"             ] = INTC2GOVFCLR_CLRO;
        return;
    }
    if (addr == 0x0004) {
        (*INTC2GOVFSTAT    )["OVF"              ] = INTC2GOVFSTAT_OVF;
        return;
    }
    if (addr == 0x0008) {
        (*INTC2GERRADDR    )["ADDR"             ] = INTC2GERRADDR_ADDR;
        return;
    }
    if (addr == 0x000C) {
        (*INTC2GERRTYPE    )["SEC"              ] = INTC2GERRTYPE_SEC;
        (*INTC2GERRTYPE    )["DBG"              ] = INTC2GERRTYPE_DBG;
        (*INTC2GERRTYPE    )["UM"               ] = INTC2GERRTYPE_UM;
        (*INTC2GERRTYPE    )["SPID"             ] = INTC2GERRTYPE_SPID;
        (*INTC2GERRTYPE    )["WRITE"            ] = INTC2GERRTYPE_WRITE;
        return;
    }
    if (addr == 0x0010) {
        (*INTC2GSPIDERRCLR )["SPIDCLR"          ] = INTC2GSPIDERRCLR_SPIDCLR;
        return;
    }
    if (addr == 0x0014) {
        (*INTC2GSPIDERRSTAT)["SPIDERR"          ] = INTC2GSPIDERRSTAT_SPIDERR;
        return;
    }
    if (addr == 0x0018) {
        (*INTC2GKCPROT     )["KCPROT"           ] = INTC2GKCPROT_KCPROT;
        (*INTC2GKCPROT     )["KCE"              ] = INTC2GKCPROT_KCE;
        return;
    }
    if ((0x0040 <= addr) && (addr <= (0x0040)+(4*15)) && ((addr-0x0040)%4 == 0)) {
        uint i = (addr - 0x0040)/4;
        (*(INTC2GMPID       [i]))["SPID"             ] = INTC2GMPID_SPID[i];
        return;
    }
    if (addr == 0x00F0) {
        (*INTC2GPROT_GR    )["MPID"             ] = INTC2GPROT_GR_MPID;
        (*INTC2GPROT_GR    )["GEN"              ] = INTC2GPROT_GR_GEN;
        (*INTC2GPROT_GR    )["DBG"              ] = INTC2GPROT_GR_DBG;
        (*INTC2GPROT_GR    )["UM"               ] = INTC2GPROT_GR_UM;
        (*INTC2GPROT_GR    )["WG"               ] = INTC2GPROT_GR_WG;
        (*INTC2GPROT_GR    )["RG"               ] = INTC2GPROT_GR_RG;
        return;
    }
    if (addr == 0x00F4) {
        (*INTC2GPROT_IMR   )["MPID"             ] = INTC2GPROT_IMR_MPID;
        (*INTC2GPROT_IMR   )["GEN"              ] = INTC2GPROT_IMR_GEN;
        (*INTC2GPROT_IMR   )["DBG"              ] = INTC2GPROT_IMR_DBG;
        (*INTC2GPROT_IMR   )["UM"               ] = INTC2GPROT_IMR_UM;
        (*INTC2GPROT_IMR   )["WG"               ] = INTC2GPROT_IMR_WG;
        (*INTC2GPROT_IMR   )["RG"               ] = INTC2GPROT_IMR_RG;
        return;
    }
    if (((0x0100 +(4*32)) <= addr) && (addr <= (0x0100)+(4*2047)) && ((addr-(0x0100 +(4*32)))%4 == 0)) {
        uint i = (addr - (0x0100+(4*32)))/4 + 32;
        (*(INTC2GPROT_      [i]))["MPID"             ] = INTC2GPROT__MPID[i];
        (*(INTC2GPROT_      [i]))["GEN"              ] = INTC2GPROT__GEN[i];
        (*(INTC2GPROT_      [i]))["DBG"              ] = INTC2GPROT__DBG[i];
        (*(INTC2GPROT_      [i]))["UM"               ] = INTC2GPROT__UM[i];
        (*(INTC2GPROT_      [i]))["WG"               ] = INTC2GPROT__WG[i];
        (*(INTC2GPROT_      [i]))["RG"               ] = INTC2GPROT__RG[i];
        return;
    }
}

/// convert string to vector
/// @return vector
std::vector<std::string> Cintc2g_u2_regif::Str2Vec(std::string str, const char sep)
{
    std::vector<std::string> buf;
    std::string::size_type index = 0;
    for (uint i=0 ; i<str.size() ; i++) {
        if (str[i] == sep) {
            buf.push_back(str.substr(index, i-index));
            index = i+1;
        }
    }
    buf.push_back(str.substr(index));
    return buf;
}

/// Align nuber to hexadecimal format
/// @return aligned number
std::string Cintc2g_u2_regif::Num2HexStr(cuint num, cuint num_length, bool space_strip)
{
    std::ostringstream str_tmp;
    #ifdef MSG_WO_WR_DATA
    str_tmp<<"0x"<<std::hex<<std::uppercase<<std::right<<num;
    str_tmp<<std::setfill(' ')<<std::setw(10-str_tmp.str().length())<<"";
    #else
    uint total_length = (num_length + 3)/4; // Calculate number of hexadecimal number
    str_tmp<<"0x"<<std::setfill('0')<<std::setw(total_length)<<std::hex<<std::uppercase<<std::right<<num;
    if (!space_strip) {
        str_tmp<<std::setfill(' ')<<std::setw(10-str_tmp.str().length())<<"";   
    }
    #endif
    return str_tmp.str();
}

/// Dump register access information
/// @return none
void Cintc2g_u2_regif::DumpRegMsg(const std::string operation, const std::string RegName, const std::string BitName, cuint size, cuint addr, cuint wr_data, cuint pre_data, cuint data, cuint reg_length)
{
    if(mDumpRegisterRW == true) {
        std::string reg_name = RegName;
        std::ostringstream str_tmp;
        if (BitName != "") {
            reg_name += ":" + BitName;
        }
        str_tmp<<"REG ["<<std::setw(15)<<std::left<<reg_name<<"] ";
        str_tmp<<operation;
        str_tmp<<" Size= "<<size;
        str_tmp<<" Addr= "<<Num2HexStr(addr,14, false);
        if (operation == "R") {
            str_tmp<<" Data= "<<Num2HexStr(data    , reg_length, true);
        } else {
            #ifdef MSG_WO_WR_DATA
            str_tmp<<" Data= "<<Num2HexStr(pre_data, reg_length, false);
            #else
            str_tmp<<" Data= "<<Num2HexStr(wr_data , reg_length, false);
            str_tmp<<" : "    <<Num2HexStr(pre_data, reg_length, false);
            #endif
            str_tmp<<" => "   <<Num2HexStr(data    , reg_length, true);
        }
        re_printf("DumpRegMsg", "%s\n", str_tmp.str().c_str());
    }
}

/// find register pointer based on accessed address
/// @return accessed register pointer
int Cintc2g_u2_regif::get_reg_index(cuint access_addr)
{
    if (mRegMap[access_addr] != (1<<14)) {
        return mRegMap[access_addr];
    } else {
        return -1;
    }
}

/// find first register pointer
/// @return first register pointer
vpcl::re_register *Cintc2g_u2_regif::first_reg_object()
{
    mCurReg = mRegList;
    return mCurReg->my_p;
}

/// find next register pointer
/// @return next register pointer
vpcl::re_register *Cintc2g_u2_regif::next_reg_object()
{
    if (mCurReg != NULL) {
        mCurReg = mCurReg->prev;
        if (mCurReg != NULL) {
            return mCurReg->my_p;
        }
    }
    return NULL;
}

/// write callback function of CoWare
/// @return none
void Cintc2g_u2_regif::wr_cb(cuint addr, uint data)
{
    #ifdef USR_CWR_SYSTEMC
    cwmem.put(data, addr&0xFFFF);
    #else
    array[addr&0xFFFF] = data;
    #endif
}

/// read callback function of CoWare
/// @return read data
Cintc2g_u2_regif::uint Cintc2g_u2_regif::rd_cb(cuint addr)
{
    #ifdef USR_CWR_SYSTEMC
    return cwmem.get(addr&0xFFFF);
    #else
    return array[addr&0xFFFF];
    #endif
}

/// print message function
/// @return none
void Cintc2g_u2_regif::_re_printf(std::string group, const char *message, ...)
{
    // message group check
    if (group == "DumpRegMsg") {
        group = "info";
    } else {
        #ifndef REGIF_SC_REPORT
        if (mMessageLevel[group] == false) return;
        #endif//REGIF_SC_REPORT
    }

    if (message == NULL) return;

    // print header
    #ifndef REGIF_NOT_USE_SYSTEMC
    std::stringstream t_stream;
    std::string cur_time;

    double tu_value = 0;
    std::string tu_name = "";
    if (sc_get_time_resolution() < sc_time(1, SC_PS)) {
        tu_value = 1000000000000000LL;
        tu_name = " fs";
    }
    else if (sc_get_time_resolution() < sc_time(1, SC_NS)) {
        tu_value = 1000000000000LL;
        tu_name = " ps";
    }
    else if (sc_get_time_resolution() < sc_time(1, SC_US)) {
        tu_value = 1000000000;
        tu_name = " ns";
    }
    else if (sc_get_time_resolution() < sc_time(1, SC_MS)) {
        tu_value = 1000000;
        tu_name = " us";
    }
    else if (sc_get_time_resolution() < sc_time(1, SC_SEC)) {
        tu_value = 1000;
        tu_name = " ms";
    }
    else {
        tu_value = 1;
        tu_name = " s";
    }
    t_stream << sc_time_stamp().value() * (uint64) (sc_get_time_resolution().to_seconds() * tu_value) << tu_name;

    cur_time = t_stream.str();
    #else
    std::string cur_time = "";
    #endif

    #ifndef REGIF_SC_REPORT
    #ifdef MSG_COLOR
    // color setting
    //
    // severity color       color Linux       Windows
    // fatal    RED         RED   \033[0;31m  FOREGROUND_RED
    // error    RED         BLUE  \033[0;34m  FOREGROUND_BLUE
    // warning  RED
    // info     BLUE
    #ifdef _WIN32
    HANDLE hStdout;
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    if (group == "fatal" || group == "error" || group == "warning") {
        SetConsoleTextAttribute(hStdout, FOREGROUND_RED);
    }
    else if (group == "info" ){
        SetConsoleTextAttribute(hStdout, FOREGROUND_BLUE);
    }
    #else
    if (group == "fatal" || group == "error" || group == "warning") {
        printf("\033[0;31m");
    }
    else if (group == "info" ){
        printf("\033[0;34m");
    }
    #endif
    #endif //MSG_COLOR
    printf("%8s [%20s] (%10s) ", group.c_str(), cur_time.c_str(), mInstName.c_str());
    #endif//REGIF_SC_REPORT

    // print body
    va_list argptr;
    va_start(argptr, message);
    if (argptr == NULL) return;
    #ifdef REGIF_SC_REPORT
    char str[1024];
    sprintf(str, "[%20s] ", cur_time.c_str());
    vsprintf(str+23, message, argptr);
    if (group == "fatal") {
        SC_REPORT_FATAL(mInstName.c_str(), str);
    }
    else if (group == "error") {
        SC_REPORT_ERROR(mInstName.c_str(), str);
    }
    else if (group == "warning") {
        SC_REPORT_WARNING(mInstName.c_str(), str);
    }
    else if (group == "info") {
        SC_REPORT_INFO(mInstName.c_str(), str);
    }
    #else //REGIF_SC_REPORT
    vprintf(message, argptr);
    #endif//REGIF_SC_REPORT

    #ifndef REGIF_SC_REPORT
    #ifdef DumpFileNameLineNum
    // print footer
    if (group == "fatal" || group == "error") {
        printf(" [%s:%d]\n", mFileName.c_str(), mLineNum);
    }
    #endif//DumpFileNameLineNum
    #endif//REGIF_SC_REPORT
    va_end(argptr);

    #ifndef REGIF_SC_REPORT
    #ifdef MSG_COLOR
    #ifdef _WIN32
    SetConsoleTextAttribute(hStdout, csbi.wAttributes);
    #else
    printf("\033[m");
    #endif
    #endif //MSG_COLOR
    #endif//REGIF_SC_REPORT

    fflush(stdout);
    fflush(stderr);

    if (group == "fatal") {
        exit(1);
    }
}

/// Get file name and line number
/// @return none
void Cintc2g_u2_regif::get_fileline(std::string filename, int line_number)
{
    mFileName = filename;
    mLineNum  = line_number;
}

/// API for instance registration
/// @return none
void Cintc2g_u2_regif::set_instance_name(std::string InstName)
{
    mInstName = InstName;
}

/// Method to change value of mIsReset
/// @return none
void Cintc2g_u2_regif::EnableReset(const bool is_active)
{
    // update register IF class's reset status
    mIsReset = is_active;

    // update re_register's reset status
    for (uint i = 0; i < mTotalRegNum; i++) {
        mRegArray[i]->my_p->EnableReset(is_active);
        if (is_active) {
            re_printf("info", "Initialize %s (%08x)\n", mRegArray[i]->my_p->name().c_str(), (uint)(*mRegArray[i]->my_p));
        }
    }

    if(is_active) {
        InitLocalVal(); // Initialize local variable
    }
}

#ifdef USR_CWR_SYSTEMC
uint Cintc2g_u2_regif::cw_rd_cb(tlm::tlm_generic_payload& trans, int tag)
{
    unsigned char* ptr = (unsigned char*)trans.get_data_ptr();
    memset(ptr,0,sizeof(uint));
    reg_rd_dbg((cuint)tag, ptr, sizeof(uint));
    return sizeof(uint);
}

uint Cintc2g_u2_regif::cw_wr_cb(tlm::tlm_generic_payload& trans, int tag)
{
    unsigned char* ptr = (unsigned char*)trans.get_data_ptr();
    reg_wr_dbg((cuint)tag, ptr, sizeof(uint));
    return sizeof(uint);
}
void Cintc2g_u2_regif::cw_instantiate_reg(scml2::reg<uint> * reg, std::string reg_name, int offset)
{
    reg = new scml2::reg<uint>(reg_name, cwmem, offset/sizeof(uint));
    scml2::set_debug_write_callback(*reg,SCML2_CALLBACK(cw_wr_cb),offset);
    scml2::set_debug_read_callback(*reg,SCML2_CALLBACK(cw_rd_cb),offset);
}
#endif
