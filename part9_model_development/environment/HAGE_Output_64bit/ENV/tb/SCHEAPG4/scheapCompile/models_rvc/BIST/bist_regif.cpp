// -----------------------------------------------------------------------------
// $Id$
//
// Copyright(c) 2010-2013 Renesas Electronics Corporation
// Copyright(c) 2010-2013 Renesas Design Vietnam Co., Ltd.
// RENESAS ELECTRONICS CONFIDENTIAL AND PROPRIETARY.
// This program must be used solely for the purpose for which
// it was furnished by Renesas Electronics Corporation. No part of this
// program may be reproduced or disclosed to others, in any
// form, without the prior written permission of Renesas Electronics
// Corporation.
// -----------------------------------------------------------------------------
// This file is generated by Register I/F generator
//    gen_regif.py 1.9 2013/12/04 09:51:36 sontran
//    gen_regif_class.py 1.59 2014/05/19 02:28:17 sontran
//    regif_cpp.skl 1.52 2014/05/19 02:28:22 sontran
//
// Input file : bist_info.txt
////////////////////////////////////////////////////////////////////////////////
// # -----------------------------------------------------------------------------
// # $Id: bist_info.txt,v 1.0 2013/08/13 01:50:14 binhnguyen
// #
// # Copyright(c) 2013 Renesas Electronics Corporation
// # Copyright(c) 2013 Renesas Design Vietnam Co., Ltd.
// # RENESAS ELECTRONICS CONFIDENTIAL AND PROPRIETARY.
// # This program must be used solely for the purpose for which
// # it was furnished by Renesas Electronics Corporation. No part of this
// # program may be reproduced or disclosed to others, in any
// # form, without the prior written permission of Renesas Electronics
// # Corporation.
// # -----------------------------------------------------------------------------
// 
// %MODULE bist
//     #              name     offset_size
//     %%REG_INSTANCE reg_def  6
// 
// %REG_CHANNEL   reg_def
//   %%TITLE  name         reg_name     wsize  rsize    length  offset  factor_start  factor_end  factor_index  init        access  support  callback
//   %%REG    LBISTREF1    LBISTREF1    32     8|16|32  32      0x0000  -             -           -             0x000A5A5A  R       TRUE     -
//   %%REG    LBISTREF2    LBISTREF2    32     8|16|32  32      0x0004  -             -           -             0x0005A5A5  R       TRUE     -
//   %%REG    MBISTREF1    MBISTREF1    32     8|16|32  32      0x0008  -             -           -             0x000AA55A  R       TRUE     -
//   %%REG    MBISTREF2    MBISTREF2    32     8|16|32  32      0x000C  -             -           -             0x00055AA5  R       TRUE     -
//   %%REG    LBISTSIG1    LBISTSIG1    32     8|16|32  32      0x0010  -             -           -             0x0005A5A5  R       TRUE     -
//   %%REG    LBISTSIG2    LBISTSIG2    32     8|16|32  32      0x0014  -             -           -             0x000A5A5A  R       TRUE     -
//   %%REG    MBISTSIG1    MBISTSIG1    32     8|16|32  32      0x0018  -             -           -             0x00055AA5  R       TRUE     -
//   %%REG    MBISTSIG2    MBISTSIG2    32     8|16|32  32      0x001C  -             -           -             0x000AA55A  R       TRUE     -
//   %%REG    MBISTFTAGL1  MBISTFTAGL1  32     8|16|32  32      0x0020  -             -           -             0xFFFFFFFF  R       TRUE     -
//   %%REG    MBISTFTAGH1  MBISTFTAGH1  32     8|16|32  32      0x0024  -             -           -             0xFFFFFFFF  R       TRUE     -
//   %%REG    MBISTFTAGL2  MBISTFTAGL2  32     8|16|32  32      0x0028  -             -           -             0xFFFFFFFF  R       TRUE     -
//   %%REG    MBISTFTAGH2  MBISTFTAGH2  32     8|16|32  32      0x002C  -             -           -             0xFFFFFFFF  R       TRUE     -
//   %%REG    BSEQ0ST      BSEQ0ST      32     8|16|32  32      0x0030  -             -           -             0x00000001  R       TRUE     -
//   %%REG    BSEQ0STB     BSEQ0STB     32     8|16|32  32      0x0034  -             -           -             0x00000002  R       TRUE     -
//   %%REG    BISTST       BISTST       32     8|16|32  32      0x0038  -             -           -             0x0000000F  R       TRUE     -
// 
// 
// %REG_NAME  LBISTREF1
//    %%TITLE  name        upper   lower   init      access   support   callback
//    %%BIT    LBISTREF1   19      0       0xA5A5A   R        -         -
// 
// %REG_NAME  LBISTREF2
//    %%TITLE  name        upper   lower   init      access   support   callback
//    %%BIT    LBISTREF2   19      0       0x5A5A5   R        -         -
// 
// %REG_NAME  MBISTREF1
//    %%TITLE  name        upper   lower   init      access   support   callback
//    %%BIT    MBISTREF1   19      0       0xAA55A   R        -         -
// 
// %REG_NAME  MBISTREF2
//    %%TITLE  name        upper   lower   init      access   support   callback
//    %%BIT    MBISTREF2   19      0       0x55AA5   R        -         -
// 
// %REG_NAME  LBISTSIG1
//    %%TITLE  name        upper   lower   init      access   support   callback
//    %%BIT    LBISTSIG1   19      0       0x5A5A5   R        -         -
// 
// %REG_NAME  LBISTSIG2
//    %%TITLE  name        upper   lower   init      access   support   callback
//    %%BIT    LBISTSIG2   19      0       0xA5A5A   R        -         -
// 
// %REG_NAME  MBISTSIG1
//    %%TITLE  name        upper   lower   init      access   support   callback
//    %%BIT    MBISTSIG1   19      0       0x55AA5   R        -         -
// 
// %REG_NAME  MBISTSIG2
//    %%TITLE  name        upper   lower   init      access   support   callback
//    %%BIT    MBISTSIG2   19      0       0xAA55A   R        -         -
// 
// %REG_NAME  MBISTFTAGL1
//    %%TITLE  name            upper   lower   init      access   support   callback
//    %%BIT    MBISTFTAGL131   31      31      1         R        -         -
//    %%BIT    MBISTFTAGL130   30      30      1         R        -         -
//    %%BIT    MBISTFTAGL129   29      29      1         R        -         -
//    %%BIT    MBISTFTAGL128   28      28      1         R        -         -
//    %%BIT    MBISTFTAGL127   27      27      1         R        -         -
//    %%BIT    MBISTFTAGL126   26      26      1         R        -         -
//    %%BIT    MBISTFTAGL125   25      25      1         R        -         -
//    %%BIT    MBISTFTAGL124   24      24      1         R        -         -
//    %%BIT    MBISTFTAGL123   23      23      1         R        -         -
//    %%BIT    MBISTFTAGL122   22      22      1         R        -         -
//    %%BIT    MBISTFTAGL121   21      21      1         R        -         -
//    %%BIT    MBISTFTAGL120   20      20      1         R        -         -
//    %%BIT    MBISTFTAGL119   19      19      1         R        -         -
//    %%BIT    MBISTFTAGL118   18      18      1         R        -         -
//    %%BIT    MBISTFTAGL117   17      17      1         R        -         -
//    %%BIT    MBISTFTAGL116   16      16      1         R        -         -
//    %%BIT    MBISTFTAGL115   15      15      1         R        -         -
//    %%BIT    MBISTFTAGL114   14      14      1         R        -         -
//    %%BIT    MBISTFTAGL113   13      13      1         R        -         -
//    %%BIT    MBISTFTAGL112   12      12      1         R        -         -
//    %%BIT    MBISTFTAGL111   11      11      1         R        -         -
//    %%BIT    MBISTFTAGL110   10      10      1         R        -         -
//    %%BIT    MBISTFTAGL109    9       9      1         R        -         -
//    %%BIT    MBISTFTAGL108    8       8      1         R        -         -
//    %%BIT    MBISTFTAGL107    7       7      1         R        -         -
//    %%BIT    MBISTFTAGL106    6       6      1         R        -         -
//    %%BIT    MBISTFTAGL105    5       5      1         R        -         -
//    %%BIT    MBISTFTAGL104    4       4      1         R        -         -
//    %%BIT    MBISTFTAGL103    3       3      1         R        -         -
//    %%BIT    MBISTFTAGL102    2       2      1         R        -         -
//    %%BIT    MBISTFTAGL101    1       1      1         R        -         -
//    %%BIT    MBISTFTAGL100    0       0      1         R        -         -
// 
// %REG_NAME  MBISTFTAGH1
//    %%TITLE  name            upper   lower   init      access   support   callback
//    %%BIT    MBISTFTAGH131   31      31      1         R        -         -
//    %%BIT    MBISTFTAGH130   30      30      1         R        -         -
//    %%BIT    MBISTFTAGH129   29      29      1         R        -         -
//    %%BIT    MBISTFTAGH128   28      28      1         R        -         -
//    %%BIT    MBISTFTAGH127   27      27      1         R        -         -
//    %%BIT    MBISTFTAGH126   26      26      1         R        -         -
//    %%BIT    MBISTFTAGH125   25      25      1         R        -         -
//    %%BIT    MBISTFTAGH124   24      24      1         R        -         -
//    %%BIT    MBISTFTAGH123   23      23      1         R        -         -
//    %%BIT    MBISTFTAGH122   22      22      1         R        -         -
//    %%BIT    MBISTFTAGH121   21      21      1         R        -         -
//    %%BIT    MBISTFTAGH120   20      20      1         R        -         -
//    %%BIT    MBISTFTAGH119   19      19      1         R        -         -
//    %%BIT    MBISTFTAGH118   18      18      1         R        -         -
//    %%BIT    MBISTFTAGH117   17      17      1         R        -         -
//    %%BIT    MBISTFTAGH116   16      16      1         R        -         -
//    %%BIT    MBISTFTAGH115   15      15      1         R        -         -
//    %%BIT    MBISTFTAGH114   14      14      1         R        -         -
//    %%BIT    MBISTFTAGH113   13      13      1         R        -         -
//    %%BIT    MBISTFTAGH112   12      12      1         R        -         -
//    %%BIT    MBISTFTAGH111   11      11      1         R        -         -
//    %%BIT    MBISTFTAGH110   10      10      1         R        -         -
//    %%BIT    MBISTFTAGH109    9       9      1         R        -         -
//    %%BIT    MBISTFTAGH108    8       8      1         R        -         -
//    %%BIT    MBISTFTAGH107    7       7      1         R        -         -
//    %%BIT    MBISTFTAGH106    6       6      1         R        -         -
//    %%BIT    MBISTFTAGH105    5       5      1         R        -         -
//    %%BIT    MBISTFTAGH104    4       4      1         R        -         -
//    %%BIT    MBISTFTAGH103    3       3      1         R        -         -
//    %%BIT    MBISTFTAGH102    2       2      1         R        -         -
//    %%BIT    MBISTFTAGH101    1       1      1         R        -         -
//    %%BIT    MBISTFTAGH100    0       0      1         R        -         -
// 
// %REG_NAME  MBISTFTAGL2
//    %%TITLE  name            upper   lower   init      access   support   callback
//    %%BIT    MBISTFTAGL231   31      31      1         R        -         -
//    %%BIT    MBISTFTAGL230   30      30      1         R        -         -
//    %%BIT    MBISTFTAGL229   29      29      1         R        -         -
//    %%BIT    MBISTFTAGL228   28      28      1         R        -         -
//    %%BIT    MBISTFTAGL227   27      27      1         R        -         -
//    %%BIT    MBISTFTAGL226   26      26      1         R        -         -
//    %%BIT    MBISTFTAGL225   25      25      1         R        -         -
//    %%BIT    MBISTFTAGL224   24      24      1         R        -         -
//    %%BIT    MBISTFTAGL223   23      23      1         R        -         -
//    %%BIT    MBISTFTAGL222   22      22      1         R        -         -
//    %%BIT    MBISTFTAGL221   21      21      1         R        -         -
//    %%BIT    MBISTFTAGL220   20      20      1         R        -         -
//    %%BIT    MBISTFTAGL219   19      19      1         R        -         -
//    %%BIT    MBISTFTAGL218   18      18      1         R        -         -
//    %%BIT    MBISTFTAGL217   17      17      1         R        -         -
//    %%BIT    MBISTFTAGL216   16      16      1         R        -         -
//    %%BIT    MBISTFTAGL215   15      15      1         R        -         -
//    %%BIT    MBISTFTAGL214   14      14      1         R        -         -
//    %%BIT    MBISTFTAGL213   13      13      1         R        -         -
//    %%BIT    MBISTFTAGL212   12      12      1         R        -         -
//    %%BIT    MBISTFTAGL211   11      11      1         R        -         -
//    %%BIT    MBISTFTAGL210   10      10      1         R        -         -
//    %%BIT    MBISTFTAGL209    9       9      1         R        -         -
//    %%BIT    MBISTFTAGL208    8       8      1         R        -         -
//    %%BIT    MBISTFTAGL207    7       7      1         R        -         -
//    %%BIT    MBISTFTAGL206    6       6      1         R        -         -
//    %%BIT    MBISTFTAGL205    5       5      1         R        -         -
//    %%BIT    MBISTFTAGL204    4       4      1         R        -         -
//    %%BIT    MBISTFTAGL203    3       3      1         R        -         -
//    %%BIT    MBISTFTAGL202    2       2      1         R        -         -
//    %%BIT    MBISTFTAGL201    1       1      1         R        -         -
//    %%BIT    MBISTFTAGL200    0       0      1         R        -         -
// 
// %REG_NAME  MBISTFTAGH2
//    %%TITLE  name            upper   lower   init      access   support   callback
//    %%BIT    MBISTFTAGH231   31      31      1         R        -         -
//    %%BIT    MBISTFTAGH230   30      30      1         R        -         -
//    %%BIT    MBISTFTAGH229   29      29      1         R        -         -
//    %%BIT    MBISTFTAGH228   28      28      1         R        -         -
//    %%BIT    MBISTFTAGH227   27      27      1         R        -         -
//    %%BIT    MBISTFTAGH226   26      26      1         R        -         -
//    %%BIT    MBISTFTAGH225   25      25      1         R        -         -
//    %%BIT    MBISTFTAGH224   24      24      1         R        -         -
//    %%BIT    MBISTFTAGH223   23      23      1         R        -         -
//    %%BIT    MBISTFTAGH222   22      22      1         R        -         -
//    %%BIT    MBISTFTAGH221   21      21      1         R        -         -
//    %%BIT    MBISTFTAGH220   20      20      1         R        -         -
//    %%BIT    MBISTFTAGH219   19      19      1         R        -         -
//    %%BIT    MBISTFTAGH218   18      18      1         R        -         -
//    %%BIT    MBISTFTAGH217   17      17      1         R        -         -
//    %%BIT    MBISTFTAGH216   16      16      1         R        -         -
//    %%BIT    MBISTFTAGH215   15      15      1         R        -         -
//    %%BIT    MBISTFTAGH214   14      14      1         R        -         -
//    %%BIT    MBISTFTAGH213   13      13      1         R        -         -
//    %%BIT    MBISTFTAGH212   12      12      1         R        -         -
//    %%BIT    MBISTFTAGH211   11      11      1         R        -         -
//    %%BIT    MBISTFTAGH210   10      10      1         R        -         -
//    %%BIT    MBISTFTAGH209    9       9      1         R        -         -
//    %%BIT    MBISTFTAGH208    8       8      1         R        -         -
//    %%BIT    MBISTFTAGH207    7       7      1         R        -         -
//    %%BIT    MBISTFTAGH206    6       6      1         R        -         -
//    %%BIT    MBISTFTAGH205    5       5      1         R        -         -
//    %%BIT    MBISTFTAGH204    4       4      1         R        -         -
//    %%BIT    MBISTFTAGH203    3       3      1         R        -         -
//    %%BIT    MBISTFTAGH202    2       2      1         R        -         -
//    %%BIT    MBISTFTAGH201    1       1      1         R        -         -
//    %%BIT    MBISTFTAGH200    0       0      1         R        -         -
// 
// %REG_NAME  BSEQ0ST
//    %%TITLE  name        upper   lower   init      access   support   callback
//    %%BIT    BISTEND     1       1       0         R        -         -
//    %%BIT    CMPERR      0       0       1         R        -         -
// 
// %REG_NAME  BSEQ0STB
//    %%TITLE  name        upper   lower   init      access   support   callback
//    %%BIT    BISTENDB    1       1       1         R        -         -
//    %%BIT    CMPERRB     0       0       0         R        -         -
// 
// %REG_NAME  BISTST
//    %%TITLE  name        upper   lower   init      access   support   callback
//    %%BIT    MBIST2ST    3       3       1         R        -         -
//    %%BIT    MBIST1ST    2       2       1         R        -         -
//    %%BIT    LBIST2ST    1       1       1         R        -         -
//    %%BIT    LBIST1ST    0       0       1         R        -         -
// 
// 
// %CMD_BASEID  tgt reg
// %CMD_NODUMP_API CommandCB DumpProfile ClearProfile EnableInsertInput EnableDumpResult
// 
// %CMD_RW BISTProcessingTime  <time: double=20>             @ The time from receiving the start_bist flag to sending the end_bist flag.
// 
// %CMD_ACTION SetCLKfreq  <clk_name: std::string> <clk_freq: double> : void   @ Set clock frequency for pclk port
// 
////////////////////////////////////////////////////////////////////////////////
/// @file bist_regif.cpp
/// @brief Register IF class of model BIST
/// $Id$
/// $Date$
/// $Revison$
/// $Author$
////////////////////////////////////////////////////////////////////////////////
#include "bist_regif.h"
#ifndef re_printf
#define re_printf get_fileline(__FILE__, __LINE__); _re_printf
#endif//re_printf

/// Constructor of Register IF class: define registers and bits
/// @return none
Cbist_regif::Cbist_regif(std::string name, uint buswidth)
    :vpcl::reg_super()
    #ifdef CWR_SYSTEMC
    , cwmem("register", scml_memsize(0x3C/4))
    #endif
{
    CommandInit();
    LBISTREF1   = new vpcl::re_register(0x0000, this, "LBISTREF1"  , name.c_str());
    LBISTREF2   = new vpcl::re_register(0x0004, this, "LBISTREF2"  , name.c_str());
    MBISTREF1   = new vpcl::re_register(0x0008, this, "MBISTREF1"  , name.c_str());
    MBISTREF2   = new vpcl::re_register(0x000C, this, "MBISTREF2"  , name.c_str());
    LBISTSIG1   = new vpcl::re_register(0x0010, this, "LBISTSIG1"  , name.c_str());
    LBISTSIG2   = new vpcl::re_register(0x0014, this, "LBISTSIG2"  , name.c_str());
    MBISTSIG1   = new vpcl::re_register(0x0018, this, "MBISTSIG1"  , name.c_str());
    MBISTSIG2   = new vpcl::re_register(0x001C, this, "MBISTSIG2"  , name.c_str());
    MBISTFTAGL1 = new vpcl::re_register(0x0020, this, "MBISTFTAGL1", name.c_str());
    MBISTFTAGH1 = new vpcl::re_register(0x0024, this, "MBISTFTAGH1", name.c_str());
    MBISTFTAGL2 = new vpcl::re_register(0x0028, this, "MBISTFTAGL2", name.c_str());
    MBISTFTAGH2 = new vpcl::re_register(0x002C, this, "MBISTFTAGH2", name.c_str());
    BSEQ0ST     = new vpcl::re_register(0x0030, this, "BSEQ0ST"    , name.c_str());
    BSEQ0STB    = new vpcl::re_register(0x0034, this, "BSEQ0STB"   , name.c_str());
    BISTST      = new vpcl::re_register(0x0038, this, "BISTST"     , name.c_str());

    // Construct the register pointer list
    mCurReg = NULL;

    uint index = 0;
    mRegMap = new uint [1<<6];
    for (uint i = 0; i < (1<<6); i++) {
        mRegMap[i] = (1<<6);
    }

    mRegMap[0x0000]     = index;
    mRegMap[0x0000 + 1] = index;
    mRegMap[0x0000 + 2] = index;
    mRegMap[0x0000 + 3] = index++;
    mRegMap[0x0004]     = index;
    mRegMap[0x0004 + 1] = index;
    mRegMap[0x0004 + 2] = index;
    mRegMap[0x0004 + 3] = index++;
    mRegMap[0x0008]     = index;
    mRegMap[0x0008 + 1] = index;
    mRegMap[0x0008 + 2] = index;
    mRegMap[0x0008 + 3] = index++;
    mRegMap[0x000C]     = index;
    mRegMap[0x000C + 1] = index;
    mRegMap[0x000C + 2] = index;
    mRegMap[0x000C + 3] = index++;
    mRegMap[0x0010]     = index;
    mRegMap[0x0010 + 1] = index;
    mRegMap[0x0010 + 2] = index;
    mRegMap[0x0010 + 3] = index++;
    mRegMap[0x0014]     = index;
    mRegMap[0x0014 + 1] = index;
    mRegMap[0x0014 + 2] = index;
    mRegMap[0x0014 + 3] = index++;
    mRegMap[0x0018]     = index;
    mRegMap[0x0018 + 1] = index;
    mRegMap[0x0018 + 2] = index;
    mRegMap[0x0018 + 3] = index++;
    mRegMap[0x001C]     = index;
    mRegMap[0x001C + 1] = index;
    mRegMap[0x001C + 2] = index;
    mRegMap[0x001C + 3] = index++;
    mRegMap[0x0020]     = index;
    mRegMap[0x0020 + 1] = index;
    mRegMap[0x0020 + 2] = index;
    mRegMap[0x0020 + 3] = index++;
    mRegMap[0x0024]     = index;
    mRegMap[0x0024 + 1] = index;
    mRegMap[0x0024 + 2] = index;
    mRegMap[0x0024 + 3] = index++;
    mRegMap[0x0028]     = index;
    mRegMap[0x0028 + 1] = index;
    mRegMap[0x0028 + 2] = index;
    mRegMap[0x0028 + 3] = index++;
    mRegMap[0x002C]     = index;
    mRegMap[0x002C + 1] = index;
    mRegMap[0x002C + 2] = index;
    mRegMap[0x002C + 3] = index++;
    mRegMap[0x0030]     = index;
    mRegMap[0x0030 + 1] = index;
    mRegMap[0x0030 + 2] = index;
    mRegMap[0x0030 + 3] = index++;
    mRegMap[0x0034]     = index;
    mRegMap[0x0034 + 1] = index;
    mRegMap[0x0034 + 2] = index;
    mRegMap[0x0034 + 3] = index++;
    mRegMap[0x0038]     = index;
    mRegMap[0x0038 + 1] = index;
    mRegMap[0x0038 + 2] = index;
    mRegMap[0x0038 + 3] = index++;
    mTotalRegNum = index;
    mRegArray = new SRegList* [mTotalRegNum];
    index = 0;
    #ifdef CWR_SYSTEMC
    cw_instantiate_reg(CW_LBISTREF1    , LBISTREF1->name()  , LBISTREF1->addr()  );
    cw_instantiate_reg(CW_LBISTREF2    , LBISTREF2->name()  , LBISTREF2->addr()  );
    cw_instantiate_reg(CW_MBISTREF1    , MBISTREF1->name()  , MBISTREF1->addr()  );
    cw_instantiate_reg(CW_MBISTREF2    , MBISTREF2->name()  , MBISTREF2->addr()  );
    cw_instantiate_reg(CW_LBISTSIG1    , LBISTSIG1->name()  , LBISTSIG1->addr()  );
    cw_instantiate_reg(CW_LBISTSIG2    , LBISTSIG2->name()  , LBISTSIG2->addr()  );
    cw_instantiate_reg(CW_MBISTSIG1    , MBISTSIG1->name()  , MBISTSIG1->addr()  );
    cw_instantiate_reg(CW_MBISTSIG2    , MBISTSIG2->name()  , MBISTSIG2->addr()  );
    cw_instantiate_reg(CW_MBISTFTAGL1  , MBISTFTAGL1->name(), MBISTFTAGL1->addr());
    cw_instantiate_reg(CW_MBISTFTAGH1  , MBISTFTAGH1->name(), MBISTFTAGH1->addr());
    cw_instantiate_reg(CW_MBISTFTAGL2  , MBISTFTAGL2->name(), MBISTFTAGL2->addr());
    cw_instantiate_reg(CW_MBISTFTAGH2  , MBISTFTAGH2->name(), MBISTFTAGH2->addr());
    cw_instantiate_reg(CW_BSEQ0ST      , BSEQ0ST->name()    , BSEQ0ST->addr()    );
    cw_instantiate_reg(CW_BSEQ0STB     , BSEQ0STB->name()   , BSEQ0STB->addr()   );
    cw_instantiate_reg(CW_BISTST       , BISTST->name()     , BISTST->addr()     );
    #endif
    mCurReg = mRegArray[index++] = new SRegList(LBISTREF1    , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(LBISTREF2    , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(MBISTREF1    , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(MBISTREF2    , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(LBISTSIG1    , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(LBISTSIG2    , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(MBISTSIG1    , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(MBISTSIG2    , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(MBISTFTAGL1  , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(MBISTFTAGH1  , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(MBISTFTAGL2  , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(MBISTFTAGH2  , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(BSEQ0ST      , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(BSEQ0STB     , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(BISTST       , mCurReg, 0,  4,      "32", "8|16|32");

    mRegList = mCurReg;

    (*LBISTREF1    ) (19,  0, "LBISTREF1", 0xA5A5A   , "R"     , vpcl::SPP_ENABLE);
    (*LBISTREF2    ) (19,  0, "LBISTREF2", 0x5A5A5   , "R"     , vpcl::SPP_ENABLE);
    (*MBISTREF1    ) (19,  0, "MBISTREF1", 0xAA55A   , "R"     , vpcl::SPP_ENABLE);
    (*MBISTREF2    ) (19,  0, "MBISTREF2", 0x55AA5   , "R"     , vpcl::SPP_ENABLE);
    (*LBISTSIG1    ) (19,  0, "LBISTSIG1", 0x5A5A5   , "R"     , vpcl::SPP_ENABLE);
    (*LBISTSIG2    ) (19,  0, "LBISTSIG2", 0xA5A5A   , "R"     , vpcl::SPP_ENABLE);
    (*MBISTSIG1    ) (19,  0, "MBISTSIG1", 0x55AA5   , "R"     , vpcl::SPP_ENABLE);
    (*MBISTSIG2    ) (19,  0, "MBISTSIG2", 0xAA55A   , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL1  ) (31, 31, "MBISTFTAGL131", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL1  ) (30, 30, "MBISTFTAGL130", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL1  ) (29, 29, "MBISTFTAGL129", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL1  ) (28, 28, "MBISTFTAGL128", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL1  ) (27, 27, "MBISTFTAGL127", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL1  ) (26, 26, "MBISTFTAGL126", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL1  ) (25, 25, "MBISTFTAGL125", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL1  ) (24, 24, "MBISTFTAGL124", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL1  ) (23, 23, "MBISTFTAGL123", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL1  ) (22, 22, "MBISTFTAGL122", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL1  ) (21, 21, "MBISTFTAGL121", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL1  ) (20, 20, "MBISTFTAGL120", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL1  ) (19, 19, "MBISTFTAGL119", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL1  ) (18, 18, "MBISTFTAGL118", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL1  ) (17, 17, "MBISTFTAGL117", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL1  ) (16, 16, "MBISTFTAGL116", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL1  ) (15, 15, "MBISTFTAGL115", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL1  ) (14, 14, "MBISTFTAGL114", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL1  ) (13, 13, "MBISTFTAGL113", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL1  ) (12, 12, "MBISTFTAGL112", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL1  ) (11, 11, "MBISTFTAGL111", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL1  ) (10, 10, "MBISTFTAGL110", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL1  ) ( 9,  9, "MBISTFTAGL109", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL1  ) ( 8,  8, "MBISTFTAGL108", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL1  ) ( 7,  7, "MBISTFTAGL107", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL1  ) ( 6,  6, "MBISTFTAGL106", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL1  ) ( 5,  5, "MBISTFTAGL105", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL1  ) ( 4,  4, "MBISTFTAGL104", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL1  ) ( 3,  3, "MBISTFTAGL103", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL1  ) ( 2,  2, "MBISTFTAGL102", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL1  ) ( 1,  1, "MBISTFTAGL101", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL1  ) ( 0,  0, "MBISTFTAGL100", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH1  ) (31, 31, "MBISTFTAGH131", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH1  ) (30, 30, "MBISTFTAGH130", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH1  ) (29, 29, "MBISTFTAGH129", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH1  ) (28, 28, "MBISTFTAGH128", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH1  ) (27, 27, "MBISTFTAGH127", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH1  ) (26, 26, "MBISTFTAGH126", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH1  ) (25, 25, "MBISTFTAGH125", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH1  ) (24, 24, "MBISTFTAGH124", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH1  ) (23, 23, "MBISTFTAGH123", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH1  ) (22, 22, "MBISTFTAGH122", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH1  ) (21, 21, "MBISTFTAGH121", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH1  ) (20, 20, "MBISTFTAGH120", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH1  ) (19, 19, "MBISTFTAGH119", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH1  ) (18, 18, "MBISTFTAGH118", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH1  ) (17, 17, "MBISTFTAGH117", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH1  ) (16, 16, "MBISTFTAGH116", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH1  ) (15, 15, "MBISTFTAGH115", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH1  ) (14, 14, "MBISTFTAGH114", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH1  ) (13, 13, "MBISTFTAGH113", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH1  ) (12, 12, "MBISTFTAGH112", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH1  ) (11, 11, "MBISTFTAGH111", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH1  ) (10, 10, "MBISTFTAGH110", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH1  ) ( 9,  9, "MBISTFTAGH109", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH1  ) ( 8,  8, "MBISTFTAGH108", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH1  ) ( 7,  7, "MBISTFTAGH107", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH1  ) ( 6,  6, "MBISTFTAGH106", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH1  ) ( 5,  5, "MBISTFTAGH105", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH1  ) ( 4,  4, "MBISTFTAGH104", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH1  ) ( 3,  3, "MBISTFTAGH103", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH1  ) ( 2,  2, "MBISTFTAGH102", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH1  ) ( 1,  1, "MBISTFTAGH101", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH1  ) ( 0,  0, "MBISTFTAGH100", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL2  ) (31, 31, "MBISTFTAGL231", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL2  ) (30, 30, "MBISTFTAGL230", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL2  ) (29, 29, "MBISTFTAGL229", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL2  ) (28, 28, "MBISTFTAGL228", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL2  ) (27, 27, "MBISTFTAGL227", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL2  ) (26, 26, "MBISTFTAGL226", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL2  ) (25, 25, "MBISTFTAGL225", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL2  ) (24, 24, "MBISTFTAGL224", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL2  ) (23, 23, "MBISTFTAGL223", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL2  ) (22, 22, "MBISTFTAGL222", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL2  ) (21, 21, "MBISTFTAGL221", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL2  ) (20, 20, "MBISTFTAGL220", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL2  ) (19, 19, "MBISTFTAGL219", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL2  ) (18, 18, "MBISTFTAGL218", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL2  ) (17, 17, "MBISTFTAGL217", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL2  ) (16, 16, "MBISTFTAGL216", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL2  ) (15, 15, "MBISTFTAGL215", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL2  ) (14, 14, "MBISTFTAGL214", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL2  ) (13, 13, "MBISTFTAGL213", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL2  ) (12, 12, "MBISTFTAGL212", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL2  ) (11, 11, "MBISTFTAGL211", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL2  ) (10, 10, "MBISTFTAGL210", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL2  ) ( 9,  9, "MBISTFTAGL209", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL2  ) ( 8,  8, "MBISTFTAGL208", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL2  ) ( 7,  7, "MBISTFTAGL207", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL2  ) ( 6,  6, "MBISTFTAGL206", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL2  ) ( 5,  5, "MBISTFTAGL205", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL2  ) ( 4,  4, "MBISTFTAGL204", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL2  ) ( 3,  3, "MBISTFTAGL203", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL2  ) ( 2,  2, "MBISTFTAGL202", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL2  ) ( 1,  1, "MBISTFTAGL201", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGL2  ) ( 0,  0, "MBISTFTAGL200", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH2  ) (31, 31, "MBISTFTAGH231", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH2  ) (30, 30, "MBISTFTAGH230", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH2  ) (29, 29, "MBISTFTAGH229", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH2  ) (28, 28, "MBISTFTAGH228", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH2  ) (27, 27, "MBISTFTAGH227", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH2  ) (26, 26, "MBISTFTAGH226", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH2  ) (25, 25, "MBISTFTAGH225", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH2  ) (24, 24, "MBISTFTAGH224", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH2  ) (23, 23, "MBISTFTAGH223", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH2  ) (22, 22, "MBISTFTAGH222", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH2  ) (21, 21, "MBISTFTAGH221", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH2  ) (20, 20, "MBISTFTAGH220", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH2  ) (19, 19, "MBISTFTAGH219", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH2  ) (18, 18, "MBISTFTAGH218", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH2  ) (17, 17, "MBISTFTAGH217", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH2  ) (16, 16, "MBISTFTAGH216", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH2  ) (15, 15, "MBISTFTAGH215", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH2  ) (14, 14, "MBISTFTAGH214", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH2  ) (13, 13, "MBISTFTAGH213", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH2  ) (12, 12, "MBISTFTAGH212", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH2  ) (11, 11, "MBISTFTAGH211", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH2  ) (10, 10, "MBISTFTAGH210", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH2  ) ( 9,  9, "MBISTFTAGH209", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH2  ) ( 8,  8, "MBISTFTAGH208", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH2  ) ( 7,  7, "MBISTFTAGH207", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH2  ) ( 6,  6, "MBISTFTAGH206", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH2  ) ( 5,  5, "MBISTFTAGH205", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH2  ) ( 4,  4, "MBISTFTAGH204", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH2  ) ( 3,  3, "MBISTFTAGH203", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH2  ) ( 2,  2, "MBISTFTAGH202", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH2  ) ( 1,  1, "MBISTFTAGH201", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*MBISTFTAGH2  ) ( 0,  0, "MBISTFTAGH200", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*BSEQ0ST      ) ( 1,  1, "BISTEND" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*BSEQ0ST      ) ( 0,  0, "CMPERR"  , 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*BSEQ0STB     ) ( 1,  1, "BISTENDB", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*BSEQ0STB     ) ( 0,  0, "CMPERRB" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*BISTST       ) ( 3,  3, "MBIST2ST", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*BISTST       ) ( 2,  2, "MBIST1ST", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*BISTST       ) ( 1,  1, "LBIST2ST", 0x1       , "R"     , vpcl::SPP_ENABLE);
    (*BISTST       ) ( 0,  0, "LBIST1ST", 0x1       , "R"     , vpcl::SPP_ENABLE);

    mFileName = "";
    mInstName = name;
    mLineNum = 0;
    mBusWidth = buswidth;
    mBusByteWidth = mBusWidth/8;   // using in BIG ENDIAN
    mIsReset = false;

    // Constructor the callback function of each register
    for (uint i = 0; i < mTotalRegNum; i++) {
        mWrCbAPI[mRegArray[i]->my_p->name()][mRegArray[i]->my_p->name()] = NULL;
        mRdCbAPI[mRegArray[i]->my_p->name()][mRegArray[i]->my_p->name()] = NULL;
    }

    //Constructor the mWrCbAPI, mRdCbAPI variable of each register

    InitLocalVal();
}

/// Destructor: delete pointers
/// @return none
Cbist_regif::~Cbist_regif()
{
    // Delete registers' pointer
    for (uint i = 0 ; i < mTotalRegNum ; i++) {
        delete mRegArray[i]->my_p;
        mRegArray[i]->prev = NULL;
    }
    delete [] mRegMap;
    delete [] mRegArray;
    delete mRegList;
    mCurReg = NULL;
}

/// Mask unselected bit
/// @return selected value
Cbist_regif::uint Cbist_regif::bit_select(
                         cuint val,    ///< [in] Writting address
                         cuint start,  ///< [in] start bit position
                         cuint end)    ///< [in] end bit position
{
    uint ret_val = val;
    if (end - start + 1 < 32) {
        ret_val = (val>>start) & (uint)((1<<(end-start+1))-1);
    }
    return ret_val;
}

/// Write the value to requested module register
/// @return true if writing transaction is finished normally
bool Cbist_regif::reg_wr(cuint addr,                    ///< [in] Writting address
                         const unsigned char *p_data,   ///< [in] Writing data
                         cuint size)                    ///< [in] Data size (byte)
{
    if(size == 0) return false;
    #ifdef IS_MODELED_ENDIAN_BIG
    if ((addr % mBusByteWidth) + size > mBusByteWidth) return false;
    #endif

    bool ret_val = false;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(p_data != NULL);
    #else
    sc_assert(p_data != NULL);
    #endif
    ret_val = reg_wr_process (addr, p_data, size, false);
    return ret_val;
}

/// Read the register value of requested module
/// @return true if reading transaction is finished normally
bool Cbist_regif::reg_rd(cuint addr,              ///< [in]  Reading address
                         unsigned char *p_data,   ///< [out] Reading data
                         cuint size)              ///< [in]  Data size (byte)
{
    if(size == 0) return false;
    #ifdef IS_MODELED_ENDIAN_BIG
    if ((addr % mBusByteWidth) + size > mBusByteWidth) return false;
    #endif

    bool ret_val = false;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(p_data != NULL);
    #else
    sc_assert(p_data != NULL);
    #endif
    ret_val = reg_rd_process (addr, p_data, size, false);
    return ret_val;
}

/// Write the value to requested module register
/// @return true if writing transaction is finished normally
bool Cbist_regif::reg_wr_dbg(cuint addr,                    ///< [in] Writting address
                             const unsigned char *p_data,   ///< [in] Writing data
                             cuint size)                    ///< [in] Data size (byte)
{
    if(size == 0) return false;
    #ifdef IS_MODELED_ENDIAN_BIG
    if ((addr % mBusByteWidth) + size > mBusByteWidth) return false;
    #endif

    bool ret_val = false;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(p_data != NULL);
    #else
    sc_assert(p_data != NULL);
    #endif
    ret_val = reg_wr_process (addr, p_data, size, true);
    return ret_val;
}

/// Read the register value of requested module
/// @return true if reading transaction is finished normally
bool Cbist_regif::reg_rd_dbg(cuint addr,              ///< [in]  Reading address
                             unsigned char *p_data,   ///< [out] Reading data
                             cuint size)              ///< [in]  Data size (byte)
{
    if(size == 0) return false;
    #ifdef IS_MODELED_ENDIAN_BIG
    if ((addr % mBusByteWidth) + size > mBusByteWidth) return false;
    #endif

    bool ret_val = false;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(p_data != NULL);
    #else
    sc_assert(p_data != NULL);
    #endif
    ret_val = reg_rd_process (addr, p_data, size, true);
    return ret_val;
}

/// Write the value to requested module register
/// @return true if writing transaction is finished normally
bool Cbist_regif::reg_wr_process(cuint addr,                   ///< [in] Writting address
                                 const unsigned char *p_data,  ///< [in] Writing data
                                 cuint size,                   ///< [in] Data size (byte)
                                 bool IsDbgFunc)               ///< [in] flag indicate reg_rd or reg_rd_dbg
{
    if (mIsReset == true) {
        re_printf("warning", "Cannot write during reset period\n");
        return true;
    }
    uint tmp_addr = addr;
    #ifdef IS_MODELED_ENDIAN_BIG
    if (size < mBusByteWidth) {
        tmp_addr = addr ^ (mBusByteWidth - size);
    }
    #endif
    bool ret_val = false;
    bool valid_addr = false;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(p_data != NULL);
    #else
    sc_assert(p_data != NULL);
    #endif
    std::list<uint> list_index;
    uint masked_addr = bit_select(tmp_addr, 0, 6-1);
    uint access_addr = masked_addr;
    while (masked_addr + size > access_addr) {
        int reg_index = get_reg_index(access_addr);
        if (reg_index != -1) {
            vpcl::re_register *reg_p = mRegArray[reg_index]->my_p; 
            if ((IsDbgFunc == true) || (valid_addr == true) || (ChkSize(mRegArray[reg_index]->wacc_size, size, tmp_addr))) {
                valid_addr = true;
                list_index.push_back(reg_index);
            }
            else {
                re_printf("error", "Writing access size to %s at address 0x%08X is wrong: %d byte(s).\n", reg_p->name().c_str(), tmp_addr, size);
                return false;
            }
            access_addr = reg_p->addr() + mRegArray[reg_index]->length;
        } else {
            access_addr += 1;
        }
    }
    if (valid_addr == true) {
        std::list<uint>::iterator it;
        for (it=list_index.begin() ; it!=list_index.end() ; it++) {
            access_addr = masked_addr;
            uint d_size = size;
            uint index = 0;
            if (masked_addr < mRegArray[(*it)]->my_p->addr()) { // adjust access address & index
                access_addr = mRegArray[(*it)]->my_p->addr();
                index = mRegArray[(*it)]->my_p->addr() - masked_addr;
            }
            if ((masked_addr + size) < (mRegArray[(*it)]->my_p->addr() + mRegArray[(*it)]->length)) { // adjust access size
                d_size = masked_addr + size - access_addr;
            } else { // adjust access size
                d_size = (mRegArray[(*it)]->my_p->addr() + mRegArray[(*it)]->length) - access_addr;
            }
            if (size > mRegArray[(*it)]->length) { // adjust index for big endianess
                #ifdef IS_MODELED_ENDIAN_BIG
                index = index ^ (size - mRegArray[(*it)]->length);
                #endif
            }
            ret_val = reg_wr_func(tmp_addr - masked_addr + access_addr, &(p_data[index]), d_size, (*it), IsDbgFunc);
        }
    } else {
        if (IsDbgFunc == false) {
            re_printf("error", "Invalid access address 0x%08X\n", tmp_addr);
        } else {
            ret_val = true;
        }
    }
    return ret_val;
}

/// Read the register value of requested module
/// @return true if reading transaction is finished normally
bool Cbist_regif::reg_rd_process(cuint addr,              ///< [in]  Reading address
                                 unsigned char *p_data,   ///< [out] Reading data
                                 cuint size,              ///< [in]  Data size (byte)
                                 bool IsDbgFunc)          ///< [in] flag indicate reg_rd or reg_rd_dbg
{
    uint tmp_addr = addr;
    #ifdef IS_MODELED_ENDIAN_BIG
    if (size < mBusByteWidth) {
        tmp_addr = addr ^ (mBusByteWidth - size);
    }
    #endif
    bool ret_val = false;
    bool valid_addr = false;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(p_data != NULL);
    #else
    sc_assert(p_data != NULL);
    #endif
    std::list<uint> list_index;
    uint masked_addr = bit_select(tmp_addr, 0, 6-1);
    uint access_addr = masked_addr;
    while (masked_addr + size > access_addr) {
        int reg_index = get_reg_index(access_addr);
        if (reg_index != -1) {
            vpcl::re_register *reg_p = mRegArray[reg_index]->my_p; 
            if ((IsDbgFunc == true) || (valid_addr == true) || (ChkSize(mRegArray[reg_index]->racc_size, size, tmp_addr))) {
                valid_addr = true;
                list_index.push_back(reg_index);
            }
            else {
                re_printf("error", "Reading access size to %s at address 0x%08X is wrong: %d byte(s).\n", reg_p->name().c_str(), tmp_addr, size);
                return false;
            }
            access_addr = reg_p->addr() + mRegArray[reg_index]->length;
        } else {
            access_addr += 1;
        }
    }
    if (valid_addr == true) {
        std::list<uint>::iterator it;
        for (it=list_index.begin() ; it!=list_index.end() ; it++) {
            access_addr = masked_addr;
            uint d_size = size;
            uint index = 0;
            if (masked_addr < mRegArray[(*it)]->my_p->addr()) { // adjust access address & index
                access_addr = mRegArray[(*it)]->my_p->addr();
                index = mRegArray[(*it)]->my_p->addr() - masked_addr;
            }
            if ((masked_addr + size) < (mRegArray[(*it)]->my_p->addr() + mRegArray[(*it)]->length)) { // adjust access size
                d_size = masked_addr + size - access_addr;
            } else { // adjust access size
                d_size = (mRegArray[(*it)]->my_p->addr() + mRegArray[(*it)]->length) - access_addr;
            }
            if (size > mRegArray[(*it)]->length) { // adjust index for big endianess
                #ifdef IS_MODELED_ENDIAN_BIG
                index = index ^ (size - mRegArray[(*it)]->length);
                #endif
            }
            ret_val = reg_rd_func(tmp_addr - masked_addr + access_addr, &(p_data[index]), d_size, (*it), IsDbgFunc);
        }
    } else {
        if (IsDbgFunc == false) {
            re_printf("error", "Invalid access address 0x%08X\n", tmp_addr);
        } else {
            memset(p_data, 0, size);
            ret_val = true;
        }
    }
    return ret_val;
}

/// Process reading function
/// @return true if reading successfully
bool Cbist_regif::reg_rd_func(cuint addr,                     ///< [in]  Reading address
                              unsigned char *p_data,          ///< [out] Reading data
                              cuint size,                     ///< [in]  Data size (byte)
                              cuint reg_index,                ///< [in] Register index
                              bool IsDbgFunc)                 ///< [in] flag indicate reg_rd or reg_rd_dbg
{
    vpcl::re_register* Register = mRegArray[reg_index]->my_p;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(Register != NULL);
    #else
    sc_assert(Register != NULL);
    #endif
    
    uint pst_data = 0;
    #if 1 // always 1 since any size can be accessed in debug mode 
    uint reg_length = mRegArray[reg_index]->length;
    uint start_pos = 0;
    uint mask_size = (1 << (reg_length/2)) - 1;
    if (size < reg_length) {
        #ifdef IS_MODELED_ENDIAN_BIG
        start_pos =  (reg_length - 1)*8 - (addr & mask_size)*8; // Start bit position
        #else
        start_pos =  (addr & mask_size)*8;  // Start bit position
        #endif
    }
    #endif
    if (IsDbgFunc == false) {
        if (mIsReset == true) {
            re_printf("warning", "Cannot launch call-back function during reset period\n");
        }else {
            #if 1 // always 1 since any size can be accessed in debug mode 
            if (size < reg_length) {
                re_printf("warning","Should read all bit in a register\n");
            }
            #endif
            
            pst_data = Register->read();
            
        }
    }
    pst_data = (uint)(*Register);
    #if 1 // always 1 since any size can be accessed in debug mode 
    if (size < reg_length) {
        uint read_data = 0;
        if (((reg_length%2 == 0) && (reg_length%size == 0) && ((addr&mask_size)%size == 0)) 
         || (IsDbgFunc == false)) {
            for (uint i = start_pos; i < (8*size + start_pos); i++) {
                read_data |= (pst_data & (1 << i)) >> start_pos;
            }
            pst_data = read_data;
        }
    }
    #endif

    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(p_data != NULL);
    #else
    sc_assert(p_data != NULL);
    #endif
    memcpy(p_data, &pst_data, size);
    DumpRegMsg("R", Register->name(), "", size, addr, 0, 0, pst_data, mRegArray[reg_index]->length*8);
    for (vpcl::bit_info *it=Register->mBitInfo ; it!=NULL ; it=it->next) {
        uint val = (uint)(*Register);
        val = bit_select(val, it->mStartAddr, it->mEndAddr);
        DumpRegMsg("R", Register->name(), it->name(), size, addr, 0, 0, val, it->mEndAddr - it->mStartAddr + 1);
    }
    return true;
}

/// Process writing function
/// @return true if writing successfully
bool Cbist_regif::reg_wr_func(cuint addr,                       ///< [in] Writting address
                              const unsigned char *p_data,      ///< [in] Writing data
                              cuint size,                       ///< [in] Data size (byte)
                              cuint reg_index,                  ///< [in] Register index
                              bool IsDbgFunc)                   ///< [in] flag indicate reg_wr or reg_wr_dbg
{
    vpcl::re_register* Register = mRegArray[reg_index]->my_p;
    uint pre_data = 0;
    uint data = 0;
    #if 1 // always 1 since any size can be accessed in debug mode 
    uint reg_length = mRegArray[reg_index]->length;
    uint start_pos = 0;
    #endif
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert ((p_data != NULL) && (Register != NULL));
    #else
    sc_assert ((p_data != NULL) && (Register != NULL));
    #endif
    memcpy(&data, p_data, size);
    #if 1 // always 1 since any size can be accessed in debug mode 
    if (size < reg_length) {
        uint mask_size = (1 << (reg_length/2)) - 1;
        if (((reg_length%2 == 0) && (reg_length%size == 0) && ((addr&mask_size)%size == 0)) 
         || (IsDbgFunc == false)) {
            uint new_data = (uint)(*Register);  // For writing to register
            uint written_data = 0;         // For transferring to callback function
            #ifdef IS_MODELED_ENDIAN_BIG
            start_pos =  (reg_length - 1)*8 - (addr & mask_size)*8; // Start bit position
            #else
            start_pos =  (addr & mask_size)*8;  // Start bit position
            #endif
            for (uint i = start_pos; i < (8*size + start_pos); i++) {
                new_data = (new_data & (~(1 << i))) | ((data << start_pos) & (1 << i));
                written_data = (written_data & (~(1 << i))) | ((data << start_pos) & (1 << i));
            }
            data = new_data;
        }
    }
    #endif

    if ((mRegArray[reg_index]->block == false) || (IsDbgFunc == true)){
        pre_data = (uint)(*Register);
        if (IsDbgFunc == true) {
            bool backup_warning = Register->mMessageLevel["warning"];
            bool backup_error = Register->mMessageLevel["error"];
            Register->mMessageLevel["warning"]   = false;
            Register->mMessageLevel["error"]   = false;

            Register->write(data);

            Register->mMessageLevel["warning"]   = backup_warning;
            Register->mMessageLevel["error"]   = backup_error;
        } else {
            Register->write(data);
        }
        UpdateLocalVal(Register->addr());
        DumpRegMsg("W", Register->name(), "", size, addr, data, pre_data, (uint)(*Register), mRegArray[reg_index]->length*8);
        for (vpcl::bit_info *it=Register->mBitInfo ; it!=NULL ; it=it->next) {
            uint val = (uint)(*Register);
            val = bit_select(val, it->mStartAddr, it->mEndAddr);
            uint pre_val = pre_data;
            pre_val = bit_select(pre_val, it->mStartAddr, it->mEndAddr);
            DumpRegMsg("W", Register->name(), it->name(), size, addr, 0, pre_val, val, it->mEndAddr - it->mStartAddr + 1);
            
        }
    }
    else {
        re_printf("warning","%s is blocked writing from Bus I/F.\n", Register->name().c_str());
    }
    return true;
}

/// Check access size
/// @@return true if detect_size equal expect_size
bool Cbist_regif::ChkSize(std::string expect_size, cuint detect_size, cuint addr)
{
    std::vector<std::string> arg_vec = Str2Vec(expect_size, '|');
    std::vector<std::string>::iterator it;
    char *err_p = NULL;
    uint size = 0;
    if (detect_size > mBusByteWidth) {
        re_printf("error", "Invalid access size: %d bytes\n", detect_size);
        return false;
    }
    if(addr%detect_size != 0) {
        re_printf("error", "Invalid access address 0x%08X with access size %d bytes\n", addr, detect_size);
        return false;
    }
    for (it = arg_vec.begin(); it != arg_vec.end(); it++) {
        errno = 0; size = (uint) strtoul((*it).c_str(), &err_p, 0);
        #ifdef REGIF_NOT_USE_SYSTEMC
        assert(err_p != NULL);
        #else
        sc_assert(err_p != NULL);
        #endif
        if (errno != ERANGE && *err_p == '\0') {
            if ((size/8) == detect_size) {
                return true;
            }
        }
    }
    return false;
}

/// Initialize reg_handle_command variables
/// @return none
void Cbist_regif::CommandInit()
{
    mDumpRegisterRW = false;
    mMessageLevel["fatal"]   = true;
    mMessageLevel["error"]   = true;
    mMessageLevel["warning"] = false;
    mMessageLevel["info"]    = false;
}

/// Process reg_handle_command command
/// @return string
std::string Cbist_regif::reg_handle_command(const std::vector<std::string>& args)
{
    std::string ret = "";
    std::string err_msg = "Error ("   + mInstName + ") ";   // error message
    if (args[0] == "reg") {
        if (args[1] == "help") {
            ret += "    --- reg ---\n";
            ret += "    reg MessageLevel <fatal|error|warning|info> Select debug message level (Default: fatal,error)\n";
            ret += "    reg DumpRegisterRW <true/false>             Select dump register access information  (Default: false)\n";
            ret += "    reg <register_name> MessageLevel <fatal|error|warning|info> Select debug message level for register (Default: fatal,error)\n";
            ret += "    reg <register_name> force <value>           Force register with setting value\n";
            ret += "    reg <register_name> release                 Release register from force value\n";
            ret += "    reg <register_name> <value>                 Write a value into register\n";
            ret += "    reg <register_name>                         Read value of register\n";
            ret += "    reg help                                    Show a direction\n";
        }
        else if (args[1] == "DumpRegisterRW") {
            if (args.size() == 2) {
                ret = (mDumpRegisterRW)? "true" : "false";
            }
            else if (args.size() == 3) {
                if (args[2] == "true") {
                    mDumpRegisterRW = true;
                }
                else if (args[2] == "false") {
                    mDumpRegisterRW = false;
                } else {
                    ret = err_msg + "DumpRegisterRW command needs an argument [true/false]\n";
                }
            } else {
                ret = err_msg + "DumpRegisterRW has too much arguments\n";
            }
        }
        else if (args[1] == "MessageLevel") {
            // read mode
            if (args.size() == 2) {
                std::map<std::string, bool>::iterator it;
                for (it = mMessageLevel.begin(); it != mMessageLevel.end(); it++) {
                    if ( it->second == true ) {
                        ret += " " + it->first;
                    }
                }
            // write mode
            } else if (args.size() == 3) {
                std::vector<std::string> arg_vec = Str2Vec(args[2], '|');
                std::map<std::string, bool>::iterator msgit;
                for (msgit =mMessageLevel.begin(); msgit != mMessageLevel.end(); msgit++) {
                    msgit->second = false;
                }
                std::vector<std::string>::iterator it;
                for (it = arg_vec.begin(); it != arg_vec.end(); it++) {
                    mMessageLevel[*it] = true;
                }
            } else {
                ret = err_msg + "MessageLevel has too much arguments\n";
            }
        } else {
            bool matched = false;
            for (uint i = 0; i < mTotalRegNum; i++) {
                if (args[1] == mRegArray[i]->my_p->name()) {
                    ret = AccessRegCommand(args, mRegArray[i]->my_p, mRegArray[i]->block);
                    matched = true;
                    break;
                }
            }
            if (!matched) {
                ret = err_msg + "Register name " + (std::string)args[1] + " is invalid\n";
            }
        }
    }
    return ret;
}

/// process reg_handle_command of "reg" parameter
/// @return string
std::string Cbist_regif::AccessRegCommand(const std::vector<std::string>& args, vpcl::re_register *Register, bool &BlockReg)
{
    std::string ret = "";
    char *err_p = NULL;
    std::string err_msg = "Error ("   + mInstName + ") ";   // error message
    uint data = 0;
    std::ostringstream str_tmp;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(Register != NULL);
    #else
    sc_assert(Register != NULL);
    #endif
    if (args.size() == 2) {
        data = (uint)(*Register);
        str_tmp<<std::setw(14)<<std::left<<(Register->name());
        str_tmp<<"0x"<<std::setw(8)<<std::hex<<std::uppercase<<std::left<<data<<"\n";
        ret = str_tmp.str();
    } else if ((args.size() == 3) && (args[2] == "release")) {
        BlockReg = false;
    } else if ((args.size() == 4) && (args[2] == "force")) {
        errno = 0; data = (uint) strtoul(args[3].c_str(), &err_p, 0);
        #ifdef REGIF_NOT_USE_SYSTEMC
        assert(err_p != NULL);
        #else
        sc_assert(err_p != NULL);
        #endif
        if (errno != ERANGE && *err_p == '\0') {
            *Register = data;
            BlockReg = true;
            UpdateLocalVal(Register->addr());
        } else {
            ret = err_msg + "[" + Register->name() + "] Invalid force value\n";
        }
    } else if ((args.size() >= 3) && (args[2] == "MessageLevel")) {
        if (args.size() == 3) {
            ret = Register->name() + " ";
            ret += Register->GetMessageLevel();
        } else if (args.size() == 4) {
            std::map<std::string, bool> MessageLevel;
            std::vector<std::string> arg_vec = Str2Vec(args[3], '|');
            std::vector<std::string>::iterator it;
            for (it = arg_vec.begin(); it != arg_vec.end(); it++) {
                MessageLevel[*it] = true;
            }
            Register->SetMessageLevel(MessageLevel);
        } else {
            ret = err_msg + "[" + Register->name() + "] MessageLevel has too much arguments\n";
        }
    } else if ((args.size() == 3) && (args[2] != "release")) {
        errno = 0; data = (uint) strtoul(args[2].c_str(), &err_p, 0);
        if (errno != ERANGE && *err_p == '\0') {
            *Register = data;
            UpdateLocalVal(Register->addr());
        } else {
            ret = err_msg + "[" + Register->name() + "] Invalid write value\n";
        }
    } else {
        ret = err_msg + "Wrong command : ";
        for (uint index = 0; index < args.size(); index ++) {
            ret += args[index] + " ";
        }
    }
    return ret;
}

/// Initialize local variables
/// @return none
void Cbist_regif::InitLocalVal()
{
    // Initialize local variables
    LBISTREF1_LBISTREF1 = 0xA5A5A;
    LBISTREF2_LBISTREF2 = 0x5A5A5;
    MBISTREF1_MBISTREF1 = 0xAA55A;
    MBISTREF2_MBISTREF2 = 0x55AA5;
    LBISTSIG1_LBISTSIG1 = 0x5A5A5;
    LBISTSIG2_LBISTSIG2 = 0xA5A5A;
    MBISTSIG1_MBISTSIG1 = 0x55AA5;
    MBISTSIG2_MBISTSIG2 = 0xAA55A;
    MBISTFTAGL1_MBISTFTAGL131 = 0x1;
    MBISTFTAGL1_MBISTFTAGL130 = 0x1;
    MBISTFTAGL1_MBISTFTAGL129 = 0x1;
    MBISTFTAGL1_MBISTFTAGL128 = 0x1;
    MBISTFTAGL1_MBISTFTAGL127 = 0x1;
    MBISTFTAGL1_MBISTFTAGL126 = 0x1;
    MBISTFTAGL1_MBISTFTAGL125 = 0x1;
    MBISTFTAGL1_MBISTFTAGL124 = 0x1;
    MBISTFTAGL1_MBISTFTAGL123 = 0x1;
    MBISTFTAGL1_MBISTFTAGL122 = 0x1;
    MBISTFTAGL1_MBISTFTAGL121 = 0x1;
    MBISTFTAGL1_MBISTFTAGL120 = 0x1;
    MBISTFTAGL1_MBISTFTAGL119 = 0x1;
    MBISTFTAGL1_MBISTFTAGL118 = 0x1;
    MBISTFTAGL1_MBISTFTAGL117 = 0x1;
    MBISTFTAGL1_MBISTFTAGL116 = 0x1;
    MBISTFTAGL1_MBISTFTAGL115 = 0x1;
    MBISTFTAGL1_MBISTFTAGL114 = 0x1;
    MBISTFTAGL1_MBISTFTAGL113 = 0x1;
    MBISTFTAGL1_MBISTFTAGL112 = 0x1;
    MBISTFTAGL1_MBISTFTAGL111 = 0x1;
    MBISTFTAGL1_MBISTFTAGL110 = 0x1;
    MBISTFTAGL1_MBISTFTAGL109 = 0x1;
    MBISTFTAGL1_MBISTFTAGL108 = 0x1;
    MBISTFTAGL1_MBISTFTAGL107 = 0x1;
    MBISTFTAGL1_MBISTFTAGL106 = 0x1;
    MBISTFTAGL1_MBISTFTAGL105 = 0x1;
    MBISTFTAGL1_MBISTFTAGL104 = 0x1;
    MBISTFTAGL1_MBISTFTAGL103 = 0x1;
    MBISTFTAGL1_MBISTFTAGL102 = 0x1;
    MBISTFTAGL1_MBISTFTAGL101 = 0x1;
    MBISTFTAGL1_MBISTFTAGL100 = 0x1;
    MBISTFTAGH1_MBISTFTAGH131 = 0x1;
    MBISTFTAGH1_MBISTFTAGH130 = 0x1;
    MBISTFTAGH1_MBISTFTAGH129 = 0x1;
    MBISTFTAGH1_MBISTFTAGH128 = 0x1;
    MBISTFTAGH1_MBISTFTAGH127 = 0x1;
    MBISTFTAGH1_MBISTFTAGH126 = 0x1;
    MBISTFTAGH1_MBISTFTAGH125 = 0x1;
    MBISTFTAGH1_MBISTFTAGH124 = 0x1;
    MBISTFTAGH1_MBISTFTAGH123 = 0x1;
    MBISTFTAGH1_MBISTFTAGH122 = 0x1;
    MBISTFTAGH1_MBISTFTAGH121 = 0x1;
    MBISTFTAGH1_MBISTFTAGH120 = 0x1;
    MBISTFTAGH1_MBISTFTAGH119 = 0x1;
    MBISTFTAGH1_MBISTFTAGH118 = 0x1;
    MBISTFTAGH1_MBISTFTAGH117 = 0x1;
    MBISTFTAGH1_MBISTFTAGH116 = 0x1;
    MBISTFTAGH1_MBISTFTAGH115 = 0x1;
    MBISTFTAGH1_MBISTFTAGH114 = 0x1;
    MBISTFTAGH1_MBISTFTAGH113 = 0x1;
    MBISTFTAGH1_MBISTFTAGH112 = 0x1;
    MBISTFTAGH1_MBISTFTAGH111 = 0x1;
    MBISTFTAGH1_MBISTFTAGH110 = 0x1;
    MBISTFTAGH1_MBISTFTAGH109 = 0x1;
    MBISTFTAGH1_MBISTFTAGH108 = 0x1;
    MBISTFTAGH1_MBISTFTAGH107 = 0x1;
    MBISTFTAGH1_MBISTFTAGH106 = 0x1;
    MBISTFTAGH1_MBISTFTAGH105 = 0x1;
    MBISTFTAGH1_MBISTFTAGH104 = 0x1;
    MBISTFTAGH1_MBISTFTAGH103 = 0x1;
    MBISTFTAGH1_MBISTFTAGH102 = 0x1;
    MBISTFTAGH1_MBISTFTAGH101 = 0x1;
    MBISTFTAGH1_MBISTFTAGH100 = 0x1;
    MBISTFTAGL2_MBISTFTAGL231 = 0x1;
    MBISTFTAGL2_MBISTFTAGL230 = 0x1;
    MBISTFTAGL2_MBISTFTAGL229 = 0x1;
    MBISTFTAGL2_MBISTFTAGL228 = 0x1;
    MBISTFTAGL2_MBISTFTAGL227 = 0x1;
    MBISTFTAGL2_MBISTFTAGL226 = 0x1;
    MBISTFTAGL2_MBISTFTAGL225 = 0x1;
    MBISTFTAGL2_MBISTFTAGL224 = 0x1;
    MBISTFTAGL2_MBISTFTAGL223 = 0x1;
    MBISTFTAGL2_MBISTFTAGL222 = 0x1;
    MBISTFTAGL2_MBISTFTAGL221 = 0x1;
    MBISTFTAGL2_MBISTFTAGL220 = 0x1;
    MBISTFTAGL2_MBISTFTAGL219 = 0x1;
    MBISTFTAGL2_MBISTFTAGL218 = 0x1;
    MBISTFTAGL2_MBISTFTAGL217 = 0x1;
    MBISTFTAGL2_MBISTFTAGL216 = 0x1;
    MBISTFTAGL2_MBISTFTAGL215 = 0x1;
    MBISTFTAGL2_MBISTFTAGL214 = 0x1;
    MBISTFTAGL2_MBISTFTAGL213 = 0x1;
    MBISTFTAGL2_MBISTFTAGL212 = 0x1;
    MBISTFTAGL2_MBISTFTAGL211 = 0x1;
    MBISTFTAGL2_MBISTFTAGL210 = 0x1;
    MBISTFTAGL2_MBISTFTAGL209 = 0x1;
    MBISTFTAGL2_MBISTFTAGL208 = 0x1;
    MBISTFTAGL2_MBISTFTAGL207 = 0x1;
    MBISTFTAGL2_MBISTFTAGL206 = 0x1;
    MBISTFTAGL2_MBISTFTAGL205 = 0x1;
    MBISTFTAGL2_MBISTFTAGL204 = 0x1;
    MBISTFTAGL2_MBISTFTAGL203 = 0x1;
    MBISTFTAGL2_MBISTFTAGL202 = 0x1;
    MBISTFTAGL2_MBISTFTAGL201 = 0x1;
    MBISTFTAGL2_MBISTFTAGL200 = 0x1;
    MBISTFTAGH2_MBISTFTAGH231 = 0x1;
    MBISTFTAGH2_MBISTFTAGH230 = 0x1;
    MBISTFTAGH2_MBISTFTAGH229 = 0x1;
    MBISTFTAGH2_MBISTFTAGH228 = 0x1;
    MBISTFTAGH2_MBISTFTAGH227 = 0x1;
    MBISTFTAGH2_MBISTFTAGH226 = 0x1;
    MBISTFTAGH2_MBISTFTAGH225 = 0x1;
    MBISTFTAGH2_MBISTFTAGH224 = 0x1;
    MBISTFTAGH2_MBISTFTAGH223 = 0x1;
    MBISTFTAGH2_MBISTFTAGH222 = 0x1;
    MBISTFTAGH2_MBISTFTAGH221 = 0x1;
    MBISTFTAGH2_MBISTFTAGH220 = 0x1;
    MBISTFTAGH2_MBISTFTAGH219 = 0x1;
    MBISTFTAGH2_MBISTFTAGH218 = 0x1;
    MBISTFTAGH2_MBISTFTAGH217 = 0x1;
    MBISTFTAGH2_MBISTFTAGH216 = 0x1;
    MBISTFTAGH2_MBISTFTAGH215 = 0x1;
    MBISTFTAGH2_MBISTFTAGH214 = 0x1;
    MBISTFTAGH2_MBISTFTAGH213 = 0x1;
    MBISTFTAGH2_MBISTFTAGH212 = 0x1;
    MBISTFTAGH2_MBISTFTAGH211 = 0x1;
    MBISTFTAGH2_MBISTFTAGH210 = 0x1;
    MBISTFTAGH2_MBISTFTAGH209 = 0x1;
    MBISTFTAGH2_MBISTFTAGH208 = 0x1;
    MBISTFTAGH2_MBISTFTAGH207 = 0x1;
    MBISTFTAGH2_MBISTFTAGH206 = 0x1;
    MBISTFTAGH2_MBISTFTAGH205 = 0x1;
    MBISTFTAGH2_MBISTFTAGH204 = 0x1;
    MBISTFTAGH2_MBISTFTAGH203 = 0x1;
    MBISTFTAGH2_MBISTFTAGH202 = 0x1;
    MBISTFTAGH2_MBISTFTAGH201 = 0x1;
    MBISTFTAGH2_MBISTFTAGH200 = 0x1;
    BSEQ0ST_BISTEND = 0x0;
    BSEQ0ST_CMPERR = 0x1;
    BSEQ0STB_BISTENDB = 0x1;
    BSEQ0STB_CMPERRB = 0x0;
    BISTST_MBIST2ST = 0x1;
    BISTST_MBIST1ST = 0x1;
    BISTST_LBIST2ST = 0x1;
    BISTST_LBIST1ST = 0x1;
}

/// Update bit value to local value
/// @return None
void Cbist_regif::UpdateLocalVal(cuint addr)
{
    if (addr == 0x0000) {
        LBISTREF1_LBISTREF1             = (*LBISTREF1  )["LBISTREF1"  ];
        return;
    }
    if (addr == 0x0004) {
        LBISTREF2_LBISTREF2             = (*LBISTREF2  )["LBISTREF2"  ];
        return;
    }
    if (addr == 0x0008) {
        MBISTREF1_MBISTREF1             = (*MBISTREF1  )["MBISTREF1"  ];
        return;
    }
    if (addr == 0x000C) {
        MBISTREF2_MBISTREF2             = (*MBISTREF2  )["MBISTREF2"  ];
        return;
    }
    if (addr == 0x0010) {
        LBISTSIG1_LBISTSIG1             = (*LBISTSIG1  )["LBISTSIG1"  ];
        return;
    }
    if (addr == 0x0014) {
        LBISTSIG2_LBISTSIG2             = (*LBISTSIG2  )["LBISTSIG2"  ];
        return;
    }
    if (addr == 0x0018) {
        MBISTSIG1_MBISTSIG1             = (*MBISTSIG1  )["MBISTSIG1"  ];
        return;
    }
    if (addr == 0x001C) {
        MBISTSIG2_MBISTSIG2             = (*MBISTSIG2  )["MBISTSIG2"  ];
        return;
    }
    if (addr == 0x0020) {
        MBISTFTAGL1_MBISTFTAGL131       = (*MBISTFTAGL1)["MBISTFTAGL131"];
        MBISTFTAGL1_MBISTFTAGL130       = (*MBISTFTAGL1)["MBISTFTAGL130"];
        MBISTFTAGL1_MBISTFTAGL129       = (*MBISTFTAGL1)["MBISTFTAGL129"];
        MBISTFTAGL1_MBISTFTAGL128       = (*MBISTFTAGL1)["MBISTFTAGL128"];
        MBISTFTAGL1_MBISTFTAGL127       = (*MBISTFTAGL1)["MBISTFTAGL127"];
        MBISTFTAGL1_MBISTFTAGL126       = (*MBISTFTAGL1)["MBISTFTAGL126"];
        MBISTFTAGL1_MBISTFTAGL125       = (*MBISTFTAGL1)["MBISTFTAGL125"];
        MBISTFTAGL1_MBISTFTAGL124       = (*MBISTFTAGL1)["MBISTFTAGL124"];
        MBISTFTAGL1_MBISTFTAGL123       = (*MBISTFTAGL1)["MBISTFTAGL123"];
        MBISTFTAGL1_MBISTFTAGL122       = (*MBISTFTAGL1)["MBISTFTAGL122"];
        MBISTFTAGL1_MBISTFTAGL121       = (*MBISTFTAGL1)["MBISTFTAGL121"];
        MBISTFTAGL1_MBISTFTAGL120       = (*MBISTFTAGL1)["MBISTFTAGL120"];
        MBISTFTAGL1_MBISTFTAGL119       = (*MBISTFTAGL1)["MBISTFTAGL119"];
        MBISTFTAGL1_MBISTFTAGL118       = (*MBISTFTAGL1)["MBISTFTAGL118"];
        MBISTFTAGL1_MBISTFTAGL117       = (*MBISTFTAGL1)["MBISTFTAGL117"];
        MBISTFTAGL1_MBISTFTAGL116       = (*MBISTFTAGL1)["MBISTFTAGL116"];
        MBISTFTAGL1_MBISTFTAGL115       = (*MBISTFTAGL1)["MBISTFTAGL115"];
        MBISTFTAGL1_MBISTFTAGL114       = (*MBISTFTAGL1)["MBISTFTAGL114"];
        MBISTFTAGL1_MBISTFTAGL113       = (*MBISTFTAGL1)["MBISTFTAGL113"];
        MBISTFTAGL1_MBISTFTAGL112       = (*MBISTFTAGL1)["MBISTFTAGL112"];
        MBISTFTAGL1_MBISTFTAGL111       = (*MBISTFTAGL1)["MBISTFTAGL111"];
        MBISTFTAGL1_MBISTFTAGL110       = (*MBISTFTAGL1)["MBISTFTAGL110"];
        MBISTFTAGL1_MBISTFTAGL109       = (*MBISTFTAGL1)["MBISTFTAGL109"];
        MBISTFTAGL1_MBISTFTAGL108       = (*MBISTFTAGL1)["MBISTFTAGL108"];
        MBISTFTAGL1_MBISTFTAGL107       = (*MBISTFTAGL1)["MBISTFTAGL107"];
        MBISTFTAGL1_MBISTFTAGL106       = (*MBISTFTAGL1)["MBISTFTAGL106"];
        MBISTFTAGL1_MBISTFTAGL105       = (*MBISTFTAGL1)["MBISTFTAGL105"];
        MBISTFTAGL1_MBISTFTAGL104       = (*MBISTFTAGL1)["MBISTFTAGL104"];
        MBISTFTAGL1_MBISTFTAGL103       = (*MBISTFTAGL1)["MBISTFTAGL103"];
        MBISTFTAGL1_MBISTFTAGL102       = (*MBISTFTAGL1)["MBISTFTAGL102"];
        MBISTFTAGL1_MBISTFTAGL101       = (*MBISTFTAGL1)["MBISTFTAGL101"];
        MBISTFTAGL1_MBISTFTAGL100       = (*MBISTFTAGL1)["MBISTFTAGL100"];
        return;
    }
    if (addr == 0x0024) {
        MBISTFTAGH1_MBISTFTAGH131       = (*MBISTFTAGH1)["MBISTFTAGH131"];
        MBISTFTAGH1_MBISTFTAGH130       = (*MBISTFTAGH1)["MBISTFTAGH130"];
        MBISTFTAGH1_MBISTFTAGH129       = (*MBISTFTAGH1)["MBISTFTAGH129"];
        MBISTFTAGH1_MBISTFTAGH128       = (*MBISTFTAGH1)["MBISTFTAGH128"];
        MBISTFTAGH1_MBISTFTAGH127       = (*MBISTFTAGH1)["MBISTFTAGH127"];
        MBISTFTAGH1_MBISTFTAGH126       = (*MBISTFTAGH1)["MBISTFTAGH126"];
        MBISTFTAGH1_MBISTFTAGH125       = (*MBISTFTAGH1)["MBISTFTAGH125"];
        MBISTFTAGH1_MBISTFTAGH124       = (*MBISTFTAGH1)["MBISTFTAGH124"];
        MBISTFTAGH1_MBISTFTAGH123       = (*MBISTFTAGH1)["MBISTFTAGH123"];
        MBISTFTAGH1_MBISTFTAGH122       = (*MBISTFTAGH1)["MBISTFTAGH122"];
        MBISTFTAGH1_MBISTFTAGH121       = (*MBISTFTAGH1)["MBISTFTAGH121"];
        MBISTFTAGH1_MBISTFTAGH120       = (*MBISTFTAGH1)["MBISTFTAGH120"];
        MBISTFTAGH1_MBISTFTAGH119       = (*MBISTFTAGH1)["MBISTFTAGH119"];
        MBISTFTAGH1_MBISTFTAGH118       = (*MBISTFTAGH1)["MBISTFTAGH118"];
        MBISTFTAGH1_MBISTFTAGH117       = (*MBISTFTAGH1)["MBISTFTAGH117"];
        MBISTFTAGH1_MBISTFTAGH116       = (*MBISTFTAGH1)["MBISTFTAGH116"];
        MBISTFTAGH1_MBISTFTAGH115       = (*MBISTFTAGH1)["MBISTFTAGH115"];
        MBISTFTAGH1_MBISTFTAGH114       = (*MBISTFTAGH1)["MBISTFTAGH114"];
        MBISTFTAGH1_MBISTFTAGH113       = (*MBISTFTAGH1)["MBISTFTAGH113"];
        MBISTFTAGH1_MBISTFTAGH112       = (*MBISTFTAGH1)["MBISTFTAGH112"];
        MBISTFTAGH1_MBISTFTAGH111       = (*MBISTFTAGH1)["MBISTFTAGH111"];
        MBISTFTAGH1_MBISTFTAGH110       = (*MBISTFTAGH1)["MBISTFTAGH110"];
        MBISTFTAGH1_MBISTFTAGH109       = (*MBISTFTAGH1)["MBISTFTAGH109"];
        MBISTFTAGH1_MBISTFTAGH108       = (*MBISTFTAGH1)["MBISTFTAGH108"];
        MBISTFTAGH1_MBISTFTAGH107       = (*MBISTFTAGH1)["MBISTFTAGH107"];
        MBISTFTAGH1_MBISTFTAGH106       = (*MBISTFTAGH1)["MBISTFTAGH106"];
        MBISTFTAGH1_MBISTFTAGH105       = (*MBISTFTAGH1)["MBISTFTAGH105"];
        MBISTFTAGH1_MBISTFTAGH104       = (*MBISTFTAGH1)["MBISTFTAGH104"];
        MBISTFTAGH1_MBISTFTAGH103       = (*MBISTFTAGH1)["MBISTFTAGH103"];
        MBISTFTAGH1_MBISTFTAGH102       = (*MBISTFTAGH1)["MBISTFTAGH102"];
        MBISTFTAGH1_MBISTFTAGH101       = (*MBISTFTAGH1)["MBISTFTAGH101"];
        MBISTFTAGH1_MBISTFTAGH100       = (*MBISTFTAGH1)["MBISTFTAGH100"];
        return;
    }
    if (addr == 0x0028) {
        MBISTFTAGL2_MBISTFTAGL231       = (*MBISTFTAGL2)["MBISTFTAGL231"];
        MBISTFTAGL2_MBISTFTAGL230       = (*MBISTFTAGL2)["MBISTFTAGL230"];
        MBISTFTAGL2_MBISTFTAGL229       = (*MBISTFTAGL2)["MBISTFTAGL229"];
        MBISTFTAGL2_MBISTFTAGL228       = (*MBISTFTAGL2)["MBISTFTAGL228"];
        MBISTFTAGL2_MBISTFTAGL227       = (*MBISTFTAGL2)["MBISTFTAGL227"];
        MBISTFTAGL2_MBISTFTAGL226       = (*MBISTFTAGL2)["MBISTFTAGL226"];
        MBISTFTAGL2_MBISTFTAGL225       = (*MBISTFTAGL2)["MBISTFTAGL225"];
        MBISTFTAGL2_MBISTFTAGL224       = (*MBISTFTAGL2)["MBISTFTAGL224"];
        MBISTFTAGL2_MBISTFTAGL223       = (*MBISTFTAGL2)["MBISTFTAGL223"];
        MBISTFTAGL2_MBISTFTAGL222       = (*MBISTFTAGL2)["MBISTFTAGL222"];
        MBISTFTAGL2_MBISTFTAGL221       = (*MBISTFTAGL2)["MBISTFTAGL221"];
        MBISTFTAGL2_MBISTFTAGL220       = (*MBISTFTAGL2)["MBISTFTAGL220"];
        MBISTFTAGL2_MBISTFTAGL219       = (*MBISTFTAGL2)["MBISTFTAGL219"];
        MBISTFTAGL2_MBISTFTAGL218       = (*MBISTFTAGL2)["MBISTFTAGL218"];
        MBISTFTAGL2_MBISTFTAGL217       = (*MBISTFTAGL2)["MBISTFTAGL217"];
        MBISTFTAGL2_MBISTFTAGL216       = (*MBISTFTAGL2)["MBISTFTAGL216"];
        MBISTFTAGL2_MBISTFTAGL215       = (*MBISTFTAGL2)["MBISTFTAGL215"];
        MBISTFTAGL2_MBISTFTAGL214       = (*MBISTFTAGL2)["MBISTFTAGL214"];
        MBISTFTAGL2_MBISTFTAGL213       = (*MBISTFTAGL2)["MBISTFTAGL213"];
        MBISTFTAGL2_MBISTFTAGL212       = (*MBISTFTAGL2)["MBISTFTAGL212"];
        MBISTFTAGL2_MBISTFTAGL211       = (*MBISTFTAGL2)["MBISTFTAGL211"];
        MBISTFTAGL2_MBISTFTAGL210       = (*MBISTFTAGL2)["MBISTFTAGL210"];
        MBISTFTAGL2_MBISTFTAGL209       = (*MBISTFTAGL2)["MBISTFTAGL209"];
        MBISTFTAGL2_MBISTFTAGL208       = (*MBISTFTAGL2)["MBISTFTAGL208"];
        MBISTFTAGL2_MBISTFTAGL207       = (*MBISTFTAGL2)["MBISTFTAGL207"];
        MBISTFTAGL2_MBISTFTAGL206       = (*MBISTFTAGL2)["MBISTFTAGL206"];
        MBISTFTAGL2_MBISTFTAGL205       = (*MBISTFTAGL2)["MBISTFTAGL205"];
        MBISTFTAGL2_MBISTFTAGL204       = (*MBISTFTAGL2)["MBISTFTAGL204"];
        MBISTFTAGL2_MBISTFTAGL203       = (*MBISTFTAGL2)["MBISTFTAGL203"];
        MBISTFTAGL2_MBISTFTAGL202       = (*MBISTFTAGL2)["MBISTFTAGL202"];
        MBISTFTAGL2_MBISTFTAGL201       = (*MBISTFTAGL2)["MBISTFTAGL201"];
        MBISTFTAGL2_MBISTFTAGL200       = (*MBISTFTAGL2)["MBISTFTAGL200"];
        return;
    }
    if (addr == 0x002C) {
        MBISTFTAGH2_MBISTFTAGH231       = (*MBISTFTAGH2)["MBISTFTAGH231"];
        MBISTFTAGH2_MBISTFTAGH230       = (*MBISTFTAGH2)["MBISTFTAGH230"];
        MBISTFTAGH2_MBISTFTAGH229       = (*MBISTFTAGH2)["MBISTFTAGH229"];
        MBISTFTAGH2_MBISTFTAGH228       = (*MBISTFTAGH2)["MBISTFTAGH228"];
        MBISTFTAGH2_MBISTFTAGH227       = (*MBISTFTAGH2)["MBISTFTAGH227"];
        MBISTFTAGH2_MBISTFTAGH226       = (*MBISTFTAGH2)["MBISTFTAGH226"];
        MBISTFTAGH2_MBISTFTAGH225       = (*MBISTFTAGH2)["MBISTFTAGH225"];
        MBISTFTAGH2_MBISTFTAGH224       = (*MBISTFTAGH2)["MBISTFTAGH224"];
        MBISTFTAGH2_MBISTFTAGH223       = (*MBISTFTAGH2)["MBISTFTAGH223"];
        MBISTFTAGH2_MBISTFTAGH222       = (*MBISTFTAGH2)["MBISTFTAGH222"];
        MBISTFTAGH2_MBISTFTAGH221       = (*MBISTFTAGH2)["MBISTFTAGH221"];
        MBISTFTAGH2_MBISTFTAGH220       = (*MBISTFTAGH2)["MBISTFTAGH220"];
        MBISTFTAGH2_MBISTFTAGH219       = (*MBISTFTAGH2)["MBISTFTAGH219"];
        MBISTFTAGH2_MBISTFTAGH218       = (*MBISTFTAGH2)["MBISTFTAGH218"];
        MBISTFTAGH2_MBISTFTAGH217       = (*MBISTFTAGH2)["MBISTFTAGH217"];
        MBISTFTAGH2_MBISTFTAGH216       = (*MBISTFTAGH2)["MBISTFTAGH216"];
        MBISTFTAGH2_MBISTFTAGH215       = (*MBISTFTAGH2)["MBISTFTAGH215"];
        MBISTFTAGH2_MBISTFTAGH214       = (*MBISTFTAGH2)["MBISTFTAGH214"];
        MBISTFTAGH2_MBISTFTAGH213       = (*MBISTFTAGH2)["MBISTFTAGH213"];
        MBISTFTAGH2_MBISTFTAGH212       = (*MBISTFTAGH2)["MBISTFTAGH212"];
        MBISTFTAGH2_MBISTFTAGH211       = (*MBISTFTAGH2)["MBISTFTAGH211"];
        MBISTFTAGH2_MBISTFTAGH210       = (*MBISTFTAGH2)["MBISTFTAGH210"];
        MBISTFTAGH2_MBISTFTAGH209       = (*MBISTFTAGH2)["MBISTFTAGH209"];
        MBISTFTAGH2_MBISTFTAGH208       = (*MBISTFTAGH2)["MBISTFTAGH208"];
        MBISTFTAGH2_MBISTFTAGH207       = (*MBISTFTAGH2)["MBISTFTAGH207"];
        MBISTFTAGH2_MBISTFTAGH206       = (*MBISTFTAGH2)["MBISTFTAGH206"];
        MBISTFTAGH2_MBISTFTAGH205       = (*MBISTFTAGH2)["MBISTFTAGH205"];
        MBISTFTAGH2_MBISTFTAGH204       = (*MBISTFTAGH2)["MBISTFTAGH204"];
        MBISTFTAGH2_MBISTFTAGH203       = (*MBISTFTAGH2)["MBISTFTAGH203"];
        MBISTFTAGH2_MBISTFTAGH202       = (*MBISTFTAGH2)["MBISTFTAGH202"];
        MBISTFTAGH2_MBISTFTAGH201       = (*MBISTFTAGH2)["MBISTFTAGH201"];
        MBISTFTAGH2_MBISTFTAGH200       = (*MBISTFTAGH2)["MBISTFTAGH200"];
        return;
    }
    if (addr == 0x0030) {
        BSEQ0ST_BISTEND                 = (*BSEQ0ST    )["BISTEND"    ];
        BSEQ0ST_CMPERR                  = (*BSEQ0ST    )["CMPERR"     ];
        return;
    }
    if (addr == 0x0034) {
        BSEQ0STB_BISTENDB               = (*BSEQ0STB   )["BISTENDB"   ];
        BSEQ0STB_CMPERRB                = (*BSEQ0STB   )["CMPERRB"    ];
        return;
    }
    if (addr == 0x0038) {
        BISTST_MBIST2ST                 = (*BISTST     )["MBIST2ST"   ];
        BISTST_MBIST1ST                 = (*BISTST     )["MBIST1ST"   ];
        BISTST_LBIST2ST                 = (*BISTST     )["LBIST2ST"   ];
        BISTST_LBIST1ST                 = (*BISTST     )["LBIST1ST"   ];
        return;
    }
}

/// Update local value to bit value
/// @return None
void Cbist_regif::UpdateRegVal(cuint addr)
{
    if (addr == 0x0000) {
        (*LBISTREF1  )["LBISTREF1"  ] = LBISTREF1_LBISTREF1;
        return;
    }
    if (addr == 0x0004) {
        (*LBISTREF2  )["LBISTREF2"  ] = LBISTREF2_LBISTREF2;
        return;
    }
    if (addr == 0x0008) {
        (*MBISTREF1  )["MBISTREF1"  ] = MBISTREF1_MBISTREF1;
        return;
    }
    if (addr == 0x000C) {
        (*MBISTREF2  )["MBISTREF2"  ] = MBISTREF2_MBISTREF2;
        return;
    }
    if (addr == 0x0010) {
        (*LBISTSIG1  )["LBISTSIG1"  ] = LBISTSIG1_LBISTSIG1;
        return;
    }
    if (addr == 0x0014) {
        (*LBISTSIG2  )["LBISTSIG2"  ] = LBISTSIG2_LBISTSIG2;
        return;
    }
    if (addr == 0x0018) {
        (*MBISTSIG1  )["MBISTSIG1"  ] = MBISTSIG1_MBISTSIG1;
        return;
    }
    if (addr == 0x001C) {
        (*MBISTSIG2  )["MBISTSIG2"  ] = MBISTSIG2_MBISTSIG2;
        return;
    }
    if (addr == 0x0020) {
        (*MBISTFTAGL1)["MBISTFTAGL131"] = MBISTFTAGL1_MBISTFTAGL131;
        (*MBISTFTAGL1)["MBISTFTAGL130"] = MBISTFTAGL1_MBISTFTAGL130;
        (*MBISTFTAGL1)["MBISTFTAGL129"] = MBISTFTAGL1_MBISTFTAGL129;
        (*MBISTFTAGL1)["MBISTFTAGL128"] = MBISTFTAGL1_MBISTFTAGL128;
        (*MBISTFTAGL1)["MBISTFTAGL127"] = MBISTFTAGL1_MBISTFTAGL127;
        (*MBISTFTAGL1)["MBISTFTAGL126"] = MBISTFTAGL1_MBISTFTAGL126;
        (*MBISTFTAGL1)["MBISTFTAGL125"] = MBISTFTAGL1_MBISTFTAGL125;
        (*MBISTFTAGL1)["MBISTFTAGL124"] = MBISTFTAGL1_MBISTFTAGL124;
        (*MBISTFTAGL1)["MBISTFTAGL123"] = MBISTFTAGL1_MBISTFTAGL123;
        (*MBISTFTAGL1)["MBISTFTAGL122"] = MBISTFTAGL1_MBISTFTAGL122;
        (*MBISTFTAGL1)["MBISTFTAGL121"] = MBISTFTAGL1_MBISTFTAGL121;
        (*MBISTFTAGL1)["MBISTFTAGL120"] = MBISTFTAGL1_MBISTFTAGL120;
        (*MBISTFTAGL1)["MBISTFTAGL119"] = MBISTFTAGL1_MBISTFTAGL119;
        (*MBISTFTAGL1)["MBISTFTAGL118"] = MBISTFTAGL1_MBISTFTAGL118;
        (*MBISTFTAGL1)["MBISTFTAGL117"] = MBISTFTAGL1_MBISTFTAGL117;
        (*MBISTFTAGL1)["MBISTFTAGL116"] = MBISTFTAGL1_MBISTFTAGL116;
        (*MBISTFTAGL1)["MBISTFTAGL115"] = MBISTFTAGL1_MBISTFTAGL115;
        (*MBISTFTAGL1)["MBISTFTAGL114"] = MBISTFTAGL1_MBISTFTAGL114;
        (*MBISTFTAGL1)["MBISTFTAGL113"] = MBISTFTAGL1_MBISTFTAGL113;
        (*MBISTFTAGL1)["MBISTFTAGL112"] = MBISTFTAGL1_MBISTFTAGL112;
        (*MBISTFTAGL1)["MBISTFTAGL111"] = MBISTFTAGL1_MBISTFTAGL111;
        (*MBISTFTAGL1)["MBISTFTAGL110"] = MBISTFTAGL1_MBISTFTAGL110;
        (*MBISTFTAGL1)["MBISTFTAGL109"] = MBISTFTAGL1_MBISTFTAGL109;
        (*MBISTFTAGL1)["MBISTFTAGL108"] = MBISTFTAGL1_MBISTFTAGL108;
        (*MBISTFTAGL1)["MBISTFTAGL107"] = MBISTFTAGL1_MBISTFTAGL107;
        (*MBISTFTAGL1)["MBISTFTAGL106"] = MBISTFTAGL1_MBISTFTAGL106;
        (*MBISTFTAGL1)["MBISTFTAGL105"] = MBISTFTAGL1_MBISTFTAGL105;
        (*MBISTFTAGL1)["MBISTFTAGL104"] = MBISTFTAGL1_MBISTFTAGL104;
        (*MBISTFTAGL1)["MBISTFTAGL103"] = MBISTFTAGL1_MBISTFTAGL103;
        (*MBISTFTAGL1)["MBISTFTAGL102"] = MBISTFTAGL1_MBISTFTAGL102;
        (*MBISTFTAGL1)["MBISTFTAGL101"] = MBISTFTAGL1_MBISTFTAGL101;
        (*MBISTFTAGL1)["MBISTFTAGL100"] = MBISTFTAGL1_MBISTFTAGL100;
        return;
    }
    if (addr == 0x0024) {
        (*MBISTFTAGH1)["MBISTFTAGH131"] = MBISTFTAGH1_MBISTFTAGH131;
        (*MBISTFTAGH1)["MBISTFTAGH130"] = MBISTFTAGH1_MBISTFTAGH130;
        (*MBISTFTAGH1)["MBISTFTAGH129"] = MBISTFTAGH1_MBISTFTAGH129;
        (*MBISTFTAGH1)["MBISTFTAGH128"] = MBISTFTAGH1_MBISTFTAGH128;
        (*MBISTFTAGH1)["MBISTFTAGH127"] = MBISTFTAGH1_MBISTFTAGH127;
        (*MBISTFTAGH1)["MBISTFTAGH126"] = MBISTFTAGH1_MBISTFTAGH126;
        (*MBISTFTAGH1)["MBISTFTAGH125"] = MBISTFTAGH1_MBISTFTAGH125;
        (*MBISTFTAGH1)["MBISTFTAGH124"] = MBISTFTAGH1_MBISTFTAGH124;
        (*MBISTFTAGH1)["MBISTFTAGH123"] = MBISTFTAGH1_MBISTFTAGH123;
        (*MBISTFTAGH1)["MBISTFTAGH122"] = MBISTFTAGH1_MBISTFTAGH122;
        (*MBISTFTAGH1)["MBISTFTAGH121"] = MBISTFTAGH1_MBISTFTAGH121;
        (*MBISTFTAGH1)["MBISTFTAGH120"] = MBISTFTAGH1_MBISTFTAGH120;
        (*MBISTFTAGH1)["MBISTFTAGH119"] = MBISTFTAGH1_MBISTFTAGH119;
        (*MBISTFTAGH1)["MBISTFTAGH118"] = MBISTFTAGH1_MBISTFTAGH118;
        (*MBISTFTAGH1)["MBISTFTAGH117"] = MBISTFTAGH1_MBISTFTAGH117;
        (*MBISTFTAGH1)["MBISTFTAGH116"] = MBISTFTAGH1_MBISTFTAGH116;
        (*MBISTFTAGH1)["MBISTFTAGH115"] = MBISTFTAGH1_MBISTFTAGH115;
        (*MBISTFTAGH1)["MBISTFTAGH114"] = MBISTFTAGH1_MBISTFTAGH114;
        (*MBISTFTAGH1)["MBISTFTAGH113"] = MBISTFTAGH1_MBISTFTAGH113;
        (*MBISTFTAGH1)["MBISTFTAGH112"] = MBISTFTAGH1_MBISTFTAGH112;
        (*MBISTFTAGH1)["MBISTFTAGH111"] = MBISTFTAGH1_MBISTFTAGH111;
        (*MBISTFTAGH1)["MBISTFTAGH110"] = MBISTFTAGH1_MBISTFTAGH110;
        (*MBISTFTAGH1)["MBISTFTAGH109"] = MBISTFTAGH1_MBISTFTAGH109;
        (*MBISTFTAGH1)["MBISTFTAGH108"] = MBISTFTAGH1_MBISTFTAGH108;
        (*MBISTFTAGH1)["MBISTFTAGH107"] = MBISTFTAGH1_MBISTFTAGH107;
        (*MBISTFTAGH1)["MBISTFTAGH106"] = MBISTFTAGH1_MBISTFTAGH106;
        (*MBISTFTAGH1)["MBISTFTAGH105"] = MBISTFTAGH1_MBISTFTAGH105;
        (*MBISTFTAGH1)["MBISTFTAGH104"] = MBISTFTAGH1_MBISTFTAGH104;
        (*MBISTFTAGH1)["MBISTFTAGH103"] = MBISTFTAGH1_MBISTFTAGH103;
        (*MBISTFTAGH1)["MBISTFTAGH102"] = MBISTFTAGH1_MBISTFTAGH102;
        (*MBISTFTAGH1)["MBISTFTAGH101"] = MBISTFTAGH1_MBISTFTAGH101;
        (*MBISTFTAGH1)["MBISTFTAGH100"] = MBISTFTAGH1_MBISTFTAGH100;
        return;
    }
    if (addr == 0x0028) {
        (*MBISTFTAGL2)["MBISTFTAGL231"] = MBISTFTAGL2_MBISTFTAGL231;
        (*MBISTFTAGL2)["MBISTFTAGL230"] = MBISTFTAGL2_MBISTFTAGL230;
        (*MBISTFTAGL2)["MBISTFTAGL229"] = MBISTFTAGL2_MBISTFTAGL229;
        (*MBISTFTAGL2)["MBISTFTAGL228"] = MBISTFTAGL2_MBISTFTAGL228;
        (*MBISTFTAGL2)["MBISTFTAGL227"] = MBISTFTAGL2_MBISTFTAGL227;
        (*MBISTFTAGL2)["MBISTFTAGL226"] = MBISTFTAGL2_MBISTFTAGL226;
        (*MBISTFTAGL2)["MBISTFTAGL225"] = MBISTFTAGL2_MBISTFTAGL225;
        (*MBISTFTAGL2)["MBISTFTAGL224"] = MBISTFTAGL2_MBISTFTAGL224;
        (*MBISTFTAGL2)["MBISTFTAGL223"] = MBISTFTAGL2_MBISTFTAGL223;
        (*MBISTFTAGL2)["MBISTFTAGL222"] = MBISTFTAGL2_MBISTFTAGL222;
        (*MBISTFTAGL2)["MBISTFTAGL221"] = MBISTFTAGL2_MBISTFTAGL221;
        (*MBISTFTAGL2)["MBISTFTAGL220"] = MBISTFTAGL2_MBISTFTAGL220;
        (*MBISTFTAGL2)["MBISTFTAGL219"] = MBISTFTAGL2_MBISTFTAGL219;
        (*MBISTFTAGL2)["MBISTFTAGL218"] = MBISTFTAGL2_MBISTFTAGL218;
        (*MBISTFTAGL2)["MBISTFTAGL217"] = MBISTFTAGL2_MBISTFTAGL217;
        (*MBISTFTAGL2)["MBISTFTAGL216"] = MBISTFTAGL2_MBISTFTAGL216;
        (*MBISTFTAGL2)["MBISTFTAGL215"] = MBISTFTAGL2_MBISTFTAGL215;
        (*MBISTFTAGL2)["MBISTFTAGL214"] = MBISTFTAGL2_MBISTFTAGL214;
        (*MBISTFTAGL2)["MBISTFTAGL213"] = MBISTFTAGL2_MBISTFTAGL213;
        (*MBISTFTAGL2)["MBISTFTAGL212"] = MBISTFTAGL2_MBISTFTAGL212;
        (*MBISTFTAGL2)["MBISTFTAGL211"] = MBISTFTAGL2_MBISTFTAGL211;
        (*MBISTFTAGL2)["MBISTFTAGL210"] = MBISTFTAGL2_MBISTFTAGL210;
        (*MBISTFTAGL2)["MBISTFTAGL209"] = MBISTFTAGL2_MBISTFTAGL209;
        (*MBISTFTAGL2)["MBISTFTAGL208"] = MBISTFTAGL2_MBISTFTAGL208;
        (*MBISTFTAGL2)["MBISTFTAGL207"] = MBISTFTAGL2_MBISTFTAGL207;
        (*MBISTFTAGL2)["MBISTFTAGL206"] = MBISTFTAGL2_MBISTFTAGL206;
        (*MBISTFTAGL2)["MBISTFTAGL205"] = MBISTFTAGL2_MBISTFTAGL205;
        (*MBISTFTAGL2)["MBISTFTAGL204"] = MBISTFTAGL2_MBISTFTAGL204;
        (*MBISTFTAGL2)["MBISTFTAGL203"] = MBISTFTAGL2_MBISTFTAGL203;
        (*MBISTFTAGL2)["MBISTFTAGL202"] = MBISTFTAGL2_MBISTFTAGL202;
        (*MBISTFTAGL2)["MBISTFTAGL201"] = MBISTFTAGL2_MBISTFTAGL201;
        (*MBISTFTAGL2)["MBISTFTAGL200"] = MBISTFTAGL2_MBISTFTAGL200;
        return;
    }
    if (addr == 0x002C) {
        (*MBISTFTAGH2)["MBISTFTAGH231"] = MBISTFTAGH2_MBISTFTAGH231;
        (*MBISTFTAGH2)["MBISTFTAGH230"] = MBISTFTAGH2_MBISTFTAGH230;
        (*MBISTFTAGH2)["MBISTFTAGH229"] = MBISTFTAGH2_MBISTFTAGH229;
        (*MBISTFTAGH2)["MBISTFTAGH228"] = MBISTFTAGH2_MBISTFTAGH228;
        (*MBISTFTAGH2)["MBISTFTAGH227"] = MBISTFTAGH2_MBISTFTAGH227;
        (*MBISTFTAGH2)["MBISTFTAGH226"] = MBISTFTAGH2_MBISTFTAGH226;
        (*MBISTFTAGH2)["MBISTFTAGH225"] = MBISTFTAGH2_MBISTFTAGH225;
        (*MBISTFTAGH2)["MBISTFTAGH224"] = MBISTFTAGH2_MBISTFTAGH224;
        (*MBISTFTAGH2)["MBISTFTAGH223"] = MBISTFTAGH2_MBISTFTAGH223;
        (*MBISTFTAGH2)["MBISTFTAGH222"] = MBISTFTAGH2_MBISTFTAGH222;
        (*MBISTFTAGH2)["MBISTFTAGH221"] = MBISTFTAGH2_MBISTFTAGH221;
        (*MBISTFTAGH2)["MBISTFTAGH220"] = MBISTFTAGH2_MBISTFTAGH220;
        (*MBISTFTAGH2)["MBISTFTAGH219"] = MBISTFTAGH2_MBISTFTAGH219;
        (*MBISTFTAGH2)["MBISTFTAGH218"] = MBISTFTAGH2_MBISTFTAGH218;
        (*MBISTFTAGH2)["MBISTFTAGH217"] = MBISTFTAGH2_MBISTFTAGH217;
        (*MBISTFTAGH2)["MBISTFTAGH216"] = MBISTFTAGH2_MBISTFTAGH216;
        (*MBISTFTAGH2)["MBISTFTAGH215"] = MBISTFTAGH2_MBISTFTAGH215;
        (*MBISTFTAGH2)["MBISTFTAGH214"] = MBISTFTAGH2_MBISTFTAGH214;
        (*MBISTFTAGH2)["MBISTFTAGH213"] = MBISTFTAGH2_MBISTFTAGH213;
        (*MBISTFTAGH2)["MBISTFTAGH212"] = MBISTFTAGH2_MBISTFTAGH212;
        (*MBISTFTAGH2)["MBISTFTAGH211"] = MBISTFTAGH2_MBISTFTAGH211;
        (*MBISTFTAGH2)["MBISTFTAGH210"] = MBISTFTAGH2_MBISTFTAGH210;
        (*MBISTFTAGH2)["MBISTFTAGH209"] = MBISTFTAGH2_MBISTFTAGH209;
        (*MBISTFTAGH2)["MBISTFTAGH208"] = MBISTFTAGH2_MBISTFTAGH208;
        (*MBISTFTAGH2)["MBISTFTAGH207"] = MBISTFTAGH2_MBISTFTAGH207;
        (*MBISTFTAGH2)["MBISTFTAGH206"] = MBISTFTAGH2_MBISTFTAGH206;
        (*MBISTFTAGH2)["MBISTFTAGH205"] = MBISTFTAGH2_MBISTFTAGH205;
        (*MBISTFTAGH2)["MBISTFTAGH204"] = MBISTFTAGH2_MBISTFTAGH204;
        (*MBISTFTAGH2)["MBISTFTAGH203"] = MBISTFTAGH2_MBISTFTAGH203;
        (*MBISTFTAGH2)["MBISTFTAGH202"] = MBISTFTAGH2_MBISTFTAGH202;
        (*MBISTFTAGH2)["MBISTFTAGH201"] = MBISTFTAGH2_MBISTFTAGH201;
        (*MBISTFTAGH2)["MBISTFTAGH200"] = MBISTFTAGH2_MBISTFTAGH200;
        return;
    }
    if (addr == 0x0030) {
        (*BSEQ0ST    )["BISTEND"    ] = BSEQ0ST_BISTEND;
        (*BSEQ0ST    )["CMPERR"     ] = BSEQ0ST_CMPERR;
        return;
    }
    if (addr == 0x0034) {
        (*BSEQ0STB   )["BISTENDB"   ] = BSEQ0STB_BISTENDB;
        (*BSEQ0STB   )["CMPERRB"    ] = BSEQ0STB_CMPERRB;
        return;
    }
    if (addr == 0x0038) {
        (*BISTST     )["MBIST2ST"   ] = BISTST_MBIST2ST;
        (*BISTST     )["MBIST1ST"   ] = BISTST_MBIST1ST;
        (*BISTST     )["LBIST2ST"   ] = BISTST_LBIST2ST;
        (*BISTST     )["LBIST1ST"   ] = BISTST_LBIST1ST;
        return;
    }
}

/// convert string to vector
/// @return vector
std::vector<std::string> Cbist_regif::Str2Vec(std::string str, const char sep)
{
    std::vector<std::string> buf;
    std::string::size_type index = 0;
    for (uint i=0 ; i<str.size() ; i++) {
        if (str[i] == sep) {
            buf.push_back(str.substr(index, i-index));
            index = i+1;
        }
    }
    buf.push_back(str.substr(index));
    return buf;
}

/// Align nuber to hexadecimal format
/// @return aligned number
std::string Cbist_regif::Num2HexStr(cuint num, cuint num_length, bool space_strip)
{
    std::ostringstream str_tmp;
    #ifdef MSG_WO_WR_DATA
    str_tmp<<"0x"<<std::hex<<std::uppercase<<std::right<<num;
    str_tmp<<std::setfill(' ')<<std::setw(10-str_tmp.str().length())<<"";
    #else
    uint total_length = (num_length + 3)/4; // Calculate number of hexadecimal number
    str_tmp<<"0x"<<std::setfill('0')<<std::setw(total_length)<<std::hex<<std::uppercase<<std::right<<num;
    if (!space_strip) {
        str_tmp<<std::setfill(' ')<<std::setw(10-str_tmp.str().length())<<"";   
    }
    #endif
    return str_tmp.str();
}

/// Dump register access information
/// @return none
void Cbist_regif::DumpRegMsg(const std::string operation, const std::string RegName, const std::string BitName, cuint size, cuint addr, cuint wr_data, cuint pre_data, cuint data, cuint reg_length)
{
    if(mDumpRegisterRW == true) {
        std::string reg_name = RegName;
        std::ostringstream str_tmp;
        if (BitName != "") {
            reg_name += ":" + BitName;
        }
        str_tmp<<"REG ["<<std::setw(15)<<std::left<<reg_name<<"] ";
        str_tmp<<operation;
        str_tmp<<" Size= "<<size;
        str_tmp<<" Addr= "<<Num2HexStr(addr,6, false);
        if (operation == "R") {
            str_tmp<<" Data= "<<Num2HexStr(data    , reg_length, true);
        } else {
            #ifdef MSG_WO_WR_DATA
            str_tmp<<" Data= "<<Num2HexStr(pre_data, reg_length, false);
            #else
            str_tmp<<" Data= "<<Num2HexStr(wr_data , reg_length, false);
            str_tmp<<" : "    <<Num2HexStr(pre_data, reg_length, false);
            #endif
            str_tmp<<" => "   <<Num2HexStr(data    , reg_length, true);
        }
        re_printf("DumpRegMsg", "%s\n", str_tmp.str().c_str());
    }
}

/// find register pointer based on accessed address
/// @return accessed register pointer
int Cbist_regif::get_reg_index(cuint access_addr)
{
    if (mRegMap[access_addr] != (1<<6)) {
        return mRegMap[access_addr];
    } else {
        return -1;
    }
}

/// find first register pointer
/// @return first register pointer
vpcl::re_register *Cbist_regif::first_reg_object()
{
    mCurReg = mRegList;
    return mCurReg->my_p;
}

/// find next register pointer
/// @return next register pointer
vpcl::re_register *Cbist_regif::next_reg_object()
{
    if (mCurReg != NULL) {
        mCurReg = mCurReg->prev;
        if (mCurReg != NULL) {
            return mCurReg->my_p;
        }
    }
    return NULL;
}

/// write callback function of CoWare
/// @return none
void Cbist_regif::wr_cb(cuint addr, uint data)
{
    #ifdef CWR_SYSTEMC
    cwmem.put(data, addr&0xFFFF);
    #else
    array[addr&0xFFFF] = data;
    #endif
}

/// read callback function of CoWare
/// @return read data
Cbist_regif::uint Cbist_regif::rd_cb(cuint addr)
{
    #ifdef CWR_SYSTEMC
    return cwmem.get(addr&0xFFFF);
    #else
    return array[addr&0xFFFF];
    #endif
}

/// print message function
/// @return none
void Cbist_regif::_re_printf(std::string group, const char *message, ...)
{
    // message group check
    if (group == "DumpRegMsg") {
        group = "info";
    } else {
        #ifndef REGIF_SC_REPORT
        if (mMessageLevel[group] == false) return;
        #endif//REGIF_SC_REPORT
    }

    if (message == NULL) return;

    // print header
    #ifndef REGIF_NOT_USE_SYSTEMC
    std::stringstream t_stream;
    std::string cur_time;

    double tu_value = 0;
    std::string tu_name = "";
    if (sc_get_time_resolution() < sc_time(1, SC_PS)) {
        tu_value = 1000000000000000LL;
        tu_name = " fs";
    }
    else if (sc_get_time_resolution() < sc_time(1, SC_NS)) {
        tu_value = 1000000000000LL;
        tu_name = " ps";
    }
    else if (sc_get_time_resolution() < sc_time(1, SC_US)) {
        tu_value = 1000000000;
        tu_name = " ns";
    }
    else if (sc_get_time_resolution() < sc_time(1, SC_MS)) {
        tu_value = 1000000;
        tu_name = " us";
    }
    else if (sc_get_time_resolution() < sc_time(1, SC_SEC)) {
        tu_value = 1000;
        tu_name = " ms";
    }
    else {
        tu_value = 1;
        tu_name = " s";
    }
    t_stream << sc_time_stamp().value() * (uint64) (sc_get_time_resolution().to_seconds() * tu_value) << tu_name;

    cur_time = t_stream.str();
    #else
    std::string cur_time = "";
    #endif

    #ifndef REGIF_SC_REPORT
    #ifdef MSG_COLOR
    // color setting
    //
    // severity color       color Linux       Windows
    // fatal    RED         RED   \033[0;31m  FOREGROUND_RED
    // error    RED         BLUE  \033[0;34m  FOREGROUND_BLUE
    // warning  RED
    // info     BLUE
    #ifdef _WIN32
    HANDLE hStdout;
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    if (group == "fatal" || group == "error" || group == "warning") {
        SetConsoleTextAttribute(hStdout, FOREGROUND_RED);
    }
    else if (group == "info" ){
        SetConsoleTextAttribute(hStdout, FOREGROUND_BLUE);
    }
    #else
    if (group == "fatal" || group == "error" || group == "warning") {
        printf("\033[0;31m");
    }
    else if (group == "info" ){
        printf("\033[0;34m");
    }
    #endif
    #endif //MSG_COLOR
    printf("%8s [%20s] (%10s) ", group.c_str(), cur_time.c_str(), mInstName.c_str());
    #endif//REGIF_SC_REPORT

    // print body
    va_list argptr;
    va_start(argptr, message);
    if (argptr == NULL) return;
    #ifdef REGIF_SC_REPORT
    char str[1024];
    sprintf(str, "[%20s] ", cur_time.c_str());
    vsprintf(str+23, message, argptr);
    if (group == "fatal") {
        SC_REPORT_FATAL(mInstName.c_str(), str);
    }
    else if (group == "error") {
        SC_REPORT_ERROR(mInstName.c_str(), str);
    }
    else if (group == "warning") {
        SC_REPORT_WARNING(mInstName.c_str(), str);
    }
    else if (group == "info") {
        SC_REPORT_INFO(mInstName.c_str(), str);
    }
    #else //REGIF_SC_REPORT
    vprintf(message, argptr);
    #endif//REGIF_SC_REPORT

    #ifndef REGIF_SC_REPORT
    #ifdef DumpFileNameLineNum
    // print footer
    if (group == "fatal" || group == "error") {
        printf(" [%s:%d]\n", mFileName.c_str(), mLineNum);
    }
    #endif//DumpFileNameLineNum
    #endif//REGIF_SC_REPORT
    va_end(argptr);

    #ifndef REGIF_SC_REPORT
    #ifdef MSG_COLOR
    #ifdef _WIN32
    SetConsoleTextAttribute(hStdout, csbi.wAttributes);
    #else
    printf("\033[m");
    #endif
    #endif //MSG_COLOR
    #endif//REGIF_SC_REPORT

    fflush(stdout);
    fflush(stderr);

    if (group == "fatal") {
        exit(1);
    }
}

/// Get file name and line number
/// @return none
void Cbist_regif::get_fileline(std::string filename, int line_number)
{
    mFileName = filename;
    mLineNum  = line_number;
}

/// API for instance registration
/// @return none
void Cbist_regif::set_instance_name(std::string InstName)
{
    mInstName = InstName;
}

/// Method to change value of mIsReset
/// @return none
void Cbist_regif::EnableReset(const bool is_active)
{
    // update register IF class's reset status
    mIsReset = is_active;

    // update re_register's reset status
    for (uint i = 0; i < mTotalRegNum; i++) {
        mRegArray[i]->my_p->EnableReset(is_active);
        if (is_active) {
            re_printf("info", "Initialize %s (%08x)\n", mRegArray[i]->my_p->name().c_str(), (uint)(*mRegArray[i]->my_p));
        }
    }

    if(is_active) {
        InitLocalVal(); // Initialize local variable
    }
}

#ifdef CWR_SYSTEMC
uint Cbist_regif::cw_rd_cb(tlm::tlm_generic_payload& trans, int tag)
{
    unsigned char* ptr = (unsigned char*)trans.get_data_ptr();
    memset(ptr,0,sizeof(uint));
    reg_rd_dbg((cuint)tag, ptr, sizeof(uint));
    return sizeof(uint);
}

uint Cbist_regif::cw_wr_cb(tlm::tlm_generic_payload& trans, int tag)
{
    unsigned char* ptr = (unsigned char*)trans.get_data_ptr();
    reg_wr_dbg((cuint)tag, ptr, sizeof(uint));
    return sizeof(uint);
}
void Cbist_regif::cw_instantiate_reg(scml2::reg<uint> * reg, std::string reg_name, int offset)
{
    reg = new scml2::reg<uint>(reg_name, cwmem, offset/sizeof(uint));
    scml2::set_debug_write_callback(*reg,SCML2_CALLBACK(cw_wr_cb),offset);
    scml2::set_debug_read_callback(*reg,SCML2_CALLBACK(cw_rd_cb),offset);
}
#endif
