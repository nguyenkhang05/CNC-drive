// -----------------------------------------------------------------------------
// $Id: atu5010_timerd_sub_regif.cpp,v 1.1 2018/03/14 03:21:49 binhnguyen Exp $
//
// Copyright(c) 2016-2018 Renesas Electronics Corporation
// Copyright(c) 2016-2018 Renesas Design Vietnam Co., Ltd.
// RENESAS ELECTRONICS CONFIDENTIAL AND PROPRIETARY.
// This program must be used solely for the purpose for which
// it was furnished by Renesas Electronics Corporation. No part of this
// program may be reproduced or disclosed to others, in any
// form, without the prior written permission of Renesas Electronics
// Corporation.
// -----------------------------------------------------------------------------
// This file is generated by Register I/F generator
//    gen_regif.py 1.9 2013/12/04 09:51:36 sontran
//    gen_regif_class.py 1.60 2014/10/24 09:42:15 ducduong
//    regif_cpp.skl 1.53 2014/10/13 03:19:16 sontran
//
// Input file : atu5010_timerd_sub_regif.txt
////////////////////////////////////////////////////////////////////////////////
// %MODULE ATU5010_TIMERD_SUB
//     #                   name            offset_size
//     %%REG_INSTANCE      reg_def         9
// 
// %REG_CHANNEL reg_def
//     %%TITLE   name          reg_name      wsize         rsize         length        offset        factor_start  factor_end    factor_index  factor_step   access        init          support       callback
//     %%REG     TCRD          TCRD          8|16          8|16|32       16            0x000        -             -             -             -         R|W           0x0000        TRUE          -
//     %%REG     TCCRLRD       TCCRLRD       8|16          8|16|32       16            0x01C        -             -             -             -         R|W           0x0000        TRUE          -
//     %%REG     TIOR1D        TIOR1D        8|16          8|16|32       16            0x004        -             -             -             -         R|W           0x0000        TRUE          -
//     %%REG     TIOR2D        TIOR2D        16|8          8|16|32       16            0x006        -             -             -             -         R|W           0x0000        TRUE          -
//     %%REG     TCMPED        TCMPED        8             8|16|32       8             0x03D        -             -             -             -         R|W           0x00          TRUE          -
//     %%REG     TIORD         TIORD         16|8          8|16|32       16            0x03E        -             -             -             -         R|W           0xFFFF        TRUE          -
//     %%REG     OSELRD        OSELRD        8             8|16|32       8             0x011        -             -             -             -         R|W           0x00          TRUE          -
//     %%REG     ODRD          ODRD          8             8|16|32       8             0x012        -             -             -             -         R|W           0x00          TRUE          -
//     %%REG     DSTRD         DSTRD         8             8|16|32       8             0x008        -             -             -             -         R|W           0x00          TRUE          -
//     %%REG     DSR1D         DSR1D         -             8|16|32       8             0x00A        -             -             -             -         R             0x00          TRUE          -
//     %%REG     DSR2D         DSR2D         -             8|16|32       8             0x00B        -             -             -             -         R             0x00          TRUE          -
//     %%REG     DSCRD         DSCRD         8             8|16|32       8             0x009        -             -             -             -         R|W1:0        0x00          TRUE          -
//     %%REG     DCRD          DCRD          16|8          8|16|32       16            0x002        -             -             -             -         R|W           0x0000        TRUE          -
//     %%REG     TSRD          TSRD          -             8|16|32       16            0x00C        -             -             -             -         R             0x0000        TRUE          -
//     %%REG     TSCRD         TSCRD         16|8          8|16|32       16            0x00E        -             -             -             -         R|W1:0        0x0000        TRUE          -
//     %%REG     TOCRD         TOCRD         8             8|16|32       8             0x010        -             -             -             -         R|W           0x00          TRUE          -
//     %%REG     TOCCRD        TOCCRD        8             8|16|32       8             0x03C        -             -             -             -         R|W           0x00          TRUE          -
//     %%REG     OSBRD         OSBRD         -             8|16|32       32            0x018        -             -             -             -         R             0x00000000    TRUE          -
//     %%REG     TICTSELD      TICTSELD      8             8|16|32       8             0x014        -             -             -             -         R|W           0x0           TRUE          -
//     %%REG     MIGCRD        MIGCRD        8             8|16|32       8             0x016        -             -             -             -         R|W           0x0           TRUE          -
//     %%REG     MIGSELD       MIGSELD       8             8|16|32       8             0x017        -             -             -             -         R|W           0x0           TRUE          -
//     %%REG     TCNT1D        TCNT1D        32            8|16|32       32            0x020        -             -             -             -         R|W           0x00000000    TRUE          -
//     %%REG     TCNT2D        TCNT2D        32            8|16|32       32            0x024        -             -             -             -         R|W           0x00000000    TRUE          -
//     %%REG     CUCR1D        CUCR1D        32            8|16|32       32            0x028        -             -             -             -         R|W           0xFFFFFFFF    TRUE          -
//     %%REG     CUCR2D        CUCR2D        32            8|16|32       32            0x02C        -             -             -             -         R|W           0xFFFFFFFF    TRUE          -
//     %%REG     OCR1D         OCR1D         32            8|16|32       32            0x040        0             3             -             0x20      R|W           0xFFFFFFFF    TRUE          -
//     %%REG     RCR1D         RCR1D         8             8|16|32       8             0x030        -             -             -             -         R|W           0x00          TRUE          -
//     %%REG     OCR2D         OCR2D         32            8|16|32       32            0x048        0             3             -             0x20      R|W           0xFFFFFFFF    TRUE          -
//     %%REG     RCR2D         RCR2D         8             8|16|32       8             0x034        -             -             -             -         R|W           0x00          TRUE          -
//     %%REG     ICR1D         ICR1D         -             8|16|32       32            0x050        0             3             -             0x20      R             0x00000000    TRUE          -
//     %%REG     ICR2D         ICR2D         -             8|16|32       32            0x054        0             3             -             0x20      R             0x00000000    TRUE          -
//     %%REG     DCNTD         DCNTD         32            8|16|32       32            0x058        0             3             -             0x20      R|W           0x00000000    TRUE          -
//     %%REG     TIER1D        TIER1D        8             8|16|32       8             0x0C0        -             -             -             -         R|W           0x00          TRUE          -
//     %%REG     TIER2D        TIER2D        32|16|8       8|16|32       32            0x0C4        -             -             -             -         R|W           0x0000        TRUE          -
//     %%REG     TIER3D        TIER3D        16|8          8|16|32       16            0x0C8        -             -             -             -         R|W           0x0000        TRUE          -
//     %%REG     OFMIND        OFMIND        32            8|16|32       32            0x110        0             3             -             0x40      R|W           0x00000000    TRUE          -
//     %%REG     ONMIND        ONMIND        32            8|16|32       32            0x114        0             3             -             0x40      R|W           0x00000000    TRUE          -
//     %%REG     OTOMIND       OTOMIND       32            8|16|32       32            0x118        0             3             -             0x40      R|W           0x00000000    TRUE          -
//     %%REG     OFMICNTD      OFMICNTD      32            8|16|32       32            0x100        0             3             -             0x40      R|W           0x00000000    TRUE          -
//     %%REG     ONMICNTD      ONMICNTD      32            8|16|32       32            0x104        0             3             -             0x40      R|W           0x00000000    TRUE          -
//     %%REG     OTONMICNTD    OTONMICNTD    32            8|16|32       32            0x108        0             3             -             0x40      R|W           0x00000000    TRUE          -
//     %%REG     ONCAPD1       ONCAPD1       -             8|16|32       32            0x120        0             3             -             0x40      R             0x00000000    TRUE          -
//     %%REG     ONCAPD2       ONCAPD2       -             8|16|32       32            0x124        0             3             -             0x40      R             0x00000000    TRUE          -
//     %%REG     OFCAPD1       OFCAPD1       -             8|16|32       32            0x130        0             3             -             0x40      R             0x00000000    TRUE          -
//     %%REG     OFCAPD2       OFCAPD2       -             8|16|32       32            0x134        0             3             -             0x40      R             0x00000000    TRUE          -
//     %%REG     TSR2D         TSR2D         -             8|16|32       16            0x0D0        -             -             -             -         R             0x0000        TRUE          -
//     %%REG     TSCR2D        TSCR2D        16|8          8|16|32       16            0x0D4        -             -             -             -         R|W1          0x0000        TRUE          -
// 
// 
// %REG_NAME     TCRD
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         OBRED         14            14            0x0           R|W           TRUE          W
// %%BIT         C2CED         13            13            0x0           R|W           TRUE          -
// %%BIT         C1CED         12            12            0x0           R|W           TRUE          -
// %%BIT         CLR2D         11            11            0x0           R|W           TRUE          -
// %%BIT         CKSEL2D       10            8             0x0           R|W           TRUE          -
// %%BIT         CLR1D         7             7             0x0           R|W           TRUE          -
// %%BIT         CKSEL1D       6             4             0x0           R|W           TRUE          -
// %%BIT         DCSELD        2             0             0x0           R|W           TRUE          -
// 
// %REG_NAME     TCCRLRD
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         CLRSEL2D      9             9             0x0           R|W           TRUE          W
// %%BIT         CLRSEL1D      8             8             0x0           R|W           TRUE          -
// %%BIT         CMPSEL2D3     7             7             0x0           R|W           TRUE          -
// %%BIT         CMPSEL2D2     6             6             0x0           R|W           TRUE          -
// %%BIT         CMPSEL2D1     5             5             0x0           R|W           TRUE          -
// %%BIT         CMPSEL2D0     4             4             0x0           R|W           TRUE          -
// %%BIT         CMPSEL1D3     3             3             0x0           R|W           TRUE          -
// %%BIT         CMPSEL1D2     2             2             0x0           R|W           TRUE          -
// %%BIT         CMPSEL1D1     1             1             0x0           R|W           TRUE          -
// %%BIT         CMPSEL1D0     0             0             0x0           R|W           TRUE          -
// 
// %REG_NAME     TIOR1D
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         OSSD3         15            14            0x0            R|W           TRUE          W
// %%BIT         OSSD2         13            12            0x0            R|W           TRUE          -
// %%BIT         OSSD1         11            10            0x0            R|W           TRUE          -
// %%BIT         OSSD0         9             8             0x0            R|W           TRUE          -
// %%BIT         IOAD3         7             6             0x0            R|W           TRUE          -
// %%BIT         IOAD2         5             4             0x0            R|W           TRUE          -
// %%BIT         IOAD1         3             2             0x0            R|W           TRUE          -
// %%BIT         IOAD0         1             0             0x0            R|W           TRUE          -
// 
// %REG_NAME     TIOR2D
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         IOBD3         14            12            0x0           R|W           TRUE          W
// %%BIT         IOBD2         10            8             0x0           R|W           TRUE          -
// %%BIT         IOBD1         6             4             0x0           R|W           TRUE          -
// %%BIT         IOBD0         2             0             0x0           R|W           TRUE          -
// 
// %REG_NAME     TCMPED
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         CMPE2D3       7             7             0x0           R|W           TRUE          W
// %%BIT         CMPE2D2       6             6             0x0           R|W           TRUE          -
// %%BIT         CMPE2D1       5             5             0x0           R|W           TRUE          -
// %%BIT         CMPE2D0       4             4             0x0           R|W           TRUE          -
// %%BIT         CMPE1D3       3             3             0x0           R|W           TRUE          -
// %%BIT         CMPE1D2       2             2             0x0           R|W           TRUE          -
// %%BIT         CMPE1D1       1             1             0x0           R|W           TRUE          -
// %%BIT         CMPE1D0       0             0             0x0           R|W           TRUE          -
// 
// %REG_NAME     TIORD
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         IO2D3         15            14            0x3           R|W           TRUE          W
// %%BIT         IO2D2         13            12            0x3           R|W           TRUE          -
// %%BIT         IO2D1         11            10            0x3           R|W           TRUE          -
// %%BIT         IO2D0         9             8             0x3           R|W           TRUE          -
// %%BIT         IO1D3         7             6             0x3           R|W           TRUE          -
// %%BIT         IO1D2         5             4             0x3           R|W           TRUE          -
// %%BIT         IO1D1         3             2             0x3           R|W           TRUE          -
// %%BIT         IO1D0         1             0             0x3           R|W           TRUE          -
// 
// %REG_NAME     OSELRD
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         OSELBD3       7             7             0x0           R|W           TRUE          W
// %%BIT         OSELBD2       6             6             0x0           R|W           TRUE          -
// %%BIT         OSELBD1       5             5             0x0           R|W           TRUE          -
// %%BIT         OSELBD0       4             4             0x0           R|W           TRUE          -
// %%BIT         OSELAD3       3             3             0x0           R|W           TRUE          -
// %%BIT         OSELAD2       2             2             0x0           R|W           TRUE          -
// %%BIT         OSELAD1       1             1             0x0           R|W           TRUE          -
// %%BIT         OSELAD0       0             0             0x0           R|W           TRUE          -
// 
// %REG_NAME     ODRD
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         ODBD3         7             7             0x0           R|W           TRUE          W
// %%BIT         ODBD2         6             6             0x0           R|W           TRUE          -
// %%BIT         ODBD1         5             5             0x0           R|W           TRUE          -
// %%BIT         ODBD0         4             4             0x0           R|W           TRUE          -
// %%BIT         ODAD3         3             3             0x0           R|W           TRUE          -
// %%BIT         ODAD2         2             2             0x0           R|W           TRUE          -
// %%BIT         ODAD1         1             1             0x0           R|W           TRUE          -
// %%BIT         ODAD0         0             0             0x0           R|W           TRUE          -
// 
// %REG_NAME     DSTRD
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         DSTD3         3             3             0x0           R|W           TRUE          -
// %%BIT         DSTD2         2             2             0x0           R|W           TRUE          -
// %%BIT         DSTD1         1             1             0x0           R|W           TRUE          -
// %%BIT         DSTD0         0             0             0x0           R|W           TRUE          -
// 
// %REG_NAME     DSR1D
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         DWFD3         7             7             0x0           R             TRUE          -
// %%BIT         DWFD2         6             6             0x0           R             TRUE          -
// %%BIT         DWFD1         5             5             0x0           R             TRUE          -
// %%BIT         DWFD0         4             4             0x0           R             TRUE          -
// %%BIT         DSFD3         3             3             0x0           R             TRUE          -
// %%BIT         DSFD2         2             2             0x0           R             TRUE          -
// %%BIT         DSFD1         1             1             0x0           R             TRUE          -
// %%BIT         DSFD0         0             0             0x0           R             TRUE          -
// 
// %REG_NAME     DSR2D
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         DWRFD3        7             6             0x0           R             TRUE          -
// %%BIT         DWRFD2        5             4             0x0           R             TRUE          -
// %%BIT         DWRFD1        3             2             0x0           R             TRUE          -
// %%BIT         DWRFD0        1             0             0x0           R             TRUE          -
// 
// %REG_NAME     DSCRD
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         DWFCD3        7             7             0x0           R|W1:0        TRUE          -
// %%BIT         DWFCD2        6             6             0x0           R|W1:0        TRUE          -
// %%BIT         DWFCD1        5             5             0x0           R|W1:0        TRUE          -
// %%BIT         DWFCD0        4             4             0x0           R|W1:0        TRUE          -
// %%BIT         DWRFCD3       3             3             0x0           R|W1:0        TRUE          -
// %%BIT         DWRFCD2       2             2             0x0           R|W1:0        TRUE          -
// %%BIT         DWRFCD1       1             1             0x0           R|W1:0        TRUE          -
// %%BIT         DWRFCD0       0             0             0x0           R|W1:0        TRUE          W
// 
// %REG_NAME     DCRD
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         TRGSELD3      15            12            0x0           R|W           TRUE          -
// %%BIT         TRGSELD2      11            8             0x0           R|W           TRUE          -
// %%BIT         TRGSELD1      7             4             0x0           R|W           TRUE          -
// %%BIT         TRGSELD0      3             0             0x0           R|W           TRUE          -
// 
// %REG_NAME     TSRD
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         OVF2D         13            13            0x0           R             TRUE          -
// %%BIT         OVF1D         12            12            0x0           R             TRUE          -
// %%BIT         UDFD3         11            11            0x0           R             TRUE          -
// %%BIT         UDFD2         10            10            0x0           R             TRUE          -
// %%BIT         UDFD1         9             9             0x0           R             TRUE          -
// %%BIT         UDFD0         8             8             0x0           R             TRUE          -
// %%BIT         CMFAD3        7             7             0x0           R             TRUE          -
// %%BIT         CMFAD2        6             6             0x0           R             TRUE          -
// %%BIT         CMFAD1        5             5             0x0           R             TRUE          -
// %%BIT         CMFAD0        4             4             0x0           R             TRUE          -
// %%BIT         CMFBD3        3             3             0x0           R             TRUE          -
// %%BIT         CMFBD2        2             2             0x0           R             TRUE          -
// %%BIT         CMFBD1        1             1             0x0           R             TRUE          -
// %%BIT         CMFBD0        0             0             0x0           R             TRUE          -
// 
// %REG_NAME     TSCRD
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         OVFC2D        13            13            0x0           R|W1:0        TRUE          W
// %%BIT         OVFC1D        12            12            0x0           R|W1:0        TRUE          -
// %%BIT         UDFCD3        11            11            0x0           R|W1:0        TRUE          -
// %%BIT         UDFCD2        10            10            0x0           R|W1:0        TRUE          -
// %%BIT         UDFCD1        9             9             0x0           R|W1:0        TRUE          -
// %%BIT         UDFCD0        8             8             0x0           R|W1:0        TRUE          -
// %%BIT         CMFCAD3       7             7             0x0           R|W1:0        TRUE          -
// %%BIT         CMFCAD2       6             6             0x0           R|W1:0        TRUE          -
// %%BIT         CMFCAD1       5             5             0x0           R|W1:0        TRUE          -
// %%BIT         CMFCAD0       4             4             0x0           R|W1:0        TRUE          -
// %%BIT         CMFCBD3       3             3             0x0           R|W1:0        TRUE          -
// %%BIT         CMFCBD2       2             2             0x0           R|W1:0        TRUE          -
// %%BIT         CMFCBD1       1             1             0x0           R|W1:0        TRUE          -
// %%BIT         CMFCBD0       0             0             0x0           R|W1:0        TRUE          -
// 
// %REG_NAME     TOCRD
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         TONEBD        1             1             0x0           R|W           TRUE          W
// %%BIT         TONEAD        0             0             0x0           R|W           TRUE          -
// 
// %REG_NAME     TOCCRD
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         TONEBD3       7             7             0x0           R|W           TRUE          W
// %%BIT         TONEBD2       6             6             0x0           R|W           TRUE          -
// %%BIT         TONEBD1       5             5             0x0           R|W           TRUE          -
// %%BIT         TONEBD0       4             4             0x0           R|W           TRUE          -
// %%BIT         TONEAD3       3             3             0x0           R|W           TRUE          -
// %%BIT         TONEAD2       2             2             0x0           R|W           TRUE          -
// %%BIT         TONEAD1       1             1             0x0           R|W           TRUE          -
// %%BIT         TONEAD0       0             0             0x0           R|W           TRUE          -
// 
// %REG_NAME     OSBRD
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         OSBRD         31            0             0x00000000    R             TRUE          -
// 
// %REG_NAME     TICTSELD
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         TIDSELD       1             0             0x0           R|W           TRUE          -
// 
// 
// %REG_NAME     MIGCRD 
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         MIGEND3       3             3             0x0           R|W           TRUE          -
// %%BIT         MIGEND2       2             2             0x0           R|W           TRUE          -
// %%BIT         MIGEND1       1             1             0x0           R|W           TRUE          -
// %%BIT         MIGEND0       0             0             0x0           R|W           TRUE          -
// 
// %REG_NAME     MIGSELD
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         MIGSEL3       3             3             0x0           R|W           TRUE          -
// %%BIT         MIGSEL2       2             2             0x0           R|W           TRUE          -
// %%BIT         MIGSEL1       1             1             0x0           R|W           TRUE          -
// %%BIT         MIGSEL0       0             0             0x0           R|W           TRUE          -
// 
// %REG_NAME     TCNT1D
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         TCNT1D        31            0             0x00000000    R|W           TRUE          W
// 
// %REG_NAME     TCNT2D
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         TCNT2D        31            0             0x00000000    R|W           TRUE          W
// 
// %REG_NAME     CUCR1D
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         CUCR1D        31            0             0xFFFFFFFF    R|W           TRUE          W
// 
// %REG_NAME     CUCR2D
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         CUCR2D        31            0             0xFFFFFFFF    R|W           TRUE          W
// 
// %REG_NAME     OCR1D
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         OC1D          31            0             0xFFFFFFFF    R|W           TRUE          W
// 
// %REG_NAME     RCR1D
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         RC1D          4             0             0x0           R|W           TRUE          W
// 
// %REG_NAME     OCR2D
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         OC2D          31            0             0xFFFFFFFF    R|W           TRUE          W
// 
// %REG_NAME     RCR2D
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         RC2D          4             0             0x0           R|W           TRUE          W
// 
// %REG_NAME     ICR1D
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         ICR1D         31            0             0x00000000    R             TRUE          -
// 
// %REG_NAME     ICR2D
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         ICR2D         31            0             0x00000000    R             TRUE          -
// 
// %REG_NAME     DCNTD
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         CNTD          31            0             0x00000000    R|W           TRUE          -
// 
// %REG_NAME     TIER1D
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         OV2ED         1             1             0x0           R|W           TRUE          W
// %%BIT         OV1ED         0             0             0x0           R|W           TRUE          -
// 
// %REG_NAME     TIER2D
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         UNDED3        19            19            0x0           R|W           TRUE          W
// %%BIT         UNDED2        18            18            0x0           R|W           TRUE          -
// %%BIT         UNDED1        17            17            0x0           R|W           TRUE          -
// %%BIT         UNDED0        16            16            0x0           R|W           TRUE          -
// %%BIT         CMPBED3       11            11            0x0           R|W           TRUE          -
// %%BIT         CMPBED2       10            10            0x0           R|W           TRUE          -
// %%BIT         CMPBED1       9             9             0x0           R|W           TRUE          -
// %%BIT         CMPBED0       8             8             0x0           R|W           TRUE          -
// %%BIT         CMPAED3       3             3             0x0           R|W           TRUE          -
// %%BIT         CMPAED2       2             2             0x0           R|W           TRUE          -
// %%BIT         CMPAED1       1             1             0x0           R|W           TRUE          -
// %%BIT         CMPAED0       0             0             0x0           R|W           TRUE          -
// 
// %REG_NAME     TIER3D
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         FEIED3        11            11            0x0           R|W           TRUE          W
// %%BIT         FEIED2        10            10            0x0           R|W           TRUE          -
// %%BIT         FEIED1        9             9             0x0           R|W           TRUE          -
// %%BIT         FEIED0        8             8             0x0           R|W           TRUE          -
// %%BIT         REIED3        3             3             0x0           R|W           TRUE          -
// %%BIT         REIED2        2             2             0x0           R|W           TRUE          -
// %%BIT         REIED1        1             1             0x0           R|W           TRUE          -
// %%BIT         REIED0        0             0             0x0           R|W           TRUE          -
// 
// %REG_NAME     OFMIND
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         OFMIND        31            0             0x00000000    R|W           TRUE          -
// 
// %REG_NAME     ONMIND
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         ONMIND        31            0             0x00000000    R|W           TRUE          -
// 
// %REG_NAME     OTOMIND
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         OTOMIND       31            0             0x00000000    R|W           TRUE          -
// 
// %REG_NAME     OFMICNTD
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         OFMICNTD      31            0             0x00000000    R|W           TRUE          W
// 
// %REG_NAME     ONMICNTD
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         ONMICNTD      31            0             0x00000000    R|W           TRUE          W
// 
// %REG_NAME     OTONMICNTD
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         OTONMICNTD    31            0             0x00000000    R|W           TRUE          W
// 
// %REG_NAME     ONCAPD1
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         ONCAPD1       31            0             0x00000000    R             TRUE          -
// 
// %REG_NAME     ONCAPD2
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         ONCAPD2       31            0             0x00000000    R             TRUE          -
// 
// %REG_NAME     OFCAPD1
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         OFCAPD1       31            0             0x00000000    R             TRUE          -
// 
// %REG_NAME     OFCAPD2
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         OFCAPD2       31            0             0x00000000    R             TRUE          -
// 
// %REG_NAME     TSR2D
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         FEFD3         11            11            0x0           R             TRUE          -
// %%BIT         FEFD2         10            10            0x0           R             TRUE          -
// %%BIT         FEFD1         9             9             0x0           R             TRUE          -
// %%BIT         FEFD0         8             8             0x0           R             TRUE          -
// %%BIT         REFD3         3             3             0x0           R             TRUE          -
// %%BIT         REFD2         2             2             0x0           R             TRUE          -
// %%BIT         REFD1         1             1             0x0           R             TRUE          -
// %%BIT         REFD0         0             0             0x0           R             TRUE          -
// 
// %REG_NAME     TSCR2D
// %%TITLE       name          upper         lower         init          access        support       callback
// %%BIT         FEFCD3        11            11            0x0           R|W1          TRUE          W
// %%BIT         FEFCD2        10            10            0x0           R|W1          TRUE          -
// %%BIT         FEFCD1        9             9             0x0           R|W1          TRUE          -
// %%BIT         FEFCD0        8             8             0x0           R|W1          TRUE          -
// %%BIT         REFCD3        3             3             0x0           R|W1          TRUE          -
// %%BIT         REFCD2        2             2             0x0           R|W1          TRUE          -
// %%BIT         REFCD1        1             1             0x0           R|W1          TRUE          -
// %%BIT         REFCD0        0             0             0x0           R|W1          TRUE          -
// 
////////////////////////////////////////////////////////////////////////////////
/// @file atu5010_timerd_sub_regif.cpp
/// @brief Register IF class of model ATU5010_TIMERD_SUB
/// $Id$
/// $Date$
/// $Revison$
/// $Author$
////////////////////////////////////////////////////////////////////////////////
#include "atu5010_timerd_sub_regif.h"
#ifndef re_printf
#define re_printf get_fileline(__FILE__, __LINE__); _re_printf
#endif//re_printf

/// Constructor of Register IF class: define registers and bits
/// @return none
Catu5010_timerd_sub_regif::Catu5010_timerd_sub_regif(std::string name, uint buswidth)
    :vpcl::reg_super()
    #ifdef CWR_SYSTEMC
    , cwmem("register", scml_memsize(0xD8/4))
    #endif
{
    CommandInit();
    TCRD       = new vpcl::re_register(0x0000, this, "TCRD"      , name.c_str());
    TCCRLRD    = new vpcl::re_register(0x001C, this, "TCCRLRD"   , name.c_str());
    TIOR1D     = new vpcl::re_register(0x0004, this, "TIOR1D"    , name.c_str());
    TIOR2D     = new vpcl::re_register(0x0006, this, "TIOR2D"    , name.c_str());
    TCMPED     = new vpcl::re_register(0x003D, this, "TCMPED"    , name.c_str());
    TIORD      = new vpcl::re_register(0x003E, this, "TIORD"     , name.c_str());
    OSELRD     = new vpcl::re_register(0x0011, this, "OSELRD"    , name.c_str());
    ODRD       = new vpcl::re_register(0x0012, this, "ODRD"      , name.c_str());
    DSTRD      = new vpcl::re_register(0x0008, this, "DSTRD"     , name.c_str());
    DSR1D      = new vpcl::re_register(0x000A, this, "DSR1D"     , name.c_str());
    DSR2D      = new vpcl::re_register(0x000B, this, "DSR2D"     , name.c_str());
    DSCRD      = new vpcl::re_register(0x0009, this, "DSCRD"     , name.c_str());
    DCRD       = new vpcl::re_register(0x0002, this, "DCRD"      , name.c_str());
    TSRD       = new vpcl::re_register(0x000C, this, "TSRD"      , name.c_str());
    TSCRD      = new vpcl::re_register(0x000E, this, "TSCRD"     , name.c_str());
    TOCRD      = new vpcl::re_register(0x0010, this, "TOCRD"     , name.c_str());
    TOCCRD     = new vpcl::re_register(0x003C, this, "TOCCRD"    , name.c_str());
    OSBRD      = new vpcl::re_register(0x0018, this, "OSBRD"     , name.c_str());
    TICTSELD   = new vpcl::re_register(0x0014, this, "TICTSELD"  , name.c_str());
    MIGCRD     = new vpcl::re_register(0x0016, this, "MIGCRD"    , name.c_str());
    MIGSELD    = new vpcl::re_register(0x0017, this, "MIGSELD"   , name.c_str());
    TCNT1D     = new vpcl::re_register(0x0020, this, "TCNT1D"    , name.c_str());
    TCNT2D     = new vpcl::re_register(0x0024, this, "TCNT2D"    , name.c_str());
    CUCR1D     = new vpcl::re_register(0x0028, this, "CUCR1D"    , name.c_str());
    CUCR2D     = new vpcl::re_register(0x002C, this, "CUCR2D"    , name.c_str());
    RCR1D      = new vpcl::re_register(0x0030, this, "RCR1D"     , name.c_str());
    RCR2D      = new vpcl::re_register(0x0034, this, "RCR2D"     , name.c_str());
    TIER1D     = new vpcl::re_register(0x00C0, this, "TIER1D"    , name.c_str());
    TIER2D     = new vpcl::re_register(0x00C4, this, "TIER2D"    , name.c_str());
    TIER3D     = new vpcl::re_register(0x00C8, this, "TIER3D"    , name.c_str());
    TSR2D      = new vpcl::re_register(0x00D0, this, "TSR2D"     , name.c_str());
    TSCR2D     = new vpcl::re_register(0x00D4, this, "TSCR2D"    , name.c_str());
    std::ostringstream str_tmp;
    for(uint i = 0; i < emNUM_OCR1D; i++) {
        str_tmp.str("");
        str_tmp<<"OCR1D"<< i;
        OCR1D     [i] = new vpcl::re_register((0x0040) + 32*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_OCR2D; i++) {
        str_tmp.str("");
        str_tmp<<"OCR2D"<< i;
        OCR2D     [i] = new vpcl::re_register((0x0048) + 32*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_ICR1D; i++) {
        str_tmp.str("");
        str_tmp<<"ICR1D"<< i;
        ICR1D     [i] = new vpcl::re_register((0x0050) + 32*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_ICR2D; i++) {
        str_tmp.str("");
        str_tmp<<"ICR2D"<< i;
        ICR2D     [i] = new vpcl::re_register((0x0054) + 32*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_DCNTD; i++) {
        str_tmp.str("");
        str_tmp<<"DCNTD"<< i;
        DCNTD     [i] = new vpcl::re_register((0x0058) + 32*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_OFMIND; i++) {
        str_tmp.str("");
        str_tmp<<"OFMIND"<< i;
        OFMIND    [i] = new vpcl::re_register((0x0110) + 64*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_ONMIND; i++) {
        str_tmp.str("");
        str_tmp<<"ONMIND"<< i;
        ONMIND    [i] = new vpcl::re_register((0x0114) + 64*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_OTOMIND; i++) {
        str_tmp.str("");
        str_tmp<<"OTOMIND"<< i;
        OTOMIND   [i] = new vpcl::re_register((0x0118) + 64*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_OFMICNTD; i++) {
        str_tmp.str("");
        str_tmp<<"OFMICNTD"<< i;
        OFMICNTD  [i] = new vpcl::re_register((0x0100) + 64*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_ONMICNTD; i++) {
        str_tmp.str("");
        str_tmp<<"ONMICNTD"<< i;
        ONMICNTD  [i] = new vpcl::re_register((0x0104) + 64*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_OTONMICNTD; i++) {
        str_tmp.str("");
        str_tmp<<"OTONMICNTD"<< i;
        OTONMICNTD[i] = new vpcl::re_register((0x0108) + 64*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_ONCAPD1; i++) {
        str_tmp.str("");
        str_tmp<<"ONCAPD1"<< i;
        ONCAPD1   [i] = new vpcl::re_register((0x0120) + 64*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_ONCAPD2; i++) {
        str_tmp.str("");
        str_tmp<<"ONCAPD2"<< i;
        ONCAPD2   [i] = new vpcl::re_register((0x0124) + 64*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_OFCAPD1; i++) {
        str_tmp.str("");
        str_tmp<<"OFCAPD1"<< i;
        OFCAPD1   [i] = new vpcl::re_register((0x0130) + 64*i, this, str_tmp.str(), name.c_str());
    }
    for(uint i = 0; i < emNUM_OFCAPD2; i++) {
        str_tmp.str("");
        str_tmp<<"OFCAPD2"<< i;
        OFCAPD2   [i] = new vpcl::re_register((0x0134) + 64*i, this, str_tmp.str(), name.c_str());
    }

    // Construct the register pointer list
    mCurReg = NULL;

    uint index = 0;
    mRegMap = new uint [1<<9];
    for (uint i = 0; i < (1<<9); i++) {
        mRegMap[i] = (1<<9);
    }

    mRegMap[0x0000]     = index;
    mRegMap[0x0000 + 1] = index++;
    mRegMap[0x0002]     = index;
    mRegMap[0x0002 + 1] = index++;
    mRegMap[0x0004]     = index;
    mRegMap[0x0004 + 1] = index++;
    mRegMap[0x0006]     = index;
    mRegMap[0x0006 + 1] = index++;
    mRegMap[0x0008]     = index++;
    mRegMap[0x0009]     = index++;
    mRegMap[0x000A]     = index++;
    mRegMap[0x000B]     = index++;
    mRegMap[0x000C]     = index;
    mRegMap[0x000C + 1] = index++;
    mRegMap[0x000E]     = index;
    mRegMap[0x000E + 1] = index++;
    mRegMap[0x0010]     = index++;
    mRegMap[0x0011]     = index++;
    mRegMap[0x0012]     = index++;
    mRegMap[0x0014]     = index++;
    mRegMap[0x0016]     = index++;
    mRegMap[0x0017]     = index++;
    mRegMap[0x0018]     = index;
    mRegMap[0x0018 + 1] = index;
    mRegMap[0x0018 + 2] = index;
    mRegMap[0x0018 + 3] = index++;
    mRegMap[0x001C]     = index;
    mRegMap[0x001C + 1] = index++;
    mRegMap[0x0020]     = index;
    mRegMap[0x0020 + 1] = index;
    mRegMap[0x0020 + 2] = index;
    mRegMap[0x0020 + 3] = index++;
    mRegMap[0x0024]     = index;
    mRegMap[0x0024 + 1] = index;
    mRegMap[0x0024 + 2] = index;
    mRegMap[0x0024 + 3] = index++;
    mRegMap[0x0028]     = index;
    mRegMap[0x0028 + 1] = index;
    mRegMap[0x0028 + 2] = index;
    mRegMap[0x0028 + 3] = index++;
    mRegMap[0x002C]     = index;
    mRegMap[0x002C + 1] = index;
    mRegMap[0x002C + 2] = index;
    mRegMap[0x002C + 3] = index++;
    mRegMap[0x0030]     = index++;
    mRegMap[0x0034]     = index++;
    mRegMap[0x003C]     = index++;
    mRegMap[0x003D]     = index++;
    mRegMap[0x003E]     = index;
    mRegMap[0x003E + 1] = index++;
    for(uint i = 0; i < emNUM_OCR1D;     i++) {
        mRegMap[(0x0040)     + i*32] = index;
        mRegMap[(0x0040 + 1) + i*32] = index;
        mRegMap[(0x0040 + 2) + i*32] = index;
        mRegMap[(0x0040 + 3) + i*32] = index++;
    }
    for(uint i = 0; i < emNUM_OCR2D;     i++) {
        mRegMap[(0x0048)     + i*32] = index;
        mRegMap[(0x0048 + 1) + i*32] = index;
        mRegMap[(0x0048 + 2) + i*32] = index;
        mRegMap[(0x0048 + 3) + i*32] = index++;
    }
    for(uint i = 0; i < emNUM_ICR1D;     i++) {
        mRegMap[(0x0050)     + i*32] = index;
        mRegMap[(0x0050 + 1) + i*32] = index;
        mRegMap[(0x0050 + 2) + i*32] = index;
        mRegMap[(0x0050 + 3) + i*32] = index++;
    }
    for(uint i = 0; i < emNUM_ICR2D;     i++) {
        mRegMap[(0x0054)     + i*32] = index;
        mRegMap[(0x0054 + 1) + i*32] = index;
        mRegMap[(0x0054 + 2) + i*32] = index;
        mRegMap[(0x0054 + 3) + i*32] = index++;
    }
    for(uint i = 0; i < emNUM_DCNTD;     i++) {
        mRegMap[(0x0058)     + i*32] = index;
        mRegMap[(0x0058 + 1) + i*32] = index;
        mRegMap[(0x0058 + 2) + i*32] = index;
        mRegMap[(0x0058 + 3) + i*32] = index++;
    }
    mRegMap[0x00C0]     = index++;
    mRegMap[0x00C4]     = index;
    mRegMap[0x00C4 + 1] = index;
    mRegMap[0x00C4 + 2] = index;
    mRegMap[0x00C4 + 3] = index++;
    mRegMap[0x00C8]     = index;
    mRegMap[0x00C8 + 1] = index++;
    mRegMap[0x00D0]     = index;
    mRegMap[0x00D0 + 1] = index++;
    mRegMap[0x00D4]     = index;
    mRegMap[0x00D4 + 1] = index++;
    for(uint i = 0; i < emNUM_OFMICNTD;  i++) {
        mRegMap[(0x0100)     + i*64] = index;
        mRegMap[(0x0100 + 1) + i*64] = index;
        mRegMap[(0x0100 + 2) + i*64] = index;
        mRegMap[(0x0100 + 3) + i*64] = index++;
    }
    for(uint i = 0; i < emNUM_ONMICNTD;  i++) {
        mRegMap[(0x0104)     + i*64] = index;
        mRegMap[(0x0104 + 1) + i*64] = index;
        mRegMap[(0x0104 + 2) + i*64] = index;
        mRegMap[(0x0104 + 3) + i*64] = index++;
    }
    for(uint i = 0; i < emNUM_OTONMICNTD; i++) {
        mRegMap[(0x0108)     + i*64] = index;
        mRegMap[(0x0108 + 1) + i*64] = index;
        mRegMap[(0x0108 + 2) + i*64] = index;
        mRegMap[(0x0108 + 3) + i*64] = index++;
    }
    for(uint i = 0; i < emNUM_OFMIND;    i++) {
        mRegMap[(0x0110)     + i*64] = index;
        mRegMap[(0x0110 + 1) + i*64] = index;
        mRegMap[(0x0110 + 2) + i*64] = index;
        mRegMap[(0x0110 + 3) + i*64] = index++;
    }
    for(uint i = 0; i < emNUM_ONMIND;    i++) {
        mRegMap[(0x0114)     + i*64] = index;
        mRegMap[(0x0114 + 1) + i*64] = index;
        mRegMap[(0x0114 + 2) + i*64] = index;
        mRegMap[(0x0114 + 3) + i*64] = index++;
    }
    for(uint i = 0; i < emNUM_OTOMIND;   i++) {
        mRegMap[(0x0118)     + i*64] = index;
        mRegMap[(0x0118 + 1) + i*64] = index;
        mRegMap[(0x0118 + 2) + i*64] = index;
        mRegMap[(0x0118 + 3) + i*64] = index++;
    }
    for(uint i = 0; i < emNUM_ONCAPD1;   i++) {
        mRegMap[(0x0120)     + i*64] = index;
        mRegMap[(0x0120 + 1) + i*64] = index;
        mRegMap[(0x0120 + 2) + i*64] = index;
        mRegMap[(0x0120 + 3) + i*64] = index++;
    }
    for(uint i = 0; i < emNUM_ONCAPD2;   i++) {
        mRegMap[(0x0124)     + i*64] = index;
        mRegMap[(0x0124 + 1) + i*64] = index;
        mRegMap[(0x0124 + 2) + i*64] = index;
        mRegMap[(0x0124 + 3) + i*64] = index++;
    }
    for(uint i = 0; i < emNUM_OFCAPD1;   i++) {
        mRegMap[(0x0130)     + i*64] = index;
        mRegMap[(0x0130 + 1) + i*64] = index;
        mRegMap[(0x0130 + 2) + i*64] = index;
        mRegMap[(0x0130 + 3) + i*64] = index++;
    }
    for(uint i = 0; i < emNUM_OFCAPD2;   i++) {
        mRegMap[(0x0134)     + i*64] = index;
        mRegMap[(0x0134 + 1) + i*64] = index;
        mRegMap[(0x0134 + 2) + i*64] = index;
        mRegMap[(0x0134 + 3) + i*64] = index++;
    }
    mTotalRegNum = index;
    mRegArray = new SRegList* [mTotalRegNum];
    index = 0;
    #ifdef CWR_SYSTEMC
    cw_instantiate_reg(CW_TCRD_DCRD, "TCRD_DCRD", 0x0000);
    CW_TCRD       = new scml2::bitfield<uint>(TCRD->name()      , CW_TCRD_DCRD           ,  0, 16);
    CW_DCRD       = new scml2::bitfield<uint>(DCRD->name()      , CW_TCRD_DCRD           , 16, 16);
    cw_instantiate_reg(CW_TIOR1D_TIOR2D, "TIOR1D_TIOR2D", 0x0004);
    CW_TIOR1D     = new scml2::bitfield<uint>(TIOR1D->name()    , CW_TIOR1D_TIOR2D       ,  0, 16);
    CW_TIOR2D     = new scml2::bitfield<uint>(TIOR2D->name()    , CW_TIOR1D_TIOR2D       , 16, 16);
    cw_instantiate_reg(CW_DSTRD_DSCRD_DSR1D_DSR2D, "DSTRD_DSCRD_DSR1D_DSR2D", 0x0008);
    CW_DSTRD      = new scml2::bitfield<uint>(DSTRD->name()     , CW_DSTRD_DSCRD_DSR1D_DSR2D,  0,  8);
    CW_DSCRD      = new scml2::bitfield<uint>(DSCRD->name()     , CW_DSTRD_DSCRD_DSR1D_DSR2D,  8,  8);
    CW_DSR1D      = new scml2::bitfield<uint>(DSR1D->name()     , CW_DSTRD_DSCRD_DSR1D_DSR2D, 16,  8);
    CW_DSR2D      = new scml2::bitfield<uint>(DSR2D->name()     , CW_DSTRD_DSCRD_DSR1D_DSR2D, 24,  8);
    cw_instantiate_reg(CW_TSRD_TSCRD, "TSRD_TSCRD", 0x000C);
    CW_TSRD       = new scml2::bitfield<uint>(TSRD->name()      , CW_TSRD_TSCRD          ,  0, 16);
    CW_TSCRD      = new scml2::bitfield<uint>(TSCRD->name()     , CW_TSRD_TSCRD          , 16, 16);
    cw_instantiate_reg(CW_TOCRD_OSELRD_ODRD, "TOCRD_OSELRD_ODRD", 0x0010);
    CW_TOCRD      = new scml2::bitfield<uint>(TOCRD->name()     , CW_TOCRD_OSELRD_ODRD   ,  0,  8);
    CW_OSELRD     = new scml2::bitfield<uint>(OSELRD->name()    , CW_TOCRD_OSELRD_ODRD   ,  8,  8);
    CW_ODRD       = new scml2::bitfield<uint>(ODRD->name()      , CW_TOCRD_OSELRD_ODRD   , 16,  8);
    cw_instantiate_reg(CW_TICTSELD_MIGCRD_MIGSELD, "TICTSELD_MIGCRD_MIGSELD", 0x0014);
    CW_TICTSELD   = new scml2::bitfield<uint>(TICTSELD->name()  , CW_TICTSELD_MIGCRD_MIGSELD,  0,  8);
    CW_MIGCRD     = new scml2::bitfield<uint>(MIGCRD->name()    , CW_TICTSELD_MIGCRD_MIGSELD, 16,  8);
    CW_MIGSELD    = new scml2::bitfield<uint>(MIGSELD->name()   , CW_TICTSELD_MIGCRD_MIGSELD, 24,  8);
    cw_instantiate_reg(CW_TCCRLRD_, "TCCRLRD_", 0x001C);
    CW_TCCRLRD    = new scml2::bitfield<uint>(TCCRLRD->name()   , CW_TCCRLRD_            ,  0, 16);
    cw_instantiate_reg(CW_RCR1D_, "RCR1D_", 0x0030);
    CW_RCR1D      = new scml2::bitfield<uint>(RCR1D->name()     , CW_RCR1D_              ,  0,  8);
    cw_instantiate_reg(CW_RCR2D_, "RCR2D_", 0x0034);
    CW_RCR2D      = new scml2::bitfield<uint>(RCR2D->name()     , CW_RCR2D_              ,  0,  8);
    cw_instantiate_reg(CW_TOCCRD_TCMPED_TIORD, "TOCCRD_TCMPED_TIORD", 0x003C);
    CW_TOCCRD     = new scml2::bitfield<uint>(TOCCRD->name()    , CW_TOCCRD_TCMPED_TIORD ,  0,  8);
    CW_TCMPED     = new scml2::bitfield<uint>(TCMPED->name()    , CW_TOCCRD_TCMPED_TIORD ,  8,  8);
    CW_TIORD      = new scml2::bitfield<uint>(TIORD->name()     , CW_TOCCRD_TCMPED_TIORD , 16, 16);
    cw_instantiate_reg(CW_TIER1D_, "TIER1D_", 0x00C0);
    CW_TIER1D     = new scml2::bitfield<uint>(TIER1D->name()    , CW_TIER1D_             ,  0,  8);
    cw_instantiate_reg(CW_TIER3D_, "TIER3D_", 0x00C8);
    CW_TIER3D     = new scml2::bitfield<uint>(TIER3D->name()    , CW_TIER3D_             ,  0, 16);
    cw_instantiate_reg(CW_TSR2D_, "TSR2D_", 0x00D0);
    CW_TSR2D      = new scml2::bitfield<uint>(TSR2D->name()     , CW_TSR2D_              ,  0, 16);
    cw_instantiate_reg(CW_TSCR2D_, "TSCR2D_", 0x00D4);
    CW_TSCR2D     = new scml2::bitfield<uint>(TSCR2D->name()    , CW_TSCR2D_             ,  0, 16);
    cw_instantiate_reg(CW_OSBRD       , OSBRD->name()     , OSBRD->addr()     );
    cw_instantiate_reg(CW_TCNT1D      , TCNT1D->name()    , TCNT1D->addr()    );
    cw_instantiate_reg(CW_TCNT2D      , TCNT2D->name()    , TCNT2D->addr()    );
    cw_instantiate_reg(CW_CUCR1D      , CUCR1D->name()    , CUCR1D->addr()    );
    cw_instantiate_reg(CW_CUCR2D      , CUCR2D->name()    , CUCR2D->addr()    );
    for(uint i = 0; i < emNUM_OCR1D     ; i++) cw_instantiate_reg(CW_OCR1D       [i], OCR1D     [i]->name(), OCR1D     [i]->addr());
    for(uint i = 0; i < emNUM_OCR2D     ; i++) cw_instantiate_reg(CW_OCR2D       [i], OCR2D     [i]->name(), OCR2D     [i]->addr());
    for(uint i = 0; i < emNUM_ICR1D     ; i++) cw_instantiate_reg(CW_ICR1D       [i], ICR1D     [i]->name(), ICR1D     [i]->addr());
    for(uint i = 0; i < emNUM_ICR2D     ; i++) cw_instantiate_reg(CW_ICR2D       [i], ICR2D     [i]->name(), ICR2D     [i]->addr());
    for(uint i = 0; i < emNUM_DCNTD     ; i++) cw_instantiate_reg(CW_DCNTD       [i], DCNTD     [i]->name(), DCNTD     [i]->addr());
    cw_instantiate_reg(CW_TIER2D      , TIER2D->name()    , TIER2D->addr()    );
    for(uint i = 0; i < emNUM_OFMICNTD  ; i++) cw_instantiate_reg(CW_OFMICNTD    [i], OFMICNTD  [i]->name(), OFMICNTD  [i]->addr());
    for(uint i = 0; i < emNUM_ONMICNTD  ; i++) cw_instantiate_reg(CW_ONMICNTD    [i], ONMICNTD  [i]->name(), ONMICNTD  [i]->addr());
    for(uint i = 0; i < emNUM_OTONMICNTD; i++) cw_instantiate_reg(CW_OTONMICNTD  [i], OTONMICNTD[i]->name(), OTONMICNTD[i]->addr());
    for(uint i = 0; i < emNUM_OFMIND    ; i++) cw_instantiate_reg(CW_OFMIND      [i], OFMIND    [i]->name(), OFMIND    [i]->addr());
    for(uint i = 0; i < emNUM_ONMIND    ; i++) cw_instantiate_reg(CW_ONMIND      [i], ONMIND    [i]->name(), ONMIND    [i]->addr());
    for(uint i = 0; i < emNUM_OTOMIND   ; i++) cw_instantiate_reg(CW_OTOMIND     [i], OTOMIND   [i]->name(), OTOMIND   [i]->addr());
    for(uint i = 0; i < emNUM_ONCAPD1   ; i++) cw_instantiate_reg(CW_ONCAPD1     [i], ONCAPD1   [i]->name(), ONCAPD1   [i]->addr());
    for(uint i = 0; i < emNUM_ONCAPD2   ; i++) cw_instantiate_reg(CW_ONCAPD2     [i], ONCAPD2   [i]->name(), ONCAPD2   [i]->addr());
    for(uint i = 0; i < emNUM_OFCAPD1   ; i++) cw_instantiate_reg(CW_OFCAPD1     [i], OFCAPD1   [i]->name(), OFCAPD1   [i]->addr());
    for(uint i = 0; i < emNUM_OFCAPD2   ; i++) cw_instantiate_reg(CW_OFCAPD2     [i], OFCAPD2   [i]->name(), OFCAPD2   [i]->addr());
    #endif
    mCurReg = mRegArray[index++] = new SRegList(TCRD        , mCurReg, 0,  2,    "8|16", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(DCRD        , mCurReg, 0,  2,    "16|8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TIOR1D      , mCurReg, 0,  2,    "8|16", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TIOR2D      , mCurReg, 0,  2,    "16|8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(DSTRD       , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(DSCRD       , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(DSR1D       , mCurReg, 0,  1,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(DSR2D       , mCurReg, 0,  1,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TSRD        , mCurReg, 0,  2,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TSCRD       , mCurReg, 0,  2,    "16|8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TOCRD       , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(OSELRD      , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(ODRD        , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TICTSELD    , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(MIGCRD      , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(MIGSELD     , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(OSBRD       , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TCCRLRD     , mCurReg, 0,  2,    "8|16", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TCNT1D      , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TCNT2D      , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(CUCR1D      , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(CUCR2D      , mCurReg, 0,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(RCR1D       , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(RCR2D       , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TOCCRD      , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TCMPED      , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TIORD       , mCurReg, 0,  2,    "16|8", "8|16|32");
    for(uint i = 0; i < emNUM_OCR1D     ; i++) mCurReg = mRegArray[index++] = new SRegList(OCR1D       [i], mCurReg, i,  4,      "32", "8|16|32");
    for(uint i = 0; i < emNUM_OCR2D     ; i++) mCurReg = mRegArray[index++] = new SRegList(OCR2D       [i], mCurReg, i,  4,      "32", "8|16|32");
    for(uint i = 0; i < emNUM_ICR1D     ; i++) mCurReg = mRegArray[index++] = new SRegList(ICR1D       [i], mCurReg, i,  4,      "32", "8|16|32");
    for(uint i = 0; i < emNUM_ICR2D     ; i++) mCurReg = mRegArray[index++] = new SRegList(ICR2D       [i], mCurReg, i,  4,      "32", "8|16|32");
    for(uint i = 0; i < emNUM_DCNTD     ; i++) mCurReg = mRegArray[index++] = new SRegList(DCNTD       [i], mCurReg, i,  4,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TIER1D      , mCurReg, 0,  1,       "8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TIER2D      , mCurReg, 0,  4, "32|16|8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TIER3D      , mCurReg, 0,  2,    "16|8", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TSR2D       , mCurReg, 0,  2,      "32", "8|16|32");
    mCurReg = mRegArray[index++] = new SRegList(TSCR2D      , mCurReg, 0,  2,    "16|8", "8|16|32");
    for(uint i = 0; i < emNUM_OFMICNTD  ; i++) mCurReg = mRegArray[index++] = new SRegList(OFMICNTD    [i], mCurReg, i,  4,      "32", "8|16|32");
    for(uint i = 0; i < emNUM_ONMICNTD  ; i++) mCurReg = mRegArray[index++] = new SRegList(ONMICNTD    [i], mCurReg, i,  4,      "32", "8|16|32");
    for(uint i = 0; i < emNUM_OTONMICNTD; i++) mCurReg = mRegArray[index++] = new SRegList(OTONMICNTD  [i], mCurReg, i,  4,      "32", "8|16|32");
    for(uint i = 0; i < emNUM_OFMIND    ; i++) mCurReg = mRegArray[index++] = new SRegList(OFMIND      [i], mCurReg, i,  4,      "32", "8|16|32");
    for(uint i = 0; i < emNUM_ONMIND    ; i++) mCurReg = mRegArray[index++] = new SRegList(ONMIND      [i], mCurReg, i,  4,      "32", "8|16|32");
    for(uint i = 0; i < emNUM_OTOMIND   ; i++) mCurReg = mRegArray[index++] = new SRegList(OTOMIND     [i], mCurReg, i,  4,      "32", "8|16|32");
    for(uint i = 0; i < emNUM_ONCAPD1   ; i++) mCurReg = mRegArray[index++] = new SRegList(ONCAPD1     [i], mCurReg, i,  4,      "32", "8|16|32");
    for(uint i = 0; i < emNUM_ONCAPD2   ; i++) mCurReg = mRegArray[index++] = new SRegList(ONCAPD2     [i], mCurReg, i,  4,      "32", "8|16|32");
    for(uint i = 0; i < emNUM_OFCAPD1   ; i++) mCurReg = mRegArray[index++] = new SRegList(OFCAPD1     [i], mCurReg, i,  4,      "32", "8|16|32");
    for(uint i = 0; i < emNUM_OFCAPD2   ; i++) mCurReg = mRegArray[index++] = new SRegList(OFCAPD2     [i], mCurReg, i,  4,      "32", "8|16|32");

    mRegList = mCurReg;

    (*TCRD        ) (14, 14, "OBRED"   , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TCRD        ) (13, 13, "C2CED"   , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TCRD        ) (12, 12, "C1CED"   , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TCRD        ) (11, 11, "CLR2D"   , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TCRD        ) (10,  8, "CKSEL2D" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TCRD        ) ( 7,  7, "CLR1D"   , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TCRD        ) ( 6,  4, "CKSEL1D" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TCRD        ) ( 2,  0, "DCSELD"  , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TCCRLRD     ) ( 9,  9, "CLRSEL2D", 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TCCRLRD     ) ( 8,  8, "CLRSEL1D", 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TCCRLRD     ) ( 7,  7, "CMPSEL2D3", 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TCCRLRD     ) ( 6,  6, "CMPSEL2D2", 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TCCRLRD     ) ( 5,  5, "CMPSEL2D1", 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TCCRLRD     ) ( 4,  4, "CMPSEL2D0", 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TCCRLRD     ) ( 3,  3, "CMPSEL1D3", 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TCCRLRD     ) ( 2,  2, "CMPSEL1D2", 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TCCRLRD     ) ( 1,  1, "CMPSEL1D1", 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TCCRLRD     ) ( 0,  0, "CMPSEL1D0", 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIOR1D      ) (15, 14, "OSSD3"   , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIOR1D      ) (13, 12, "OSSD2"   , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIOR1D      ) (11, 10, "OSSD1"   , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIOR1D      ) ( 9,  8, "OSSD0"   , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIOR1D      ) ( 7,  6, "IOAD3"   , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIOR1D      ) ( 5,  4, "IOAD2"   , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIOR1D      ) ( 3,  2, "IOAD1"   , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIOR1D      ) ( 1,  0, "IOAD0"   , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIOR2D      ) (14, 12, "IOBD3"   , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIOR2D      ) (10,  8, "IOBD2"   , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIOR2D      ) ( 6,  4, "IOBD1"   , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIOR2D      ) ( 2,  0, "IOBD0"   , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TCMPED      ) ( 7,  7, "CMPE2D3" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TCMPED      ) ( 6,  6, "CMPE2D2" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TCMPED      ) ( 5,  5, "CMPE2D1" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TCMPED      ) ( 4,  4, "CMPE2D0" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TCMPED      ) ( 3,  3, "CMPE1D3" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TCMPED      ) ( 2,  2, "CMPE1D2" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TCMPED      ) ( 1,  1, "CMPE1D1" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TCMPED      ) ( 0,  0, "CMPE1D0" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIORD       ) (15, 14, "IO2D3"   , 0x3       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIORD       ) (13, 12, "IO2D2"   , 0x3       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIORD       ) (11, 10, "IO2D1"   , 0x3       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIORD       ) ( 9,  8, "IO2D0"   , 0x3       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIORD       ) ( 7,  6, "IO1D3"   , 0x3       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIORD       ) ( 5,  4, "IO1D2"   , 0x3       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIORD       ) ( 3,  2, "IO1D1"   , 0x3       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIORD       ) ( 1,  0, "IO1D0"   , 0x3       , "R|W"   , vpcl::SPP_ENABLE);
    (*OSELRD      ) ( 7,  7, "OSELBD3" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*OSELRD      ) ( 6,  6, "OSELBD2" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*OSELRD      ) ( 5,  5, "OSELBD1" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*OSELRD      ) ( 4,  4, "OSELBD0" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*OSELRD      ) ( 3,  3, "OSELAD3" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*OSELRD      ) ( 2,  2, "OSELAD2" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*OSELRD      ) ( 1,  1, "OSELAD1" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*OSELRD      ) ( 0,  0, "OSELAD0" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*ODRD        ) ( 7,  7, "ODBD3"   , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*ODRD        ) ( 6,  6, "ODBD2"   , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*ODRD        ) ( 5,  5, "ODBD1"   , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*ODRD        ) ( 4,  4, "ODBD0"   , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*ODRD        ) ( 3,  3, "ODAD3"   , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*ODRD        ) ( 2,  2, "ODAD2"   , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*ODRD        ) ( 1,  1, "ODAD1"   , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*ODRD        ) ( 0,  0, "ODAD0"   , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*DSTRD       ) ( 3,  3, "DSTD3"   , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*DSTRD       ) ( 2,  2, "DSTD2"   , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*DSTRD       ) ( 1,  1, "DSTD1"   , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*DSTRD       ) ( 0,  0, "DSTD0"   , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*DSR1D       ) ( 7,  7, "DWFD3"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*DSR1D       ) ( 6,  6, "DWFD2"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*DSR1D       ) ( 5,  5, "DWFD1"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*DSR1D       ) ( 4,  4, "DWFD0"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*DSR1D       ) ( 3,  3, "DSFD3"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*DSR1D       ) ( 2,  2, "DSFD2"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*DSR1D       ) ( 1,  1, "DSFD1"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*DSR1D       ) ( 0,  0, "DSFD0"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*DSR2D       ) ( 7,  6, "DWRFD3"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*DSR2D       ) ( 5,  4, "DWRFD2"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*DSR2D       ) ( 3,  2, "DWRFD1"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*DSR2D       ) ( 1,  0, "DWRFD0"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*DSCRD       ) ( 7,  7, "DWFCD3"  , 0x0       , "R|W1:0", vpcl::SPP_ENABLE);
    (*DSCRD       ) ( 6,  6, "DWFCD2"  , 0x0       , "R|W1:0", vpcl::SPP_ENABLE);
    (*DSCRD       ) ( 5,  5, "DWFCD1"  , 0x0       , "R|W1:0", vpcl::SPP_ENABLE);
    (*DSCRD       ) ( 4,  4, "DWFCD0"  , 0x0       , "R|W1:0", vpcl::SPP_ENABLE);
    (*DSCRD       ) ( 3,  3, "DWRFCD3" , 0x0       , "R|W1:0", vpcl::SPP_ENABLE);
    (*DSCRD       ) ( 2,  2, "DWRFCD2" , 0x0       , "R|W1:0", vpcl::SPP_ENABLE);
    (*DSCRD       ) ( 1,  1, "DWRFCD1" , 0x0       , "R|W1:0", vpcl::SPP_ENABLE);
    (*DSCRD       ) ( 0,  0, "DWRFCD0" , 0x0       , "R|W1:0", vpcl::SPP_ENABLE);
    (*DCRD        ) (15, 12, "TRGSELD3", 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*DCRD        ) (11,  8, "TRGSELD2", 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*DCRD        ) ( 7,  4, "TRGSELD1", 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*DCRD        ) ( 3,  0, "TRGSELD0", 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TSRD        ) (13, 13, "OVF2D"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TSRD        ) (12, 12, "OVF1D"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TSRD        ) (11, 11, "UDFD3"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TSRD        ) (10, 10, "UDFD2"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TSRD        ) ( 9,  9, "UDFD1"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TSRD        ) ( 8,  8, "UDFD0"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TSRD        ) ( 7,  7, "CMFAD3"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TSRD        ) ( 6,  6, "CMFAD2"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TSRD        ) ( 5,  5, "CMFAD1"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TSRD        ) ( 4,  4, "CMFAD0"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TSRD        ) ( 3,  3, "CMFBD3"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TSRD        ) ( 2,  2, "CMFBD2"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TSRD        ) ( 1,  1, "CMFBD1"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TSRD        ) ( 0,  0, "CMFBD0"  , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TSCRD       ) (13, 13, "OVFC2D"  , 0x0       , "R|W1:0", vpcl::SPP_ENABLE);
    (*TSCRD       ) (12, 12, "OVFC1D"  , 0x0       , "R|W1:0", vpcl::SPP_ENABLE);
    (*TSCRD       ) (11, 11, "UDFCD3"  , 0x0       , "R|W1:0", vpcl::SPP_ENABLE);
    (*TSCRD       ) (10, 10, "UDFCD2"  , 0x0       , "R|W1:0", vpcl::SPP_ENABLE);
    (*TSCRD       ) ( 9,  9, "UDFCD1"  , 0x0       , "R|W1:0", vpcl::SPP_ENABLE);
    (*TSCRD       ) ( 8,  8, "UDFCD0"  , 0x0       , "R|W1:0", vpcl::SPP_ENABLE);
    (*TSCRD       ) ( 7,  7, "CMFCAD3" , 0x0       , "R|W1:0", vpcl::SPP_ENABLE);
    (*TSCRD       ) ( 6,  6, "CMFCAD2" , 0x0       , "R|W1:0", vpcl::SPP_ENABLE);
    (*TSCRD       ) ( 5,  5, "CMFCAD1" , 0x0       , "R|W1:0", vpcl::SPP_ENABLE);
    (*TSCRD       ) ( 4,  4, "CMFCAD0" , 0x0       , "R|W1:0", vpcl::SPP_ENABLE);
    (*TSCRD       ) ( 3,  3, "CMFCBD3" , 0x0       , "R|W1:0", vpcl::SPP_ENABLE);
    (*TSCRD       ) ( 2,  2, "CMFCBD2" , 0x0       , "R|W1:0", vpcl::SPP_ENABLE);
    (*TSCRD       ) ( 1,  1, "CMFCBD1" , 0x0       , "R|W1:0", vpcl::SPP_ENABLE);
    (*TSCRD       ) ( 0,  0, "CMFCBD0" , 0x0       , "R|W1:0", vpcl::SPP_ENABLE);
    (*TOCRD       ) ( 1,  1, "TONEBD"  , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TOCRD       ) ( 0,  0, "TONEAD"  , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TOCCRD      ) ( 7,  7, "TONEBD3" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TOCCRD      ) ( 6,  6, "TONEBD2" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TOCCRD      ) ( 5,  5, "TONEBD1" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TOCCRD      ) ( 4,  4, "TONEBD0" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TOCCRD      ) ( 3,  3, "TONEAD3" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TOCCRD      ) ( 2,  2, "TONEAD2" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TOCCRD      ) ( 1,  1, "TONEAD1" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TOCCRD      ) ( 0,  0, "TONEAD0" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*OSBRD       ) (31,  0, "OSBRD"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TICTSELD    ) ( 1,  0, "TIDSELD" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*MIGCRD      ) ( 3,  3, "MIGEND3" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*MIGCRD      ) ( 2,  2, "MIGEND2" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*MIGCRD      ) ( 1,  1, "MIGEND1" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*MIGCRD      ) ( 0,  0, "MIGEND0" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*MIGSELD     ) ( 3,  3, "MIGSEL3" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*MIGSELD     ) ( 2,  2, "MIGSEL2" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*MIGSELD     ) ( 1,  1, "MIGSEL1" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*MIGSELD     ) ( 0,  0, "MIGSEL0" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TCNT1D      ) (31,  0, "TCNT1D"  , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TCNT2D      ) (31,  0, "TCNT2D"  , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*CUCR1D      ) (31,  0, "CUCR1D"  , 0xFFFFFFFF, "R|W"   , vpcl::SPP_ENABLE);
    (*CUCR2D      ) (31,  0, "CUCR2D"  , 0xFFFFFFFF, "R|W"   , vpcl::SPP_ENABLE);
    (*RCR1D       ) ( 4,  0, "RC1D"    , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*RCR2D       ) ( 4,  0, "RC2D"    , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIER1D      ) ( 1,  1, "OV2ED"   , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIER1D      ) ( 0,  0, "OV1ED"   , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIER2D      ) (19, 19, "UNDED3"  , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIER2D      ) (18, 18, "UNDED2"  , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIER2D      ) (17, 17, "UNDED1"  , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIER2D      ) (16, 16, "UNDED0"  , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIER2D      ) (11, 11, "CMPBED3" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIER2D      ) (10, 10, "CMPBED2" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIER2D      ) ( 9,  9, "CMPBED1" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIER2D      ) ( 8,  8, "CMPBED0" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIER2D      ) ( 3,  3, "CMPAED3" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIER2D      ) ( 2,  2, "CMPAED2" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIER2D      ) ( 1,  1, "CMPAED1" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIER2D      ) ( 0,  0, "CMPAED0" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIER3D      ) (11, 11, "FEIED3"  , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIER3D      ) (10, 10, "FEIED2"  , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIER3D      ) ( 9,  9, "FEIED1"  , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIER3D      ) ( 8,  8, "FEIED0"  , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIER3D      ) ( 3,  3, "REIED3"  , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIER3D      ) ( 2,  2, "REIED2"  , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIER3D      ) ( 1,  1, "REIED1"  , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TIER3D      ) ( 0,  0, "REIED0"  , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    (*TSR2D       ) (11, 11, "FEFD3"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TSR2D       ) (10, 10, "FEFD2"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TSR2D       ) ( 9,  9, "FEFD1"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TSR2D       ) ( 8,  8, "FEFD0"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TSR2D       ) ( 3,  3, "REFD3"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TSR2D       ) ( 2,  2, "REFD2"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TSR2D       ) ( 1,  1, "REFD1"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TSR2D       ) ( 0,  0, "REFD0"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    (*TSCR2D      ) (11, 11, "FEFCD3"  , 0x0       , "R|W1"  , vpcl::SPP_ENABLE);
    (*TSCR2D      ) (10, 10, "FEFCD2"  , 0x0       , "R|W1"  , vpcl::SPP_ENABLE);
    (*TSCR2D      ) ( 9,  9, "FEFCD1"  , 0x0       , "R|W1"  , vpcl::SPP_ENABLE);
    (*TSCR2D      ) ( 8,  8, "FEFCD0"  , 0x0       , "R|W1"  , vpcl::SPP_ENABLE);
    (*TSCR2D      ) ( 3,  3, "REFCD3"  , 0x0       , "R|W1"  , vpcl::SPP_ENABLE);
    (*TSCR2D      ) ( 2,  2, "REFCD2"  , 0x0       , "R|W1"  , vpcl::SPP_ENABLE);
    (*TSCR2D      ) ( 1,  1, "REFCD1"  , 0x0       , "R|W1"  , vpcl::SPP_ENABLE);
    (*TSCR2D      ) ( 0,  0, "REFCD0"  , 0x0       , "R|W1"  , vpcl::SPP_ENABLE);
    for(uint i = 0; i < emNUM_ONMIND; i++) {
        (*ONMIND      [i]) (31,  0, "ONMIND"  , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_ONCAPD2; i++) {
        (*ONCAPD2     [i]) (31,  0, "ONCAPD2" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_OCR1D; i++) {
        (*OCR1D       [i]) (31,  0, "OC1D"    , 0xFFFFFFFF, "R|W"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_OCR2D; i++) {
        (*OCR2D       [i]) (31,  0, "OC2D"    , 0xFFFFFFFF, "R|W"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_ONMICNTD; i++) {
        (*ONMICNTD    [i]) (31,  0, "ONMICNTD", 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_OTOMIND; i++) {
        (*OTOMIND     [i]) (31,  0, "OTOMIND" , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_OFCAPD2; i++) {
        (*OFCAPD2     [i]) (31,  0, "OFCAPD2" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_ICR2D; i++) {
        (*ICR2D       [i]) (31,  0, "ICR2D"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_DCNTD; i++) {
        (*DCNTD       [i]) (31,  0, "CNTD"    , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_OFCAPD1; i++) {
        (*OFCAPD1     [i]) (31,  0, "OFCAPD1" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_OFMIND; i++) {
        (*OFMIND      [i]) (31,  0, "OFMIND"  , 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_OFMICNTD; i++) {
        (*OFMICNTD    [i]) (31,  0, "OFMICNTD", 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_ONCAPD1; i++) {
        (*ONCAPD1     [i]) (31,  0, "ONCAPD1" , 0x0       , "R"     , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_ICR1D; i++) {
        (*ICR1D       [i]) (31,  0, "ICR1D"   , 0x0       , "R"     , vpcl::SPP_ENABLE);
    }
    for(uint i = 0; i < emNUM_OTONMICNTD; i++) {
        (*OTONMICNTD  [i]) (31,  0, "OTONMICNTD", 0x0       , "R|W"   , vpcl::SPP_ENABLE);
    }

    mFileName = "";
    mInstName = name;
    mLineNum = 0;
    mBusWidth = buswidth;
    mBusByteWidth = mBusWidth/8;   // using in BIG ENDIAN
    mIsReset = false;

    // Constructor the callback function of each register
    for (uint i = 0; i < mTotalRegNum; i++) {
        mWrCbAPI[mRegArray[i]->my_p->name()][mRegArray[i]->my_p->name()] = NULL;
        mRdCbAPI[mRegArray[i]->my_p->name()][mRegArray[i]->my_p->name()] = NULL;
    }

    //Constructor the mWrCbAPI, mRdCbAPI variable of each register
    mWrCbAPI["TCRD"    ]["OBRED"   ] = &Catu5010_timerd_sub_regif::cb_TCRD_OBRED;
    mWrCbAPI["TCCRLRD" ]["CLRSEL2D"] = &Catu5010_timerd_sub_regif::cb_TCCRLRD_CLRSEL2D;
    mWrCbAPI["TIOR1D"  ]["OSSD3"   ] = &Catu5010_timerd_sub_regif::cb_TIOR1D_OSSD3;
    mWrCbAPI["TIOR2D"  ]["IOBD3"   ] = &Catu5010_timerd_sub_regif::cb_TIOR2D_IOBD3;
    mWrCbAPI["TCMPED"  ]["CMPE2D3" ] = &Catu5010_timerd_sub_regif::cb_TCMPED_CMPE2D3;
    mWrCbAPI["TIORD"   ]["IO2D3"   ] = &Catu5010_timerd_sub_regif::cb_TIORD_IO2D3;
    mWrCbAPI["OSELRD"  ]["OSELBD3" ] = &Catu5010_timerd_sub_regif::cb_OSELRD_OSELBD3;
    mWrCbAPI["ODRD"    ]["ODBD3"   ] = &Catu5010_timerd_sub_regif::cb_ODRD_ODBD3;
    mWrCbAPI["DSCRD"   ]["DWRFCD0" ] = &Catu5010_timerd_sub_regif::cb_DSCRD_DWRFCD0;
    mWrCbAPI["TSCRD"   ]["OVFC2D"  ] = &Catu5010_timerd_sub_regif::cb_TSCRD_OVFC2D;
    mWrCbAPI["TOCRD"   ]["TONEBD"  ] = &Catu5010_timerd_sub_regif::cb_TOCRD_TONEBD;
    mWrCbAPI["TOCCRD"  ]["TONEBD3" ] = &Catu5010_timerd_sub_regif::cb_TOCCRD_TONEBD3;
    mWrCbAPI["TCNT1D"  ]["TCNT1D"  ] = &Catu5010_timerd_sub_regif::cb_TCNT1D_TCNT1D;
    mWrCbAPI["TCNT2D"  ]["TCNT2D"  ] = &Catu5010_timerd_sub_regif::cb_TCNT2D_TCNT2D;
    mWrCbAPI["CUCR1D"  ]["CUCR1D"  ] = &Catu5010_timerd_sub_regif::cb_CUCR1D_CUCR1D;
    mWrCbAPI["CUCR2D"  ]["CUCR2D"  ] = &Catu5010_timerd_sub_regif::cb_CUCR2D_CUCR2D;
    mWrCbAPI["RCR1D"   ]["RC1D"    ] = &Catu5010_timerd_sub_regif::cb_RCR1D_RC1D;
    mWrCbAPI["RCR2D"   ]["RC2D"    ] = &Catu5010_timerd_sub_regif::cb_RCR2D_RC2D;
    mWrCbAPI["TIER1D"  ]["OV2ED"   ] = &Catu5010_timerd_sub_regif::cb_TIER1D_OV2ED;
    mWrCbAPI["TIER2D"  ]["UNDED3"  ] = &Catu5010_timerd_sub_regif::cb_TIER2D_UNDED3;
    mWrCbAPI["TIER3D"  ]["FEIED3"  ] = &Catu5010_timerd_sub_regif::cb_TIER3D_FEIED3;
    mWrCbAPI["TSCR2D"  ]["FEFCD3"  ] = &Catu5010_timerd_sub_regif::cb_TSCR2D_FEFCD3;

    for(uint i = 0; i < emNUM_OCR1D; i++) {
        str_tmp.str("");
        str_tmp<<"OCR1D"<< i;
        mWrCbAPI[str_tmp.str()]["OC1D"] = &Catu5010_timerd_sub_regif::cb_OCR1D_OC1D;
    }
    for(uint i = 0; i < emNUM_OCR2D; i++) {
        str_tmp.str("");
        str_tmp<<"OCR2D"<< i;
        mWrCbAPI[str_tmp.str()]["OC2D"] = &Catu5010_timerd_sub_regif::cb_OCR2D_OC2D;
    }
    for(uint i = 0; i < emNUM_OFMICNTD; i++) {
        str_tmp.str("");
        str_tmp<<"OFMICNTD"<< i;
        mWrCbAPI[str_tmp.str()]["OFMICNTD"] = &Catu5010_timerd_sub_regif::cb_OFMICNTD_OFMICNTD;
    }
    for(uint i = 0; i < emNUM_ONMICNTD; i++) {
        str_tmp.str("");
        str_tmp<<"ONMICNTD"<< i;
        mWrCbAPI[str_tmp.str()]["ONMICNTD"] = &Catu5010_timerd_sub_regif::cb_ONMICNTD_ONMICNTD;
    }
    for(uint i = 0; i < emNUM_OTONMICNTD; i++) {
        str_tmp.str("");
        str_tmp<<"OTONMICNTD"<< i;
        mWrCbAPI[str_tmp.str()]["OTONMICNTD"] = &Catu5010_timerd_sub_regif::cb_OTONMICNTD_OTONMICNTD;
    }
    InitLocalVal();
}

/// Destructor: delete pointers
/// @return none
Catu5010_timerd_sub_regif::~Catu5010_timerd_sub_regif()
{
    // Delete registers' pointer
    for (uint i = 0 ; i < mTotalRegNum ; i++) {
        delete mRegArray[i]->my_p;
        mRegArray[i]->prev = NULL;
    }
    delete [] mRegMap;
    delete [] mRegArray;
    delete mRegList;
    mCurReg = NULL;
}

/// Mask unselected bit
/// @return selected value
Catu5010_timerd_sub_regif::uint Catu5010_timerd_sub_regif::bit_select(
                                       cuint val,    ///< [in] Writting address
                                       cuint start,  ///< [in] start bit position
                                       cuint end)    ///< [in] end bit position
{
    uint ret_val = val;
    if (end - start + 1 < 32) {
        ret_val = (val>>start) & (uint)((1<<(end-start+1))-1);
    }
    return ret_val;
}

/// Write the value to requested module register
/// @return true if writing transaction is finished normally
bool Catu5010_timerd_sub_regif::reg_wr(cuint addr,                    ///< [in] Writting address
                                       const unsigned char *p_data,   ///< [in] Writing data
                                       cuint size)                    ///< [in] Data size (byte)
{
    if(size == 0) return false;
    #ifdef IS_MODELED_ENDIAN_BIG
    if ((addr % mBusByteWidth) + size > mBusByteWidth) return false;
    #endif

    bool ret_val = false;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(p_data != NULL);
    #else
    sc_assert(p_data != NULL);
    #endif
    ret_val = reg_wr_process (addr, p_data, size, false);
    return ret_val;
}

/// Read the register value of requested module
/// @return true if reading transaction is finished normally
bool Catu5010_timerd_sub_regif::reg_rd(cuint addr,              ///< [in]  Reading address
                                       unsigned char *p_data,   ///< [out] Reading data
                                       cuint size)              ///< [in]  Data size (byte)
{
    if(size == 0) return false;
    #ifdef IS_MODELED_ENDIAN_BIG
    if ((addr % mBusByteWidth) + size > mBusByteWidth) return false;
    #endif

    bool ret_val = false;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(p_data != NULL);
    #else
    sc_assert(p_data != NULL);
    #endif
    ret_val = reg_rd_process (addr, p_data, size, false);
    return ret_val;
}

/// Write the value to requested module register
/// @return true if writing transaction is finished normally
bool Catu5010_timerd_sub_regif::reg_wr_dbg(cuint addr,                    ///< [in] Writting address
                                           const unsigned char *p_data,   ///< [in] Writing data
                                           cuint size)                    ///< [in] Data size (byte)
{
    if(size == 0) return false;
    #ifdef IS_MODELED_ENDIAN_BIG
    if ((addr % mBusByteWidth) + size > mBusByteWidth) return false;
    #endif

    bool ret_val = false;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(p_data != NULL);
    #else
    sc_assert(p_data != NULL);
    #endif
    ret_val = reg_wr_process (addr, p_data, size, true);
    return ret_val;
}

/// Read the register value of requested module
/// @return true if reading transaction is finished normally
bool Catu5010_timerd_sub_regif::reg_rd_dbg(cuint addr,              ///< [in]  Reading address
                                           unsigned char *p_data,   ///< [out] Reading data
                                           cuint size)              ///< [in]  Data size (byte)
{
    if(size == 0) return false;
    #ifdef IS_MODELED_ENDIAN_BIG
    if ((addr % mBusByteWidth) + size > mBusByteWidth) return false;
    #endif

    bool ret_val = false;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(p_data != NULL);
    #else
    sc_assert(p_data != NULL);
    #endif
    ret_val = reg_rd_process (addr, p_data, size, true);
    return ret_val;
}

/// Write the value to requested module register
/// @return true if writing transaction is finished normally
bool Catu5010_timerd_sub_regif::reg_wr_process(cuint addr,                   ///< [in] Writting address
                                               const unsigned char *p_data,  ///< [in] Writing data
                                               cuint size,                   ///< [in] Data size (byte)
                                               bool IsDbgFunc)               ///< [in] flag indicate reg_rd or reg_rd_dbg
{
    if (mIsReset == true) {
        re_printf("warning", "Cannot write during reset period\n");
        return true;
    }
    uint tmp_addr = addr;
    #ifdef IS_MODELED_ENDIAN_BIG
    if (size < mBusByteWidth) {
        tmp_addr = addr ^ (mBusByteWidth - size);
    }
    #endif
    bool ret_val = false;
    bool valid_addr = false;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(p_data != NULL);
    #else
    sc_assert(p_data != NULL);
    #endif
    std::list<uint> list_index;
    uint masked_addr = bit_select(tmp_addr, 0, 9-1);
    uint access_addr = masked_addr;
    while (masked_addr + size > access_addr) {
        int reg_index = get_reg_index(access_addr);
        if (reg_index != -1) {
            vpcl::re_register *reg_p = mRegArray[reg_index]->my_p; 
            if ((IsDbgFunc == true) || (valid_addr == true) || (ChkSize(mRegArray[reg_index]->wacc_size, size, tmp_addr))) {
                valid_addr = true;
                list_index.push_back(reg_index);
            }
            else {
                re_printf("error", "Writing access size to %s at address 0x%08X is wrong: %d byte(s).\n", reg_p->name().c_str(), tmp_addr, size);
                return false;
            }
            access_addr = reg_p->addr() + mRegArray[reg_index]->length;
        } else {
            access_addr += 1;
        }
    }
    if (valid_addr == true) {
        std::list<uint>::iterator it;
        for (it=list_index.begin() ; it!=list_index.end() ; it++) {
            access_addr = masked_addr;
            uint d_size = size;
            uint index = 0;
            if (masked_addr < mRegArray[(*it)]->my_p->addr()) { // adjust access address & index
                access_addr = mRegArray[(*it)]->my_p->addr();
                index = mRegArray[(*it)]->my_p->addr() - masked_addr;
            }
            if ((masked_addr + size) < (mRegArray[(*it)]->my_p->addr() + mRegArray[(*it)]->length)) { // adjust access size
                d_size = masked_addr + size - access_addr;
            } else { // adjust access size
                d_size = (mRegArray[(*it)]->my_p->addr() + mRegArray[(*it)]->length) - access_addr;
            }
            if (size > mRegArray[(*it)]->length) { // adjust index for big endianess
                #ifdef IS_MODELED_ENDIAN_BIG
                index = index ^ (size - mRegArray[(*it)]->length);
                #endif
            }
            ret_val = reg_wr_func(tmp_addr - masked_addr + access_addr, &(p_data[index]), d_size, (*it), IsDbgFunc);
        }
    } else {
        if (IsDbgFunc == false) {
            re_printf("error", "Invalid access address 0x%08X\n", tmp_addr);
        } else {
            ret_val = true;
        }
    }
    return ret_val;
}

/// Read the register value of requested module
/// @return true if reading transaction is finished normally
bool Catu5010_timerd_sub_regif::reg_rd_process(cuint addr,              ///< [in]  Reading address
                                               unsigned char *p_data,   ///< [out] Reading data
                                               cuint size,              ///< [in]  Data size (byte)
                                               bool IsDbgFunc)          ///< [in] flag indicate reg_rd or reg_rd_dbg
{
    uint tmp_addr = addr;
    #ifdef IS_MODELED_ENDIAN_BIG
    if (size < mBusByteWidth) {
        tmp_addr = addr ^ (mBusByteWidth - size);
    }
    #endif
    bool ret_val = false;
    bool valid_addr = false;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(p_data != NULL);
    #else
    sc_assert(p_data != NULL);
    #endif
    std::list<uint> list_index;
    uint masked_addr = bit_select(tmp_addr, 0, 9-1);
    uint access_addr = masked_addr;
    while (masked_addr + size > access_addr) {
        int reg_index = get_reg_index(access_addr);
        if (reg_index != -1) {
            vpcl::re_register *reg_p = mRegArray[reg_index]->my_p; 
            if ((IsDbgFunc == true) || (valid_addr == true) || (ChkSize(mRegArray[reg_index]->racc_size, size, tmp_addr))) {
                valid_addr = true;
                list_index.push_back(reg_index);
            }
            else {
                re_printf("error", "Reading access size to %s at address 0x%08X is wrong: %d byte(s).\n", reg_p->name().c_str(), tmp_addr, size);
                return false;
            }
            access_addr = reg_p->addr() + mRegArray[reg_index]->length;
        } else {
            access_addr += 1;
        }
    }
    if (valid_addr == true) {
        std::list<uint>::iterator it;
        for (it=list_index.begin() ; it!=list_index.end() ; it++) {
            access_addr = masked_addr;
            uint d_size = size;
            uint index = 0;
            if (masked_addr < mRegArray[(*it)]->my_p->addr()) { // adjust access address & index
                access_addr = mRegArray[(*it)]->my_p->addr();
                index = mRegArray[(*it)]->my_p->addr() - masked_addr;
            }
            if ((masked_addr + size) < (mRegArray[(*it)]->my_p->addr() + mRegArray[(*it)]->length)) { // adjust access size
                d_size = masked_addr + size - access_addr;
            } else { // adjust access size
                d_size = (mRegArray[(*it)]->my_p->addr() + mRegArray[(*it)]->length) - access_addr;
            }
            if (size > mRegArray[(*it)]->length) { // adjust index for big endianess
                #ifdef IS_MODELED_ENDIAN_BIG
                index = index ^ (size - mRegArray[(*it)]->length);
                #endif
            }
            ret_val = reg_rd_func(tmp_addr - masked_addr + access_addr, &(p_data[index]), d_size, (*it), IsDbgFunc);
        }
    } else {
        if (IsDbgFunc == false) {
            re_printf("error", "Invalid access address 0x%08X\n", tmp_addr);
        } else {
            memset(p_data, 0, size);
            ret_val = true;
        }
    }
    return ret_val;
}

/// Process reading function
/// @return true if reading successfully
bool Catu5010_timerd_sub_regif::reg_rd_func(cuint addr,                     ///< [in]  Reading address
                                            unsigned char *p_data,          ///< [out] Reading data
                                            cuint size,                     ///< [in]  Data size (byte)
                                            cuint reg_index,                ///< [in] Register index
                                            bool IsDbgFunc)                 ///< [in] flag indicate reg_rd or reg_rd_dbg
{
    vpcl::re_register* Register = mRegArray[reg_index]->my_p;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(Register != NULL);
    #else
    sc_assert(Register != NULL);
    #endif
    
    uint pst_data = 0;
    #if 1 // always 1 since any size can be accessed in debug mode 
    uint reg_length = mRegArray[reg_index]->length;
    uint start_pos = 0;
    uint mask_size = (1 << (reg_length/2)) - 1;
    if (size < reg_length) {
        #ifdef IS_MODELED_ENDIAN_BIG
        start_pos =  (reg_length - 1)*8 - (addr & mask_size)*8; // Start bit position
        #else
        start_pos =  (addr & mask_size)*8;  // Start bit position
        #endif
    }
    #endif
    if (IsDbgFunc == false) {
        if (mIsReset == true) {
            re_printf("warning", "Cannot launch call-back function during reset period\n");
        }else {
            #if 1 // always 1 since any size can be accessed in debug mode 
            if (size < reg_length) {
                re_printf("warning","Should read all bit in a register\n");
            }
            #endif
            
            pst_data = Register->read();
            
        }
    }
    pst_data = (uint)(*Register);
    #if 1 // always 1 since any size can be accessed in debug mode 
    if (size < reg_length) {
        uint read_data = 0;
        if (((reg_length%2 == 0) && (reg_length%size == 0) && ((addr&mask_size)%size == 0)) 
         || (IsDbgFunc == false)) {
            for (uint i = start_pos; i < (8*size + start_pos); i++) {
                read_data |= (pst_data & (1 << i)) >> start_pos;
            }
            pst_data = read_data;
        }
    }
    #endif

    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(p_data != NULL);
    #else
    sc_assert(p_data != NULL);
    #endif
    memcpy(p_data, &pst_data, size);
    DumpRegMsg("R", Register->name(), "", size, addr, 0, 0, pst_data, mRegArray[reg_index]->length*8);
    for (vpcl::bit_info *it=Register->mBitInfo ; it!=NULL ; it=it->next) {
        uint val = (uint)(*Register);
        val = bit_select(val, it->mStartAddr, it->mEndAddr);
        DumpRegMsg("R", Register->name(), it->name(), size, addr, 0, 0, val, it->mEndAddr - it->mStartAddr + 1);
    }
    return true;
}

/// Process writing function
/// @return true if writing successfully
bool Catu5010_timerd_sub_regif::reg_wr_func(cuint addr,                       ///< [in] Writting address
                                            const unsigned char *p_data,      ///< [in] Writing data
                                            cuint size,                       ///< [in] Data size (byte)
                                            cuint reg_index,                  ///< [in] Register index
                                            bool IsDbgFunc)                   ///< [in] flag indicate reg_wr or reg_wr_dbg
{
    vpcl::re_register* Register = mRegArray[reg_index]->my_p;
    uint pre_data = 0;
    uint data = 0;
    #if 1 // always 1 since any size can be accessed in debug mode 
    uint reg_length = mRegArray[reg_index]->length;
    uint start_pos = 0;
    #endif
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert ((p_data != NULL) && (Register != NULL));
    #else
    sc_assert ((p_data != NULL) && (Register != NULL));
    #endif
    memcpy(&data, p_data, size);
    #if 1 // always 1 since any size can be accessed in debug mode 
    if (size < reg_length) {
        uint mask_size = (1 << (reg_length/2)) - 1;
        if (((reg_length%2 == 0) && (reg_length%size == 0) && ((addr&mask_size)%size == 0)) 
         || (IsDbgFunc == false)) {
            uint new_data = (uint)(*Register);  // For writing to register
            uint written_data = 0;         // For transferring to callback function
            #ifdef IS_MODELED_ENDIAN_BIG
            start_pos =  (reg_length - 1)*8 - (addr & mask_size)*8; // Start bit position
            #else
            start_pos =  (addr & mask_size)*8;  // Start bit position
            #endif
            for (uint i = start_pos; i < (8*size + start_pos); i++) {
                new_data = (new_data & (~(1 << i))) | ((data << start_pos) & (1 << i));
                written_data = (written_data & (~(1 << i))) | ((data << start_pos) & (1 << i));
            }
            data = new_data;
        }
    }
    #endif

    if ((mRegArray[reg_index]->block == false) || (IsDbgFunc == true)){
        pre_data = (uint)(*Register);
        if (IsDbgFunc == true) {
            bool backup_warning = Register->mMessageLevel["warning"];
            bool backup_error = Register->mMessageLevel["error"];
            Register->mMessageLevel["warning"]   = false;
            Register->mMessageLevel["error"]   = false;

            Register->write(data);

            Register->mMessageLevel["warning"]   = backup_warning;
            Register->mMessageLevel["error"]   = backup_error;
        } else {
            Register->write(data);
        }
        UpdateLocalVal(Register->addr());
        DumpRegMsg("W", Register->name(), "", size, addr, data, pre_data, (uint)(*Register), mRegArray[reg_index]->length*8);
        for (vpcl::bit_info *it=Register->mBitInfo ; it!=NULL ; it=it->next) {
            uint val = (uint)(*Register);
            val = bit_select(val, it->mStartAddr, it->mEndAddr);
            uint pre_val = pre_data;
            pre_val = bit_select(pre_val, it->mStartAddr, it->mEndAddr);
            DumpRegMsg("W", Register->name(), it->name(), size, addr, 0, pre_val, val, it->mEndAddr - it->mStartAddr + 1);
            if ((mWrCbAPI[Register->name()][it->name()]) != NULL) {
                (this->*(mWrCbAPI[Register->name()][it->name()]))(RegCBstr(mRegArray[reg_index]->channel, true, size, pre_data, data));
            }
        }
    }
    else {
        re_printf("warning","%s is blocked writing from Bus I/F.\n", Register->name().c_str());
    }
    return true;
}

/// Check access size
/// @@return true if detect_size equal expect_size
bool Catu5010_timerd_sub_regif::ChkSize(std::string expect_size, cuint detect_size, cuint addr)
{
    std::vector<std::string> arg_vec = Str2Vec(expect_size, '|');
    std::vector<std::string>::iterator it;
    char *err_p = NULL;
    uint size = 0;
    if (detect_size > mBusByteWidth) {
        re_printf("error", "Invalid access size: %d bytes\n", detect_size);
        return false;
    }
    if(addr%detect_size != 0) {
        re_printf("error", "Invalid access address 0x%08X with access size %d bytes\n", addr, detect_size);
        return false;
    }
    for (it = arg_vec.begin(); it != arg_vec.end(); it++) {
        errno = 0; size = (uint) strtoul((*it).c_str(), &err_p, 0);
        #ifdef REGIF_NOT_USE_SYSTEMC
        assert(err_p != NULL);
        #else
        sc_assert(err_p != NULL);
        #endif
        if (errno != ERANGE && *err_p == '\0') {
            if ((size/8) == detect_size) {
                return true;
            }
        }
    }
    return false;
}

/// Initialize reg_handle_command variables
/// @return none
void Catu5010_timerd_sub_regif::CommandInit()
{
    mDumpRegisterRW = false;
    mMessageLevel["fatal"]   = true;
    mMessageLevel["error"]   = true;
    mMessageLevel["warning"] = false;
    mMessageLevel["info"]    = false;
}

/// Process reg_handle_command command
/// @return string
std::string Catu5010_timerd_sub_regif::reg_handle_command(const std::vector<std::string>& args)
{
    std::string ret = "";
    std::string err_msg = "Error ("   + mInstName + ") ";   // error message
    if (args[0] == "reg") {
        if (args[1] == "help") {
            ret += "    --- reg ---\n";
            ret += "    reg MessageLevel <fatal|error|warning|info> Select debug message level (Default: fatal,error)\n";
            ret += "    reg DumpRegisterRW <true/false>             Select dump register access information  (Default: false)\n";
            ret += "    reg <register_name> MessageLevel <fatal|error|warning|info> Select debug message level for register (Default: fatal,error)\n";
            ret += "    reg <register_name> force <value>           Force register with setting value\n";
            ret += "    reg <register_name> release                 Release register from force value\n";
            ret += "    reg <register_name> <value>                 Write a value into register\n";
            ret += "    reg <register_name>                         Read value of register\n";
            ret += "    reg help                                    Show a direction\n";
        }
        else if (args[1] == "DumpRegisterRW") {
            if (args.size() == 2) {
                ret = (mDumpRegisterRW)? "true" : "false";
            }
            else if (args.size() == 3) {
                if (args[2] == "true") {
                    mDumpRegisterRW = true;
                }
                else if (args[2] == "false") {
                    mDumpRegisterRW = false;
                } else {
                    ret = err_msg + "DumpRegisterRW command needs an argument [true/false]\n";
                }
            } else {
                ret = err_msg + "DumpRegisterRW has too much arguments\n";
            }
        }
        else if (args[1] == "MessageLevel") {
            // read mode
            if (args.size() == 2) {
                std::map<std::string, bool>::iterator it;
                for (it = mMessageLevel.begin(); it != mMessageLevel.end(); it++) {
                    if ( it->second == true ) {
                        ret += " " + it->first;
                    }
                }
            // write mode
            } else if (args.size() == 3) {
                std::vector<std::string> arg_vec = Str2Vec(args[2], '|');
                std::map<std::string, bool>::iterator msgit;
                for (msgit =mMessageLevel.begin(); msgit != mMessageLevel.end(); msgit++) {
                    msgit->second = false;
                }
                std::vector<std::string>::iterator it;
                for (it = arg_vec.begin(); it != arg_vec.end(); it++) {
                    mMessageLevel[*it] = true;
                }
            } else {
                ret = err_msg + "MessageLevel has too much arguments\n";
            }
        } else {
            bool matched = false;
            for (uint i = 0; i < mTotalRegNum; i++) {
                if (args[1] == mRegArray[i]->my_p->name()) {
                    ret = AccessRegCommand(args, mRegArray[i]->my_p, mRegArray[i]->block);
                    matched = true;
                    break;
                }
            }
            if (!matched) {
                ret = err_msg + "Register name " + (std::string)args[1] + " is invalid\n";
            }
        }
    }
    return ret;
}

/// process reg_handle_command of "reg" parameter
/// @return string
std::string Catu5010_timerd_sub_regif::AccessRegCommand(const std::vector<std::string>& args, vpcl::re_register *Register, bool &BlockReg)
{
    std::string ret = "";
    char *err_p = NULL;
    std::string err_msg = "Error ("   + mInstName + ") ";   // error message
    uint data = 0;
    std::ostringstream str_tmp;
    #ifdef REGIF_NOT_USE_SYSTEMC
    assert(Register != NULL);
    #else
    sc_assert(Register != NULL);
    #endif
    if (args.size() == 2) {
        data = (uint)(*Register);
        str_tmp<<std::setw(14)<<std::left<<(Register->name());
        str_tmp<<"0x"<<std::setw(8)<<std::hex<<std::uppercase<<std::left<<data<<"\n";
        ret = str_tmp.str();
    } else if ((args.size() == 3) && (args[2] == "release")) {
        BlockReg = false;
    } else if ((args.size() == 4) && (args[2] == "force")) {
        errno = 0; data = (uint) strtoul(args[3].c_str(), &err_p, 0);
        #ifdef REGIF_NOT_USE_SYSTEMC
        assert(err_p != NULL);
        #else
        sc_assert(err_p != NULL);
        #endif
        if (errno != ERANGE && *err_p == '\0') {
            *Register = data;
            BlockReg = true;
            UpdateLocalVal(Register->addr());
        } else {
            ret = err_msg + "[" + Register->name() + "] Invalid force value\n";
        }
    } else if ((args.size() >= 3) && (args[2] == "MessageLevel")) {
        if (args.size() == 3) {
            ret = Register->name() + " ";
            ret += Register->GetMessageLevel();
        } else if (args.size() == 4) {
            std::map<std::string, bool> MessageLevel;
            std::vector<std::string> arg_vec = Str2Vec(args[3], '|');
            std::vector<std::string>::iterator it;
            for (it = arg_vec.begin(); it != arg_vec.end(); it++) {
                MessageLevel[*it] = true;
            }
            Register->SetMessageLevel(MessageLevel);
        } else {
            ret = err_msg + "[" + Register->name() + "] MessageLevel has too much arguments\n";
        }
    } else if ((args.size() == 3) && (args[2] != "release")) {
        errno = 0; data = (uint) strtoul(args[2].c_str(), &err_p, 0);
        if (errno != ERANGE && *err_p == '\0') {
            *Register = data;
            UpdateLocalVal(Register->addr());
        } else {
            ret = err_msg + "[" + Register->name() + "] Invalid write value\n";
        }
    } else {
        ret = err_msg + "Wrong command : ";
        for (uint index = 0; index < args.size(); index ++) {
            ret += args[index] + " ";
        }
    }
    return ret;
}

/// Initialize local variables
/// @return none
void Catu5010_timerd_sub_regif::InitLocalVal()
{
    // Initialize local variables
    TCRD_OBRED    = 0x0;
    TCRD_C2CED    = 0x0;
    TCRD_C1CED    = 0x0;
    TCRD_CLR2D    = 0x0;
    TCRD_CKSEL2D  = 0x0;
    TCRD_CLR1D    = 0x0;
    TCRD_CKSEL1D  = 0x0;
    TCRD_DCSELD   = 0x0;
    TCCRLRD_CLRSEL2D = 0x0;
    TCCRLRD_CLRSEL1D = 0x0;
    TCCRLRD_CMPSEL2D3 = 0x0;
    TCCRLRD_CMPSEL2D2 = 0x0;
    TCCRLRD_CMPSEL2D1 = 0x0;
    TCCRLRD_CMPSEL2D0 = 0x0;
    TCCRLRD_CMPSEL1D3 = 0x0;
    TCCRLRD_CMPSEL1D2 = 0x0;
    TCCRLRD_CMPSEL1D1 = 0x0;
    TCCRLRD_CMPSEL1D0 = 0x0;
    TIOR1D_OSSD3  = 0x0;
    TIOR1D_OSSD2  = 0x0;
    TIOR1D_OSSD1  = 0x0;
    TIOR1D_OSSD0  = 0x0;
    TIOR1D_IOAD3  = 0x0;
    TIOR1D_IOAD2  = 0x0;
    TIOR1D_IOAD1  = 0x0;
    TIOR1D_IOAD0  = 0x0;
    TIOR2D_IOBD3  = 0x0;
    TIOR2D_IOBD2  = 0x0;
    TIOR2D_IOBD1  = 0x0;
    TIOR2D_IOBD0  = 0x0;
    TCMPED_CMPE2D3 = 0x0;
    TCMPED_CMPE2D2 = 0x0;
    TCMPED_CMPE2D1 = 0x0;
    TCMPED_CMPE2D0 = 0x0;
    TCMPED_CMPE1D3 = 0x0;
    TCMPED_CMPE1D2 = 0x0;
    TCMPED_CMPE1D1 = 0x0;
    TCMPED_CMPE1D0 = 0x0;
    TIORD_IO2D3   = 0x3;
    TIORD_IO2D2   = 0x3;
    TIORD_IO2D1   = 0x3;
    TIORD_IO2D0   = 0x3;
    TIORD_IO1D3   = 0x3;
    TIORD_IO1D2   = 0x3;
    TIORD_IO1D1   = 0x3;
    TIORD_IO1D0   = 0x3;
    OSELRD_OSELBD3 = 0x0;
    OSELRD_OSELBD2 = 0x0;
    OSELRD_OSELBD1 = 0x0;
    OSELRD_OSELBD0 = 0x0;
    OSELRD_OSELAD3 = 0x0;
    OSELRD_OSELAD2 = 0x0;
    OSELRD_OSELAD1 = 0x0;
    OSELRD_OSELAD0 = 0x0;
    ODRD_ODBD3    = 0x0;
    ODRD_ODBD2    = 0x0;
    ODRD_ODBD1    = 0x0;
    ODRD_ODBD0    = 0x0;
    ODRD_ODAD3    = 0x0;
    ODRD_ODAD2    = 0x0;
    ODRD_ODAD1    = 0x0;
    ODRD_ODAD0    = 0x0;
    DSTRD_DSTD3   = 0x0;
    DSTRD_DSTD2   = 0x0;
    DSTRD_DSTD1   = 0x0;
    DSTRD_DSTD0   = 0x0;
    DSR1D_DWFD3   = 0x0;
    DSR1D_DWFD2   = 0x0;
    DSR1D_DWFD1   = 0x0;
    DSR1D_DWFD0   = 0x0;
    DSR1D_DSFD3   = 0x0;
    DSR1D_DSFD2   = 0x0;
    DSR1D_DSFD1   = 0x0;
    DSR1D_DSFD0   = 0x0;
    DSR2D_DWRFD3  = 0x0;
    DSR2D_DWRFD2  = 0x0;
    DSR2D_DWRFD1  = 0x0;
    DSR2D_DWRFD0  = 0x0;
    DSCRD_DWFCD3  = 0x0;
    DSCRD_DWFCD2  = 0x0;
    DSCRD_DWFCD1  = 0x0;
    DSCRD_DWFCD0  = 0x0;
    DSCRD_DWRFCD3 = 0x0;
    DSCRD_DWRFCD2 = 0x0;
    DSCRD_DWRFCD1 = 0x0;
    DSCRD_DWRFCD0 = 0x0;
    DCRD_TRGSELD3 = 0x0;
    DCRD_TRGSELD2 = 0x0;
    DCRD_TRGSELD1 = 0x0;
    DCRD_TRGSELD0 = 0x0;
    TSRD_OVF2D    = 0x0;
    TSRD_OVF1D    = 0x0;
    TSRD_UDFD3    = 0x0;
    TSRD_UDFD2    = 0x0;
    TSRD_UDFD1    = 0x0;
    TSRD_UDFD0    = 0x0;
    TSRD_CMFAD3   = 0x0;
    TSRD_CMFAD2   = 0x0;
    TSRD_CMFAD1   = 0x0;
    TSRD_CMFAD0   = 0x0;
    TSRD_CMFBD3   = 0x0;
    TSRD_CMFBD2   = 0x0;
    TSRD_CMFBD1   = 0x0;
    TSRD_CMFBD0   = 0x0;
    TSCRD_OVFC2D  = 0x0;
    TSCRD_OVFC1D  = 0x0;
    TSCRD_UDFCD3  = 0x0;
    TSCRD_UDFCD2  = 0x0;
    TSCRD_UDFCD1  = 0x0;
    TSCRD_UDFCD0  = 0x0;
    TSCRD_CMFCAD3 = 0x0;
    TSCRD_CMFCAD2 = 0x0;
    TSCRD_CMFCAD1 = 0x0;
    TSCRD_CMFCAD0 = 0x0;
    TSCRD_CMFCBD3 = 0x0;
    TSCRD_CMFCBD2 = 0x0;
    TSCRD_CMFCBD1 = 0x0;
    TSCRD_CMFCBD0 = 0x0;
    TOCRD_TONEBD  = 0x0;
    TOCRD_TONEAD  = 0x0;
    TOCCRD_TONEBD3 = 0x0;
    TOCCRD_TONEBD2 = 0x0;
    TOCCRD_TONEBD1 = 0x0;
    TOCCRD_TONEBD0 = 0x0;
    TOCCRD_TONEAD3 = 0x0;
    TOCCRD_TONEAD2 = 0x0;
    TOCCRD_TONEAD1 = 0x0;
    TOCCRD_TONEAD0 = 0x0;
    OSBRD_OSBRD   = 0x0;
    TICTSELD_TIDSELD = 0x0;
    MIGCRD_MIGEND3 = 0x0;
    MIGCRD_MIGEND2 = 0x0;
    MIGCRD_MIGEND1 = 0x0;
    MIGCRD_MIGEND0 = 0x0;
    MIGSELD_MIGSEL3 = 0x0;
    MIGSELD_MIGSEL2 = 0x0;
    MIGSELD_MIGSEL1 = 0x0;
    MIGSELD_MIGSEL0 = 0x0;
    TCNT1D_TCNT1D = 0x0;
    TCNT2D_TCNT2D = 0x0;
    CUCR1D_CUCR1D = 0xFFFFFFFF;
    CUCR2D_CUCR2D = 0xFFFFFFFF;
    for(uint i = 0; i < emNUM_OCR1D;     i++) {
        OCR1D_OC1D   [i] = 0xFFFFFFFF;
    }
    RCR1D_RC1D    = 0x0;
    for(uint i = 0; i < emNUM_OCR2D;     i++) {
        OCR2D_OC2D   [i] = 0xFFFFFFFF;
    }
    RCR2D_RC2D    = 0x0;
    for(uint i = 0; i < emNUM_ICR1D;     i++) {
        ICR1D_ICR1D  [i] = 0x0;
    }
    for(uint i = 0; i < emNUM_ICR2D;     i++) {
        ICR2D_ICR2D  [i] = 0x0;
    }
    for(uint i = 0; i < emNUM_DCNTD;     i++) {
        DCNTD_CNTD   [i] = 0x0;
    }
    TIER1D_OV2ED  = 0x0;
    TIER1D_OV1ED  = 0x0;
    TIER2D_UNDED3 = 0x0;
    TIER2D_UNDED2 = 0x0;
    TIER2D_UNDED1 = 0x0;
    TIER2D_UNDED0 = 0x0;
    TIER2D_CMPBED3 = 0x0;
    TIER2D_CMPBED2 = 0x0;
    TIER2D_CMPBED1 = 0x0;
    TIER2D_CMPBED0 = 0x0;
    TIER2D_CMPAED3 = 0x0;
    TIER2D_CMPAED2 = 0x0;
    TIER2D_CMPAED1 = 0x0;
    TIER2D_CMPAED0 = 0x0;
    TIER3D_FEIED3 = 0x0;
    TIER3D_FEIED2 = 0x0;
    TIER3D_FEIED1 = 0x0;
    TIER3D_FEIED0 = 0x0;
    TIER3D_REIED3 = 0x0;
    TIER3D_REIED2 = 0x0;
    TIER3D_REIED1 = 0x0;
    TIER3D_REIED0 = 0x0;
    for(uint i = 0; i < emNUM_OFMIND;    i++) {
        OFMIND_OFMIND[i] = 0x0;
    }
    for(uint i = 0; i < emNUM_ONMIND;    i++) {
        ONMIND_ONMIND[i] = 0x0;
    }
    for(uint i = 0; i < emNUM_OTOMIND;   i++) {
        OTOMIND_OTOMIND[i] = 0x0;
    }
    for(uint i = 0; i < emNUM_OFMICNTD;  i++) {
        OFMICNTD_OFMICNTD[i] = 0x0;
    }
    for(uint i = 0; i < emNUM_ONMICNTD;  i++) {
        ONMICNTD_ONMICNTD[i] = 0x0;
    }
    for(uint i = 0; i < emNUM_OTONMICNTD; i++) {
        OTONMICNTD_OTONMICNTD[i] = 0x0;
    }
    for(uint i = 0; i < emNUM_ONCAPD1;   i++) {
        ONCAPD1_ONCAPD1[i] = 0x0;
    }
    for(uint i = 0; i < emNUM_ONCAPD2;   i++) {
        ONCAPD2_ONCAPD2[i] = 0x0;
    }
    for(uint i = 0; i < emNUM_OFCAPD1;   i++) {
        OFCAPD1_OFCAPD1[i] = 0x0;
    }
    for(uint i = 0; i < emNUM_OFCAPD2;   i++) {
        OFCAPD2_OFCAPD2[i] = 0x0;
    }
    TSR2D_FEFD3   = 0x0;
    TSR2D_FEFD2   = 0x0;
    TSR2D_FEFD1   = 0x0;
    TSR2D_FEFD0   = 0x0;
    TSR2D_REFD3   = 0x0;
    TSR2D_REFD2   = 0x0;
    TSR2D_REFD1   = 0x0;
    TSR2D_REFD0   = 0x0;
    TSCR2D_FEFCD3 = 0x0;
    TSCR2D_FEFCD2 = 0x0;
    TSCR2D_FEFCD1 = 0x0;
    TSCR2D_FEFCD0 = 0x0;
    TSCR2D_REFCD3 = 0x0;
    TSCR2D_REFCD2 = 0x0;
    TSCR2D_REFCD1 = 0x0;
    TSCR2D_REFCD0 = 0x0;
}

/// Update bit value to local value
/// @return None
void Catu5010_timerd_sub_regif::UpdateLocalVal(cuint addr)
{
    if (addr == 0x0000) {
        TCRD_OBRED                     = (*TCRD      )["OBRED"     ];
        TCRD_C2CED                     = (*TCRD      )["C2CED"     ];
        TCRD_C1CED                     = (*TCRD      )["C1CED"     ];
        TCRD_CLR2D                     = (*TCRD      )["CLR2D"     ];
        TCRD_CKSEL2D                   = (*TCRD      )["CKSEL2D"   ];
        TCRD_CLR1D                     = (*TCRD      )["CLR1D"     ];
        TCRD_CKSEL1D                   = (*TCRD      )["CKSEL1D"   ];
        TCRD_DCSELD                    = (*TCRD      )["DCSELD"    ];
        return;
    }
    if (addr == 0x001C) {
        TCCRLRD_CLRSEL2D               = (*TCCRLRD   )["CLRSEL2D"  ];
        TCCRLRD_CLRSEL1D               = (*TCCRLRD   )["CLRSEL1D"  ];
        TCCRLRD_CMPSEL2D3              = (*TCCRLRD   )["CMPSEL2D3" ];
        TCCRLRD_CMPSEL2D2              = (*TCCRLRD   )["CMPSEL2D2" ];
        TCCRLRD_CMPSEL2D1              = (*TCCRLRD   )["CMPSEL2D1" ];
        TCCRLRD_CMPSEL2D0              = (*TCCRLRD   )["CMPSEL2D0" ];
        TCCRLRD_CMPSEL1D3              = (*TCCRLRD   )["CMPSEL1D3" ];
        TCCRLRD_CMPSEL1D2              = (*TCCRLRD   )["CMPSEL1D2" ];
        TCCRLRD_CMPSEL1D1              = (*TCCRLRD   )["CMPSEL1D1" ];
        TCCRLRD_CMPSEL1D0              = (*TCCRLRD   )["CMPSEL1D0" ];
        return;
    }
    if (addr == 0x0004) {
        TIOR1D_OSSD3                   = (*TIOR1D    )["OSSD3"     ];
        TIOR1D_OSSD2                   = (*TIOR1D    )["OSSD2"     ];
        TIOR1D_OSSD1                   = (*TIOR1D    )["OSSD1"     ];
        TIOR1D_OSSD0                   = (*TIOR1D    )["OSSD0"     ];
        TIOR1D_IOAD3                   = (*TIOR1D    )["IOAD3"     ];
        TIOR1D_IOAD2                   = (*TIOR1D    )["IOAD2"     ];
        TIOR1D_IOAD1                   = (*TIOR1D    )["IOAD1"     ];
        TIOR1D_IOAD0                   = (*TIOR1D    )["IOAD0"     ];
        return;
    }
    if (addr == 0x0006) {
        TIOR2D_IOBD3                   = (*TIOR2D    )["IOBD3"     ];
        TIOR2D_IOBD2                   = (*TIOR2D    )["IOBD2"     ];
        TIOR2D_IOBD1                   = (*TIOR2D    )["IOBD1"     ];
        TIOR2D_IOBD0                   = (*TIOR2D    )["IOBD0"     ];
        return;
    }
    if (addr == 0x003D) {
        TCMPED_CMPE2D3                 = (*TCMPED    )["CMPE2D3"   ];
        TCMPED_CMPE2D2                 = (*TCMPED    )["CMPE2D2"   ];
        TCMPED_CMPE2D1                 = (*TCMPED    )["CMPE2D1"   ];
        TCMPED_CMPE2D0                 = (*TCMPED    )["CMPE2D0"   ];
        TCMPED_CMPE1D3                 = (*TCMPED    )["CMPE1D3"   ];
        TCMPED_CMPE1D2                 = (*TCMPED    )["CMPE1D2"   ];
        TCMPED_CMPE1D1                 = (*TCMPED    )["CMPE1D1"   ];
        TCMPED_CMPE1D0                 = (*TCMPED    )["CMPE1D0"   ];
        return;
    }
    if (addr == 0x003E) {
        TIORD_IO2D3                    = (*TIORD     )["IO2D3"     ];
        TIORD_IO2D2                    = (*TIORD     )["IO2D2"     ];
        TIORD_IO2D1                    = (*TIORD     )["IO2D1"     ];
        TIORD_IO2D0                    = (*TIORD     )["IO2D0"     ];
        TIORD_IO1D3                    = (*TIORD     )["IO1D3"     ];
        TIORD_IO1D2                    = (*TIORD     )["IO1D2"     ];
        TIORD_IO1D1                    = (*TIORD     )["IO1D1"     ];
        TIORD_IO1D0                    = (*TIORD     )["IO1D0"     ];
        return;
    }
    if (addr == 0x0011) {
        OSELRD_OSELBD3                 = (*OSELRD    )["OSELBD3"   ];
        OSELRD_OSELBD2                 = (*OSELRD    )["OSELBD2"   ];
        OSELRD_OSELBD1                 = (*OSELRD    )["OSELBD1"   ];
        OSELRD_OSELBD0                 = (*OSELRD    )["OSELBD0"   ];
        OSELRD_OSELAD3                 = (*OSELRD    )["OSELAD3"   ];
        OSELRD_OSELAD2                 = (*OSELRD    )["OSELAD2"   ];
        OSELRD_OSELAD1                 = (*OSELRD    )["OSELAD1"   ];
        OSELRD_OSELAD0                 = (*OSELRD    )["OSELAD0"   ];
        return;
    }
    if (addr == 0x0012) {
        ODRD_ODBD3                     = (*ODRD      )["ODBD3"     ];
        ODRD_ODBD2                     = (*ODRD      )["ODBD2"     ];
        ODRD_ODBD1                     = (*ODRD      )["ODBD1"     ];
        ODRD_ODBD0                     = (*ODRD      )["ODBD0"     ];
        ODRD_ODAD3                     = (*ODRD      )["ODAD3"     ];
        ODRD_ODAD2                     = (*ODRD      )["ODAD2"     ];
        ODRD_ODAD1                     = (*ODRD      )["ODAD1"     ];
        ODRD_ODAD0                     = (*ODRD      )["ODAD0"     ];
        return;
    }
    if (addr == 0x0008) {
        DSTRD_DSTD3                    = (*DSTRD     )["DSTD3"     ];
        DSTRD_DSTD2                    = (*DSTRD     )["DSTD2"     ];
        DSTRD_DSTD1                    = (*DSTRD     )["DSTD1"     ];
        DSTRD_DSTD0                    = (*DSTRD     )["DSTD0"     ];
        return;
    }
    if (addr == 0x000A) {
        DSR1D_DWFD3                    = (*DSR1D     )["DWFD3"     ];
        DSR1D_DWFD2                    = (*DSR1D     )["DWFD2"     ];
        DSR1D_DWFD1                    = (*DSR1D     )["DWFD1"     ];
        DSR1D_DWFD0                    = (*DSR1D     )["DWFD0"     ];
        DSR1D_DSFD3                    = (*DSR1D     )["DSFD3"     ];
        DSR1D_DSFD2                    = (*DSR1D     )["DSFD2"     ];
        DSR1D_DSFD1                    = (*DSR1D     )["DSFD1"     ];
        DSR1D_DSFD0                    = (*DSR1D     )["DSFD0"     ];
        return;
    }
    if (addr == 0x000B) {
        DSR2D_DWRFD3                   = (*DSR2D     )["DWRFD3"    ];
        DSR2D_DWRFD2                   = (*DSR2D     )["DWRFD2"    ];
        DSR2D_DWRFD1                   = (*DSR2D     )["DWRFD1"    ];
        DSR2D_DWRFD0                   = (*DSR2D     )["DWRFD0"    ];
        return;
    }
    if (addr == 0x0009) {
        DSCRD_DWFCD3                   = (*DSCRD     )["DWFCD3"    ];
        DSCRD_DWFCD2                   = (*DSCRD     )["DWFCD2"    ];
        DSCRD_DWFCD1                   = (*DSCRD     )["DWFCD1"    ];
        DSCRD_DWFCD0                   = (*DSCRD     )["DWFCD0"    ];
        DSCRD_DWRFCD3                  = (*DSCRD     )["DWRFCD3"   ];
        DSCRD_DWRFCD2                  = (*DSCRD     )["DWRFCD2"   ];
        DSCRD_DWRFCD1                  = (*DSCRD     )["DWRFCD1"   ];
        DSCRD_DWRFCD0                  = (*DSCRD     )["DWRFCD0"   ];
        return;
    }
    if (addr == 0x0002) {
        DCRD_TRGSELD3                  = (*DCRD      )["TRGSELD3"  ];
        DCRD_TRGSELD2                  = (*DCRD      )["TRGSELD2"  ];
        DCRD_TRGSELD1                  = (*DCRD      )["TRGSELD1"  ];
        DCRD_TRGSELD0                  = (*DCRD      )["TRGSELD0"  ];
        return;
    }
    if (addr == 0x000C) {
        TSRD_OVF2D                     = (*TSRD      )["OVF2D"     ];
        TSRD_OVF1D                     = (*TSRD      )["OVF1D"     ];
        TSRD_UDFD3                     = (*TSRD      )["UDFD3"     ];
        TSRD_UDFD2                     = (*TSRD      )["UDFD2"     ];
        TSRD_UDFD1                     = (*TSRD      )["UDFD1"     ];
        TSRD_UDFD0                     = (*TSRD      )["UDFD0"     ];
        TSRD_CMFAD3                    = (*TSRD      )["CMFAD3"    ];
        TSRD_CMFAD2                    = (*TSRD      )["CMFAD2"    ];
        TSRD_CMFAD1                    = (*TSRD      )["CMFAD1"    ];
        TSRD_CMFAD0                    = (*TSRD      )["CMFAD0"    ];
        TSRD_CMFBD3                    = (*TSRD      )["CMFBD3"    ];
        TSRD_CMFBD2                    = (*TSRD      )["CMFBD2"    ];
        TSRD_CMFBD1                    = (*TSRD      )["CMFBD1"    ];
        TSRD_CMFBD0                    = (*TSRD      )["CMFBD0"    ];
        return;
    }
    if (addr == 0x000E) {
        TSCRD_OVFC2D                   = (*TSCRD     )["OVFC2D"    ];
        TSCRD_OVFC1D                   = (*TSCRD     )["OVFC1D"    ];
        TSCRD_UDFCD3                   = (*TSCRD     )["UDFCD3"    ];
        TSCRD_UDFCD2                   = (*TSCRD     )["UDFCD2"    ];
        TSCRD_UDFCD1                   = (*TSCRD     )["UDFCD1"    ];
        TSCRD_UDFCD0                   = (*TSCRD     )["UDFCD0"    ];
        TSCRD_CMFCAD3                  = (*TSCRD     )["CMFCAD3"   ];
        TSCRD_CMFCAD2                  = (*TSCRD     )["CMFCAD2"   ];
        TSCRD_CMFCAD1                  = (*TSCRD     )["CMFCAD1"   ];
        TSCRD_CMFCAD0                  = (*TSCRD     )["CMFCAD0"   ];
        TSCRD_CMFCBD3                  = (*TSCRD     )["CMFCBD3"   ];
        TSCRD_CMFCBD2                  = (*TSCRD     )["CMFCBD2"   ];
        TSCRD_CMFCBD1                  = (*TSCRD     )["CMFCBD1"   ];
        TSCRD_CMFCBD0                  = (*TSCRD     )["CMFCBD0"   ];
        return;
    }
    if (addr == 0x0010) {
        TOCRD_TONEBD                   = (*TOCRD     )["TONEBD"    ];
        TOCRD_TONEAD                   = (*TOCRD     )["TONEAD"    ];
        return;
    }
    if (addr == 0x003C) {
        TOCCRD_TONEBD3                 = (*TOCCRD    )["TONEBD3"   ];
        TOCCRD_TONEBD2                 = (*TOCCRD    )["TONEBD2"   ];
        TOCCRD_TONEBD1                 = (*TOCCRD    )["TONEBD1"   ];
        TOCCRD_TONEBD0                 = (*TOCCRD    )["TONEBD0"   ];
        TOCCRD_TONEAD3                 = (*TOCCRD    )["TONEAD3"   ];
        TOCCRD_TONEAD2                 = (*TOCCRD    )["TONEAD2"   ];
        TOCCRD_TONEAD1                 = (*TOCCRD    )["TONEAD1"   ];
        TOCCRD_TONEAD0                 = (*TOCCRD    )["TONEAD0"   ];
        return;
    }
    if (addr == 0x0018) {
        OSBRD_OSBRD                    = (*OSBRD     )["OSBRD"     ];
        return;
    }
    if (addr == 0x0014) {
        TICTSELD_TIDSELD               = (*TICTSELD  )["TIDSELD"   ];
        return;
    }
    if (addr == 0x0016) {
        MIGCRD_MIGEND3                 = (*MIGCRD    )["MIGEND3"   ];
        MIGCRD_MIGEND2                 = (*MIGCRD    )["MIGEND2"   ];
        MIGCRD_MIGEND1                 = (*MIGCRD    )["MIGEND1"   ];
        MIGCRD_MIGEND0                 = (*MIGCRD    )["MIGEND0"   ];
        return;
    }
    if (addr == 0x0017) {
        MIGSELD_MIGSEL3                = (*MIGSELD   )["MIGSEL3"   ];
        MIGSELD_MIGSEL2                = (*MIGSELD   )["MIGSEL2"   ];
        MIGSELD_MIGSEL1                = (*MIGSELD   )["MIGSEL1"   ];
        MIGSELD_MIGSEL0                = (*MIGSELD   )["MIGSEL0"   ];
        return;
    }
    if (addr == 0x0020) {
        TCNT1D_TCNT1D                  = (*TCNT1D    )["TCNT1D"    ];
        return;
    }
    if (addr == 0x0024) {
        TCNT2D_TCNT2D                  = (*TCNT2D    )["TCNT2D"    ];
        return;
    }
    if (addr == 0x0028) {
        CUCR1D_CUCR1D                  = (*CUCR1D    )["CUCR1D"    ];
        return;
    }
    if (addr == 0x002C) {
        CUCR2D_CUCR2D                  = (*CUCR2D    )["CUCR2D"    ];
        return;
    }
    if ((0x0040 <= addr) && (addr <= (0x0040)+(32*3)) && ((addr-0x0040)%32 == 0)) {
        uint i = (addr - 0x0040)/32;
        OCR1D_OC1D                    [i] = (*(OCR1D     [i]))["OC1D"      ];
        return;
    }
    if (addr == 0x0030) {
        RCR1D_RC1D                     = (*RCR1D     )["RC1D"      ];
        return;
    }
    if ((0x0048 <= addr) && (addr <= (0x0048)+(32*3)) && ((addr-0x0048)%32 == 0)) {
        uint i = (addr - 0x0048)/32;
        OCR2D_OC2D                    [i] = (*(OCR2D     [i]))["OC2D"      ];
        return;
    }
    if (addr == 0x0034) {
        RCR2D_RC2D                     = (*RCR2D     )["RC2D"      ];
        return;
    }
    if ((0x0050 <= addr) && (addr <= (0x0050)+(32*3)) && ((addr-0x0050)%32 == 0)) {
        uint i = (addr - 0x0050)/32;
        ICR1D_ICR1D                   [i] = (*(ICR1D     [i]))["ICR1D"     ];
        return;
    }
    if ((0x0054 <= addr) && (addr <= (0x0054)+(32*3)) && ((addr-0x0054)%32 == 0)) {
        uint i = (addr - 0x0054)/32;
        ICR2D_ICR2D                   [i] = (*(ICR2D     [i]))["ICR2D"     ];
        return;
    }
    if ((0x0058 <= addr) && (addr <= (0x0058)+(32*3)) && ((addr-0x0058)%32 == 0)) {
        uint i = (addr - 0x0058)/32;
        DCNTD_CNTD                    [i] = (*(DCNTD     [i]))["CNTD"      ];
        return;
    }
    if (addr == 0x00C0) {
        TIER1D_OV2ED                   = (*TIER1D    )["OV2ED"     ];
        TIER1D_OV1ED                   = (*TIER1D    )["OV1ED"     ];
        return;
    }
    if (addr == 0x00C4) {
        TIER2D_UNDED3                  = (*TIER2D    )["UNDED3"    ];
        TIER2D_UNDED2                  = (*TIER2D    )["UNDED2"    ];
        TIER2D_UNDED1                  = (*TIER2D    )["UNDED1"    ];
        TIER2D_UNDED0                  = (*TIER2D    )["UNDED0"    ];
        TIER2D_CMPBED3                 = (*TIER2D    )["CMPBED3"   ];
        TIER2D_CMPBED2                 = (*TIER2D    )["CMPBED2"   ];
        TIER2D_CMPBED1                 = (*TIER2D    )["CMPBED1"   ];
        TIER2D_CMPBED0                 = (*TIER2D    )["CMPBED0"   ];
        TIER2D_CMPAED3                 = (*TIER2D    )["CMPAED3"   ];
        TIER2D_CMPAED2                 = (*TIER2D    )["CMPAED2"   ];
        TIER2D_CMPAED1                 = (*TIER2D    )["CMPAED1"   ];
        TIER2D_CMPAED0                 = (*TIER2D    )["CMPAED0"   ];
        return;
    }
    if (addr == 0x00C8) {
        TIER3D_FEIED3                  = (*TIER3D    )["FEIED3"    ];
        TIER3D_FEIED2                  = (*TIER3D    )["FEIED2"    ];
        TIER3D_FEIED1                  = (*TIER3D    )["FEIED1"    ];
        TIER3D_FEIED0                  = (*TIER3D    )["FEIED0"    ];
        TIER3D_REIED3                  = (*TIER3D    )["REIED3"    ];
        TIER3D_REIED2                  = (*TIER3D    )["REIED2"    ];
        TIER3D_REIED1                  = (*TIER3D    )["REIED1"    ];
        TIER3D_REIED0                  = (*TIER3D    )["REIED0"    ];
        return;
    }
    if ((0x0110 <= addr) && (addr <= (0x0110)+(64*3)) && ((addr-0x0110)%64 == 0)) {
        uint i = (addr - 0x0110)/64;
        OFMIND_OFMIND                 [i] = (*(OFMIND    [i]))["OFMIND"    ];
        return;
    }
    if ((0x0114 <= addr) && (addr <= (0x0114)+(64*3)) && ((addr-0x0114)%64 == 0)) {
        uint i = (addr - 0x0114)/64;
        ONMIND_ONMIND                 [i] = (*(ONMIND    [i]))["ONMIND"    ];
        return;
    }
    if ((0x0118 <= addr) && (addr <= (0x0118)+(64*3)) && ((addr-0x0118)%64 == 0)) {
        uint i = (addr - 0x0118)/64;
        OTOMIND_OTOMIND               [i] = (*(OTOMIND   [i]))["OTOMIND"   ];
        return;
    }
    if ((0x0100 <= addr) && (addr <= (0x0100)+(64*3)) && ((addr-0x0100)%64 == 0)) {
        uint i = (addr - 0x0100)/64;
        OFMICNTD_OFMICNTD             [i] = (*(OFMICNTD  [i]))["OFMICNTD"  ];
        return;
    }
    if ((0x0104 <= addr) && (addr <= (0x0104)+(64*3)) && ((addr-0x0104)%64 == 0)) {
        uint i = (addr - 0x0104)/64;
        ONMICNTD_ONMICNTD             [i] = (*(ONMICNTD  [i]))["ONMICNTD"  ];
        return;
    }
    if ((0x0108 <= addr) && (addr <= (0x0108)+(64*3)) && ((addr-0x0108)%64 == 0)) {
        uint i = (addr - 0x0108)/64;
        OTONMICNTD_OTONMICNTD         [i] = (*(OTONMICNTD[i]))["OTONMICNTD"];
        return;
    }
    if ((0x0120 <= addr) && (addr <= (0x0120)+(64*3)) && ((addr-0x0120)%64 == 0)) {
        uint i = (addr - 0x0120)/64;
        ONCAPD1_ONCAPD1               [i] = (*(ONCAPD1   [i]))["ONCAPD1"   ];
        return;
    }
    if ((0x0124 <= addr) && (addr <= (0x0124)+(64*3)) && ((addr-0x0124)%64 == 0)) {
        uint i = (addr - 0x0124)/64;
        ONCAPD2_ONCAPD2               [i] = (*(ONCAPD2   [i]))["ONCAPD2"   ];
        return;
    }
    if ((0x0130 <= addr) && (addr <= (0x0130)+(64*3)) && ((addr-0x0130)%64 == 0)) {
        uint i = (addr - 0x0130)/64;
        OFCAPD1_OFCAPD1               [i] = (*(OFCAPD1   [i]))["OFCAPD1"   ];
        return;
    }
    if ((0x0134 <= addr) && (addr <= (0x0134)+(64*3)) && ((addr-0x0134)%64 == 0)) {
        uint i = (addr - 0x0134)/64;
        OFCAPD2_OFCAPD2               [i] = (*(OFCAPD2   [i]))["OFCAPD2"   ];
        return;
    }
    if (addr == 0x00D0) {
        TSR2D_FEFD3                    = (*TSR2D     )["FEFD3"     ];
        TSR2D_FEFD2                    = (*TSR2D     )["FEFD2"     ];
        TSR2D_FEFD1                    = (*TSR2D     )["FEFD1"     ];
        TSR2D_FEFD0                    = (*TSR2D     )["FEFD0"     ];
        TSR2D_REFD3                    = (*TSR2D     )["REFD3"     ];
        TSR2D_REFD2                    = (*TSR2D     )["REFD2"     ];
        TSR2D_REFD1                    = (*TSR2D     )["REFD1"     ];
        TSR2D_REFD0                    = (*TSR2D     )["REFD0"     ];
        return;
    }
    if (addr == 0x00D4) {
        TSCR2D_FEFCD3                  = (*TSCR2D    )["FEFCD3"    ];
        TSCR2D_FEFCD2                  = (*TSCR2D    )["FEFCD2"    ];
        TSCR2D_FEFCD1                  = (*TSCR2D    )["FEFCD1"    ];
        TSCR2D_FEFCD0                  = (*TSCR2D    )["FEFCD0"    ];
        TSCR2D_REFCD3                  = (*TSCR2D    )["REFCD3"    ];
        TSCR2D_REFCD2                  = (*TSCR2D    )["REFCD2"    ];
        TSCR2D_REFCD1                  = (*TSCR2D    )["REFCD1"    ];
        TSCR2D_REFCD0                  = (*TSCR2D    )["REFCD0"    ];
        return;
    }
}

/// Update local value to bit value
/// @return None
void Catu5010_timerd_sub_regif::UpdateRegVal(cuint addr)
{
    if (addr == 0x0000) {
        (*TCRD      )["OBRED"     ] = TCRD_OBRED;
        (*TCRD      )["C2CED"     ] = TCRD_C2CED;
        (*TCRD      )["C1CED"     ] = TCRD_C1CED;
        (*TCRD      )["CLR2D"     ] = TCRD_CLR2D;
        (*TCRD      )["CKSEL2D"   ] = TCRD_CKSEL2D;
        (*TCRD      )["CLR1D"     ] = TCRD_CLR1D;
        (*TCRD      )["CKSEL1D"   ] = TCRD_CKSEL1D;
        (*TCRD      )["DCSELD"    ] = TCRD_DCSELD;
        return;
    }
    if (addr == 0x001C) {
        (*TCCRLRD   )["CLRSEL2D"  ] = TCCRLRD_CLRSEL2D;
        (*TCCRLRD   )["CLRSEL1D"  ] = TCCRLRD_CLRSEL1D;
        (*TCCRLRD   )["CMPSEL2D3" ] = TCCRLRD_CMPSEL2D3;
        (*TCCRLRD   )["CMPSEL2D2" ] = TCCRLRD_CMPSEL2D2;
        (*TCCRLRD   )["CMPSEL2D1" ] = TCCRLRD_CMPSEL2D1;
        (*TCCRLRD   )["CMPSEL2D0" ] = TCCRLRD_CMPSEL2D0;
        (*TCCRLRD   )["CMPSEL1D3" ] = TCCRLRD_CMPSEL1D3;
        (*TCCRLRD   )["CMPSEL1D2" ] = TCCRLRD_CMPSEL1D2;
        (*TCCRLRD   )["CMPSEL1D1" ] = TCCRLRD_CMPSEL1D1;
        (*TCCRLRD   )["CMPSEL1D0" ] = TCCRLRD_CMPSEL1D0;
        return;
    }
    if (addr == 0x0004) {
        (*TIOR1D    )["OSSD3"     ] = TIOR1D_OSSD3;
        (*TIOR1D    )["OSSD2"     ] = TIOR1D_OSSD2;
        (*TIOR1D    )["OSSD1"     ] = TIOR1D_OSSD1;
        (*TIOR1D    )["OSSD0"     ] = TIOR1D_OSSD0;
        (*TIOR1D    )["IOAD3"     ] = TIOR1D_IOAD3;
        (*TIOR1D    )["IOAD2"     ] = TIOR1D_IOAD2;
        (*TIOR1D    )["IOAD1"     ] = TIOR1D_IOAD1;
        (*TIOR1D    )["IOAD0"     ] = TIOR1D_IOAD0;
        return;
    }
    if (addr == 0x0006) {
        (*TIOR2D    )["IOBD3"     ] = TIOR2D_IOBD3;
        (*TIOR2D    )["IOBD2"     ] = TIOR2D_IOBD2;
        (*TIOR2D    )["IOBD1"     ] = TIOR2D_IOBD1;
        (*TIOR2D    )["IOBD0"     ] = TIOR2D_IOBD0;
        return;
    }
    if (addr == 0x003D) {
        (*TCMPED    )["CMPE2D3"   ] = TCMPED_CMPE2D3;
        (*TCMPED    )["CMPE2D2"   ] = TCMPED_CMPE2D2;
        (*TCMPED    )["CMPE2D1"   ] = TCMPED_CMPE2D1;
        (*TCMPED    )["CMPE2D0"   ] = TCMPED_CMPE2D0;
        (*TCMPED    )["CMPE1D3"   ] = TCMPED_CMPE1D3;
        (*TCMPED    )["CMPE1D2"   ] = TCMPED_CMPE1D2;
        (*TCMPED    )["CMPE1D1"   ] = TCMPED_CMPE1D1;
        (*TCMPED    )["CMPE1D0"   ] = TCMPED_CMPE1D0;
        return;
    }
    if (addr == 0x003E) {
        (*TIORD     )["IO2D3"     ] = TIORD_IO2D3;
        (*TIORD     )["IO2D2"     ] = TIORD_IO2D2;
        (*TIORD     )["IO2D1"     ] = TIORD_IO2D1;
        (*TIORD     )["IO2D0"     ] = TIORD_IO2D0;
        (*TIORD     )["IO1D3"     ] = TIORD_IO1D3;
        (*TIORD     )["IO1D2"     ] = TIORD_IO1D2;
        (*TIORD     )["IO1D1"     ] = TIORD_IO1D1;
        (*TIORD     )["IO1D0"     ] = TIORD_IO1D0;
        return;
    }
    if (addr == 0x0011) {
        (*OSELRD    )["OSELBD3"   ] = OSELRD_OSELBD3;
        (*OSELRD    )["OSELBD2"   ] = OSELRD_OSELBD2;
        (*OSELRD    )["OSELBD1"   ] = OSELRD_OSELBD1;
        (*OSELRD    )["OSELBD0"   ] = OSELRD_OSELBD0;
        (*OSELRD    )["OSELAD3"   ] = OSELRD_OSELAD3;
        (*OSELRD    )["OSELAD2"   ] = OSELRD_OSELAD2;
        (*OSELRD    )["OSELAD1"   ] = OSELRD_OSELAD1;
        (*OSELRD    )["OSELAD0"   ] = OSELRD_OSELAD0;
        return;
    }
    if (addr == 0x0012) {
        (*ODRD      )["ODBD3"     ] = ODRD_ODBD3;
        (*ODRD      )["ODBD2"     ] = ODRD_ODBD2;
        (*ODRD      )["ODBD1"     ] = ODRD_ODBD1;
        (*ODRD      )["ODBD0"     ] = ODRD_ODBD0;
        (*ODRD      )["ODAD3"     ] = ODRD_ODAD3;
        (*ODRD      )["ODAD2"     ] = ODRD_ODAD2;
        (*ODRD      )["ODAD1"     ] = ODRD_ODAD1;
        (*ODRD      )["ODAD0"     ] = ODRD_ODAD0;
        return;
    }
    if (addr == 0x0008) {
        (*DSTRD     )["DSTD3"     ] = DSTRD_DSTD3;
        (*DSTRD     )["DSTD2"     ] = DSTRD_DSTD2;
        (*DSTRD     )["DSTD1"     ] = DSTRD_DSTD1;
        (*DSTRD     )["DSTD0"     ] = DSTRD_DSTD0;
        return;
    }
    if (addr == 0x000A) {
        (*DSR1D     )["DWFD3"     ] = DSR1D_DWFD3;
        (*DSR1D     )["DWFD2"     ] = DSR1D_DWFD2;
        (*DSR1D     )["DWFD1"     ] = DSR1D_DWFD1;
        (*DSR1D     )["DWFD0"     ] = DSR1D_DWFD0;
        (*DSR1D     )["DSFD3"     ] = DSR1D_DSFD3;
        (*DSR1D     )["DSFD2"     ] = DSR1D_DSFD2;
        (*DSR1D     )["DSFD1"     ] = DSR1D_DSFD1;
        (*DSR1D     )["DSFD0"     ] = DSR1D_DSFD0;
        return;
    }
    if (addr == 0x000B) {
        (*DSR2D     )["DWRFD3"    ] = DSR2D_DWRFD3;
        (*DSR2D     )["DWRFD2"    ] = DSR2D_DWRFD2;
        (*DSR2D     )["DWRFD1"    ] = DSR2D_DWRFD1;
        (*DSR2D     )["DWRFD0"    ] = DSR2D_DWRFD0;
        return;
    }
    if (addr == 0x0009) {
        (*DSCRD     )["DWFCD3"    ] = DSCRD_DWFCD3;
        (*DSCRD     )["DWFCD2"    ] = DSCRD_DWFCD2;
        (*DSCRD     )["DWFCD1"    ] = DSCRD_DWFCD1;
        (*DSCRD     )["DWFCD0"    ] = DSCRD_DWFCD0;
        (*DSCRD     )["DWRFCD3"   ] = DSCRD_DWRFCD3;
        (*DSCRD     )["DWRFCD2"   ] = DSCRD_DWRFCD2;
        (*DSCRD     )["DWRFCD1"   ] = DSCRD_DWRFCD1;
        (*DSCRD     )["DWRFCD0"   ] = DSCRD_DWRFCD0;
        return;
    }
    if (addr == 0x0002) {
        (*DCRD      )["TRGSELD3"  ] = DCRD_TRGSELD3;
        (*DCRD      )["TRGSELD2"  ] = DCRD_TRGSELD2;
        (*DCRD      )["TRGSELD1"  ] = DCRD_TRGSELD1;
        (*DCRD      )["TRGSELD0"  ] = DCRD_TRGSELD0;
        return;
    }
    if (addr == 0x000C) {
        (*TSRD      )["OVF2D"     ] = TSRD_OVF2D;
        (*TSRD      )["OVF1D"     ] = TSRD_OVF1D;
        (*TSRD      )["UDFD3"     ] = TSRD_UDFD3;
        (*TSRD      )["UDFD2"     ] = TSRD_UDFD2;
        (*TSRD      )["UDFD1"     ] = TSRD_UDFD1;
        (*TSRD      )["UDFD0"     ] = TSRD_UDFD0;
        (*TSRD      )["CMFAD3"    ] = TSRD_CMFAD3;
        (*TSRD      )["CMFAD2"    ] = TSRD_CMFAD2;
        (*TSRD      )["CMFAD1"    ] = TSRD_CMFAD1;
        (*TSRD      )["CMFAD0"    ] = TSRD_CMFAD0;
        (*TSRD      )["CMFBD3"    ] = TSRD_CMFBD3;
        (*TSRD      )["CMFBD2"    ] = TSRD_CMFBD2;
        (*TSRD      )["CMFBD1"    ] = TSRD_CMFBD1;
        (*TSRD      )["CMFBD0"    ] = TSRD_CMFBD0;
        return;
    }
    if (addr == 0x000E) {
        (*TSCRD     )["OVFC2D"    ] = TSCRD_OVFC2D;
        (*TSCRD     )["OVFC1D"    ] = TSCRD_OVFC1D;
        (*TSCRD     )["UDFCD3"    ] = TSCRD_UDFCD3;
        (*TSCRD     )["UDFCD2"    ] = TSCRD_UDFCD2;
        (*TSCRD     )["UDFCD1"    ] = TSCRD_UDFCD1;
        (*TSCRD     )["UDFCD0"    ] = TSCRD_UDFCD0;
        (*TSCRD     )["CMFCAD3"   ] = TSCRD_CMFCAD3;
        (*TSCRD     )["CMFCAD2"   ] = TSCRD_CMFCAD2;
        (*TSCRD     )["CMFCAD1"   ] = TSCRD_CMFCAD1;
        (*TSCRD     )["CMFCAD0"   ] = TSCRD_CMFCAD0;
        (*TSCRD     )["CMFCBD3"   ] = TSCRD_CMFCBD3;
        (*TSCRD     )["CMFCBD2"   ] = TSCRD_CMFCBD2;
        (*TSCRD     )["CMFCBD1"   ] = TSCRD_CMFCBD1;
        (*TSCRD     )["CMFCBD0"   ] = TSCRD_CMFCBD0;
        return;
    }
    if (addr == 0x0010) {
        (*TOCRD     )["TONEBD"    ] = TOCRD_TONEBD;
        (*TOCRD     )["TONEAD"    ] = TOCRD_TONEAD;
        return;
    }
    if (addr == 0x003C) {
        (*TOCCRD    )["TONEBD3"   ] = TOCCRD_TONEBD3;
        (*TOCCRD    )["TONEBD2"   ] = TOCCRD_TONEBD2;
        (*TOCCRD    )["TONEBD1"   ] = TOCCRD_TONEBD1;
        (*TOCCRD    )["TONEBD0"   ] = TOCCRD_TONEBD0;
        (*TOCCRD    )["TONEAD3"   ] = TOCCRD_TONEAD3;
        (*TOCCRD    )["TONEAD2"   ] = TOCCRD_TONEAD2;
        (*TOCCRD    )["TONEAD1"   ] = TOCCRD_TONEAD1;
        (*TOCCRD    )["TONEAD0"   ] = TOCCRD_TONEAD0;
        return;
    }
    if (addr == 0x0018) {
        (*OSBRD     )["OSBRD"     ] = OSBRD_OSBRD;
        return;
    }
    if (addr == 0x0014) {
        (*TICTSELD  )["TIDSELD"   ] = TICTSELD_TIDSELD;
        return;
    }
    if (addr == 0x0016) {
        (*MIGCRD    )["MIGEND3"   ] = MIGCRD_MIGEND3;
        (*MIGCRD    )["MIGEND2"   ] = MIGCRD_MIGEND2;
        (*MIGCRD    )["MIGEND1"   ] = MIGCRD_MIGEND1;
        (*MIGCRD    )["MIGEND0"   ] = MIGCRD_MIGEND0;
        return;
    }
    if (addr == 0x0017) {
        (*MIGSELD   )["MIGSEL3"   ] = MIGSELD_MIGSEL3;
        (*MIGSELD   )["MIGSEL2"   ] = MIGSELD_MIGSEL2;
        (*MIGSELD   )["MIGSEL1"   ] = MIGSELD_MIGSEL1;
        (*MIGSELD   )["MIGSEL0"   ] = MIGSELD_MIGSEL0;
        return;
    }
    if (addr == 0x0020) {
        (*TCNT1D    )["TCNT1D"    ] = TCNT1D_TCNT1D;
        return;
    }
    if (addr == 0x0024) {
        (*TCNT2D    )["TCNT2D"    ] = TCNT2D_TCNT2D;
        return;
    }
    if (addr == 0x0028) {
        (*CUCR1D    )["CUCR1D"    ] = CUCR1D_CUCR1D;
        return;
    }
    if (addr == 0x002C) {
        (*CUCR2D    )["CUCR2D"    ] = CUCR2D_CUCR2D;
        return;
    }
    if ((0x0040 <= addr) && (addr <= (0x0040)+(32*3)) && ((addr-0x0040)%32 == 0)) {
        uint i = (addr - 0x0040)/32;
        (*(OCR1D     [i]))["OC1D"      ] = OCR1D_OC1D[i];
        return;
    }
    if (addr == 0x0030) {
        (*RCR1D     )["RC1D"      ] = RCR1D_RC1D;
        return;
    }
    if ((0x0048 <= addr) && (addr <= (0x0048)+(32*3)) && ((addr-0x0048)%32 == 0)) {
        uint i = (addr - 0x0048)/32;
        (*(OCR2D     [i]))["OC2D"      ] = OCR2D_OC2D[i];
        return;
    }
    if (addr == 0x0034) {
        (*RCR2D     )["RC2D"      ] = RCR2D_RC2D;
        return;
    }
    if ((0x0050 <= addr) && (addr <= (0x0050)+(32*3)) && ((addr-0x0050)%32 == 0)) {
        uint i = (addr - 0x0050)/32;
        (*(ICR1D     [i]))["ICR1D"     ] = ICR1D_ICR1D[i];
        return;
    }
    if ((0x0054 <= addr) && (addr <= (0x0054)+(32*3)) && ((addr-0x0054)%32 == 0)) {
        uint i = (addr - 0x0054)/32;
        (*(ICR2D     [i]))["ICR2D"     ] = ICR2D_ICR2D[i];
        return;
    }
    if ((0x0058 <= addr) && (addr <= (0x0058)+(32*3)) && ((addr-0x0058)%32 == 0)) {
        uint i = (addr - 0x0058)/32;
        (*(DCNTD     [i]))["CNTD"      ] = DCNTD_CNTD[i];
        return;
    }
    if (addr == 0x00C0) {
        (*TIER1D    )["OV2ED"     ] = TIER1D_OV2ED;
        (*TIER1D    )["OV1ED"     ] = TIER1D_OV1ED;
        return;
    }
    if (addr == 0x00C4) {
        (*TIER2D    )["UNDED3"    ] = TIER2D_UNDED3;
        (*TIER2D    )["UNDED2"    ] = TIER2D_UNDED2;
        (*TIER2D    )["UNDED1"    ] = TIER2D_UNDED1;
        (*TIER2D    )["UNDED0"    ] = TIER2D_UNDED0;
        (*TIER2D    )["CMPBED3"   ] = TIER2D_CMPBED3;
        (*TIER2D    )["CMPBED2"   ] = TIER2D_CMPBED2;
        (*TIER2D    )["CMPBED1"   ] = TIER2D_CMPBED1;
        (*TIER2D    )["CMPBED0"   ] = TIER2D_CMPBED0;
        (*TIER2D    )["CMPAED3"   ] = TIER2D_CMPAED3;
        (*TIER2D    )["CMPAED2"   ] = TIER2D_CMPAED2;
        (*TIER2D    )["CMPAED1"   ] = TIER2D_CMPAED1;
        (*TIER2D    )["CMPAED0"   ] = TIER2D_CMPAED0;
        return;
    }
    if (addr == 0x00C8) {
        (*TIER3D    )["FEIED3"    ] = TIER3D_FEIED3;
        (*TIER3D    )["FEIED2"    ] = TIER3D_FEIED2;
        (*TIER3D    )["FEIED1"    ] = TIER3D_FEIED1;
        (*TIER3D    )["FEIED0"    ] = TIER3D_FEIED0;
        (*TIER3D    )["REIED3"    ] = TIER3D_REIED3;
        (*TIER3D    )["REIED2"    ] = TIER3D_REIED2;
        (*TIER3D    )["REIED1"    ] = TIER3D_REIED1;
        (*TIER3D    )["REIED0"    ] = TIER3D_REIED0;
        return;
    }
    if ((0x0110 <= addr) && (addr <= (0x0110)+(64*3)) && ((addr-0x0110)%64 == 0)) {
        uint i = (addr - 0x0110)/64;
        (*(OFMIND    [i]))["OFMIND"    ] = OFMIND_OFMIND[i];
        return;
    }
    if ((0x0114 <= addr) && (addr <= (0x0114)+(64*3)) && ((addr-0x0114)%64 == 0)) {
        uint i = (addr - 0x0114)/64;
        (*(ONMIND    [i]))["ONMIND"    ] = ONMIND_ONMIND[i];
        return;
    }
    if ((0x0118 <= addr) && (addr <= (0x0118)+(64*3)) && ((addr-0x0118)%64 == 0)) {
        uint i = (addr - 0x0118)/64;
        (*(OTOMIND   [i]))["OTOMIND"   ] = OTOMIND_OTOMIND[i];
        return;
    }
    if ((0x0100 <= addr) && (addr <= (0x0100)+(64*3)) && ((addr-0x0100)%64 == 0)) {
        uint i = (addr - 0x0100)/64;
        (*(OFMICNTD  [i]))["OFMICNTD"  ] = OFMICNTD_OFMICNTD[i];
        return;
    }
    if ((0x0104 <= addr) && (addr <= (0x0104)+(64*3)) && ((addr-0x0104)%64 == 0)) {
        uint i = (addr - 0x0104)/64;
        (*(ONMICNTD  [i]))["ONMICNTD"  ] = ONMICNTD_ONMICNTD[i];
        return;
    }
    if ((0x0108 <= addr) && (addr <= (0x0108)+(64*3)) && ((addr-0x0108)%64 == 0)) {
        uint i = (addr - 0x0108)/64;
        (*(OTONMICNTD[i]))["OTONMICNTD"] = OTONMICNTD_OTONMICNTD[i];
        return;
    }
    if ((0x0120 <= addr) && (addr <= (0x0120)+(64*3)) && ((addr-0x0120)%64 == 0)) {
        uint i = (addr - 0x0120)/64;
        (*(ONCAPD1   [i]))["ONCAPD1"   ] = ONCAPD1_ONCAPD1[i];
        return;
    }
    if ((0x0124 <= addr) && (addr <= (0x0124)+(64*3)) && ((addr-0x0124)%64 == 0)) {
        uint i = (addr - 0x0124)/64;
        (*(ONCAPD2   [i]))["ONCAPD2"   ] = ONCAPD2_ONCAPD2[i];
        return;
    }
    if ((0x0130 <= addr) && (addr <= (0x0130)+(64*3)) && ((addr-0x0130)%64 == 0)) {
        uint i = (addr - 0x0130)/64;
        (*(OFCAPD1   [i]))["OFCAPD1"   ] = OFCAPD1_OFCAPD1[i];
        return;
    }
    if ((0x0134 <= addr) && (addr <= (0x0134)+(64*3)) && ((addr-0x0134)%64 == 0)) {
        uint i = (addr - 0x0134)/64;
        (*(OFCAPD2   [i]))["OFCAPD2"   ] = OFCAPD2_OFCAPD2[i];
        return;
    }
    if (addr == 0x00D0) {
        (*TSR2D     )["FEFD3"     ] = TSR2D_FEFD3;
        (*TSR2D     )["FEFD2"     ] = TSR2D_FEFD2;
        (*TSR2D     )["FEFD1"     ] = TSR2D_FEFD1;
        (*TSR2D     )["FEFD0"     ] = TSR2D_FEFD0;
        (*TSR2D     )["REFD3"     ] = TSR2D_REFD3;
        (*TSR2D     )["REFD2"     ] = TSR2D_REFD2;
        (*TSR2D     )["REFD1"     ] = TSR2D_REFD1;
        (*TSR2D     )["REFD0"     ] = TSR2D_REFD0;
        return;
    }
    if (addr == 0x00D4) {
        (*TSCR2D    )["FEFCD3"    ] = TSCR2D_FEFCD3;
        (*TSCR2D    )["FEFCD2"    ] = TSCR2D_FEFCD2;
        (*TSCR2D    )["FEFCD1"    ] = TSCR2D_FEFCD1;
        (*TSCR2D    )["FEFCD0"    ] = TSCR2D_FEFCD0;
        (*TSCR2D    )["REFCD3"    ] = TSCR2D_REFCD3;
        (*TSCR2D    )["REFCD2"    ] = TSCR2D_REFCD2;
        (*TSCR2D    )["REFCD1"    ] = TSCR2D_REFCD1;
        (*TSCR2D    )["REFCD0"    ] = TSCR2D_REFCD0;
        return;
    }
}

/// convert string to vector
/// @return vector
std::vector<std::string> Catu5010_timerd_sub_regif::Str2Vec(std::string str, const char sep)
{
    std::vector<std::string> buf;
    std::string::size_type index = 0;
    for (uint i=0 ; i<str.size() ; i++) {
        if (str[i] == sep) {
            buf.push_back(str.substr(index, i-index));
            index = i+1;
        }
    }
    buf.push_back(str.substr(index));
    return buf;
}

/// Align nuber to hexadecimal format
/// @return aligned number
std::string Catu5010_timerd_sub_regif::Num2HexStr(cuint num, cuint num_length, bool space_strip)
{
    std::ostringstream str_tmp;
    #ifdef MSG_WO_WR_DATA
    str_tmp<<"0x"<<std::hex<<std::uppercase<<std::right<<num;
    str_tmp<<std::setfill(' ')<<std::setw(10-str_tmp.str().length())<<"";
    #else
    uint total_length = (num_length + 3)/4; // Calculate number of hexadecimal number
    str_tmp<<"0x"<<std::setfill('0')<<std::setw(total_length)<<std::hex<<std::uppercase<<std::right<<num;
    if (!space_strip) {
        str_tmp<<std::setfill(' ')<<std::setw(10-str_tmp.str().length())<<"";   
    }
    #endif
    return str_tmp.str();
}

/// Dump register access information
/// @return none
void Catu5010_timerd_sub_regif::DumpRegMsg(const std::string operation, const std::string RegName, const std::string BitName, cuint size, cuint addr, cuint wr_data, cuint pre_data, cuint data, cuint reg_length)
{
    if(mDumpRegisterRW == true) {
        std::string reg_name = RegName;
        std::ostringstream str_tmp;
        if (BitName != "") {
            reg_name += ":" + BitName;
        }
        str_tmp<<"REG ["<<std::setw(15)<<std::left<<reg_name<<"] ";
        str_tmp<<operation;
        str_tmp<<" Size= "<<size;
        str_tmp<<" Addr= "<<Num2HexStr(addr,9, false);
        if (operation == "R") {
            str_tmp<<" Data= "<<Num2HexStr(data    , reg_length, true);
        } else {
            #ifdef MSG_WO_WR_DATA
            str_tmp<<" Data= "<<Num2HexStr(pre_data, reg_length, false);
            #else
            str_tmp<<" Data= "<<Num2HexStr(wr_data , reg_length, false);
            str_tmp<<" : "    <<Num2HexStr(pre_data, reg_length, false);
            #endif
            str_tmp<<" => "   <<Num2HexStr(data    , reg_length, true);
        }
        re_printf("DumpRegMsg", "%s\n", str_tmp.str().c_str());
    }
}

/// find register pointer based on accessed address
/// @return accessed register pointer
int Catu5010_timerd_sub_regif::get_reg_index(cuint access_addr)
{
    if (mRegMap[access_addr] != (1<<9)) {
        return mRegMap[access_addr];
    } else {
        return -1;
    }
}

/// find first register pointer
/// @return first register pointer
vpcl::re_register *Catu5010_timerd_sub_regif::first_reg_object()
{
    mCurReg = mRegList;
    return mCurReg->my_p;
}

/// find next register pointer
/// @return next register pointer
vpcl::re_register *Catu5010_timerd_sub_regif::next_reg_object()
{
    if (mCurReg != NULL) {
        mCurReg = mCurReg->prev;
        if (mCurReg != NULL) {
            return mCurReg->my_p;
        }
    }
    return NULL;
}

/// write callback function of CoWare
/// @return none
void Catu5010_timerd_sub_regif::wr_cb(cuint addr, uint data)
{
    #ifdef CWR_SYSTEMC
    cwmem.put(data, addr&0xFFFF);
    #else
    array[addr&0xFFFF] = data;
    #endif
}

/// read callback function of CoWare
/// @return read data
Catu5010_timerd_sub_regif::uint Catu5010_timerd_sub_regif::rd_cb(cuint addr)
{
    #ifdef CWR_SYSTEMC
    return cwmem.get(addr&0xFFFF);
    #else
    return array[addr&0xFFFF];
    #endif
}

/// print message function
/// @return none
void Catu5010_timerd_sub_regif::_re_printf(std::string group, const char *message, ...)
{
    // message group check
    if (group == "DumpRegMsg") {
        group = "info";
    } else {
        #ifndef REGIF_SC_REPORT
        if (mMessageLevel[group] == false) return;
        #endif//REGIF_SC_REPORT
    }

    if (message == NULL) return;

    // print header
    #ifndef REGIF_NOT_USE_SYSTEMC
    std::stringstream t_stream;
    std::string cur_time;

    double tu_value = 0;
    std::string tu_name = "";
    if (sc_get_time_resolution() < sc_time(1, SC_PS)) {
        tu_value = 1000000000000000LL;
        tu_name = " fs";
    }
    else if (sc_get_time_resolution() < sc_time(1, SC_NS)) {
        tu_value = 1000000000000LL;
        tu_name = " ps";
    }
    else if (sc_get_time_resolution() < sc_time(1, SC_US)) {
        tu_value = 1000000000;
        tu_name = " ns";
    }
    else if (sc_get_time_resolution() < sc_time(1, SC_MS)) {
        tu_value = 1000000;
        tu_name = " us";
    }
    else if (sc_get_time_resolution() < sc_time(1, SC_SEC)) {
        tu_value = 1000;
        tu_name = " ms";
    }
    else {
        tu_value = 1;
        tu_name = " s";
    }
    t_stream << sc_time_stamp().value() * (uint64) (sc_get_time_resolution().to_seconds() * tu_value) << tu_name;

    cur_time = t_stream.str();
    #else
    std::string cur_time = "";
    #endif

    #ifndef REGIF_SC_REPORT
    #ifdef MSG_COLOR
    // color setting
    //
    // severity color       color Linux       Windows
    // fatal    RED         RED   \033[0;31m  FOREGROUND_RED
    // error    RED         BLUE  \033[0;34m  FOREGROUND_BLUE
    // warning  RED
    // info     BLUE
    #ifdef _WIN32
    HANDLE hStdout;
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    if (group == "fatal" || group == "error" || group == "warning") {
        SetConsoleTextAttribute(hStdout, FOREGROUND_RED);
    }
    else if (group == "info" ){
        SetConsoleTextAttribute(hStdout, FOREGROUND_BLUE);
    }
    #else
    if (group == "fatal" || group == "error" || group == "warning") {
        printf("\033[0;31m");
    }
    else if (group == "info" ){
        printf("\033[0;34m");
    }
    #endif
    #endif //MSG_COLOR
    printf("%8s [%20s] (%10s) ", group.c_str(), cur_time.c_str(), mInstName.c_str());
    #endif//REGIF_SC_REPORT

    // print body
    va_list argptr;
    va_start(argptr, message);
    if (argptr == NULL) return;
    #ifdef REGIF_SC_REPORT
    char str[1024];
    sprintf(str, "[%20s] ", cur_time.c_str());
    vsprintf(str+23, message, argptr);
    if (group == "fatal") {
        SC_REPORT_FATAL(mInstName.c_str(), str);
    }
    else if (group == "error") {
        SC_REPORT_ERROR(mInstName.c_str(), str);
    }
    else if (group == "warning") {
        SC_REPORT_WARNING(mInstName.c_str(), str);
    }
    else if (group == "info") {
        SC_REPORT_INFO(mInstName.c_str(), str);
    }
    #else //REGIF_SC_REPORT
    vprintf(message, argptr);
    #endif//REGIF_SC_REPORT

    #ifndef REGIF_SC_REPORT
    #ifdef DumpFileNameLineNum
    // print footer
    if (group == "fatal" || group == "error") {
        printf(" [%s:%d]\n", mFileName.c_str(), mLineNum);
    }
    #endif//DumpFileNameLineNum
    #endif//REGIF_SC_REPORT
    va_end(argptr);

    #ifndef REGIF_SC_REPORT
    #ifdef MSG_COLOR
    #ifdef _WIN32
    SetConsoleTextAttribute(hStdout, csbi.wAttributes);
    #else
    printf("\033[m");
    #endif
    #endif //MSG_COLOR
    #endif//REGIF_SC_REPORT

    fflush(stdout);
    fflush(stderr);

    if (group == "fatal") {
        exit(1);
    }
}

/// Get file name and line number
/// @return none
void Catu5010_timerd_sub_regif::get_fileline(std::string filename, int line_number)
{
    mFileName = filename;
    mLineNum  = line_number;
}

/// API for instance registration
/// @return none
void Catu5010_timerd_sub_regif::set_instance_name(std::string InstName)
{
    mInstName = InstName;
}

/// Method to change value of mIsReset
/// @return none
void Catu5010_timerd_sub_regif::EnableReset(const bool is_active)
{
    // update register IF class's reset status
    mIsReset = is_active;

    // update re_register's reset status
    for (uint i = 0; i < mTotalRegNum; i++) {
        mRegArray[i]->my_p->EnableReset(is_active);
        if (is_active) {
            re_printf("info", "Initialize %s (%08x)\n", mRegArray[i]->my_p->name().c_str(), (uint)(*mRegArray[i]->my_p));
        }
    }

    if(is_active) {
        InitLocalVal(); // Initialize local variable
    }
}

#ifdef CWR_SYSTEMC
uint Catu5010_timerd_sub_regif::cw_rd_cb(tlm::tlm_generic_payload& trans, int tag)
{
    unsigned char* ptr = (unsigned char*)trans.get_data_ptr();
    memset(ptr,0,sizeof(uint));
    reg_rd_dbg((cuint)tag, ptr, sizeof(uint));
    return sizeof(uint);
}

uint Catu5010_timerd_sub_regif::cw_wr_cb(tlm::tlm_generic_payload& trans, int tag)
{
    unsigned char* ptr = (unsigned char*)trans.get_data_ptr();
    reg_wr_dbg((cuint)tag, ptr, sizeof(uint));
    return sizeof(uint);
}
void Catu5010_timerd_sub_regif::cw_instantiate_reg(scml2::reg<uint> * reg, std::string reg_name, int offset)
{
    reg = new scml2::reg<uint>(reg_name, cwmem, offset/sizeof(uint));
    scml2::set_debug_write_callback(*reg,SCML2_CALLBACK(cw_wr_cb),offset);
    scml2::set_debug_read_callback(*reg,SCML2_CALLBACK(cw_rd_cb),offset);
}
#endif
