// $Id$
// -----------------------------------------------------------------------------
// Copyright(c) 2014 Renesas Design Vietnam Co., Ltd.
// Copyright(c) 2014 Renesas Electronics Corporation
// RENESAS ELECTRONICS CONFIDENTIAL AND PROPRIETARY.
// This program must be used solely for the purpose for which
// it was furnished by Renesas Electronics Corporation. No part of this
// program may be reproduced or disclosed to others, in any
// form, without the prior written permission of Renesas Electronics
// Corporation.
// -----------------------------------------------------------------------------
// This file is generated by FSM generator version 1.0
// Input file : sarad113x_fsm.csv
//              sarad113x_tha_fsm.csv
//              sarad113x_thb_fsm.csv
////////////////////////////////////////////////////////////////////////////////

#include "sarad113x_fsm.h"
#include "sarad113x.h"

Csarad113x_fsm::Csarad113x_fsm(Csarad113x *_parent, std::string upper_state)
    :Cfsm_base(_parent, upper_state, emStNA, emEvtWOE+1)
{
    mStateNameStr[emStRESET                  ] = mStateNamePrefix + "RESET";
    mStateNameStr[emStIDLE                   ] = mStateNamePrefix + "IDLE";
    mStateNameStr[emStHALT                   ] = mStateNamePrefix + "HALT";
    mStateNameStr[emStTH_CONV                ] = mStateNamePrefix + "TH_CONV";
    mStateNameStr[emStTH_SUSPEND             ] = mStateNamePrefix + "TH_SUSPEND";
    mStateNameStr[emStNORMAL_SG_SCANNING     ] = mStateNamePrefix + "NORMAL_SG_SCANNING";
    mStateNameStr[emStNORMAL_SG_SCANNING_END ] = mStateNamePrefix + "NORMAL_SG_SCANNING_END";
    mStateNameStr[emStNORMAL_VC_CONV         ] = mStateNamePrefix + "NORMAL_VC_CONV";
    mStateNameStr[emStNORMAL_VC_CONV_END     ] = mStateNamePrefix + "NORMAL_VC_CONV_END";
    mStateNameStr[emStNORMAL_SUSPEND         ] = mStateNamePrefix + "NORMAL_SUSPEND";
    
    mCurrentState = emStIDLE; // Initial state

    pCsarad113x_tha_conv_fsm = new Csarad113x_tha_conv_fsm(mParent, mStateNameStr[emStTH_CONV                ]);
    pCsarad113x_thb_conv_fsm = new Csarad113x_thb_conv_fsm(mParent, mStateNameStr[emStTH_CONV                ]);

    // State transition table construction
    mNextStateList[emStRESET                  ][emEvtResetDeassert        ] = emStIDLE;
    
    mNextStateList[emStIDLE                   ][emEvtResetAssert          ] = emStRESET;
    mNextStateList[emStIDLE                   ][emEvtStartSG4Trigger      ] = emStNORMAL_SG_SCANNING;
    mNextStateList[emStIDLE                   ][emEvtStartSG3Trigger      ] = emStNA + 1;
    mNextStateList[emStIDLE                   ][emEvtStartSG2Trigger      ] = emStNA + 2;
    mNextStateList[emStIDLE                   ][emEvtStartSG1Trigger      ] = emStNA + 3;
    mNextStateList[emStIDLE                   ][emEvtStartSG0Trigger      ] = emStNORMAL_SG_SCANNING;
    mNextStateList[emStIDLE                   ][emEvtTHStartSampling      ] = emStNA + 4;
    mNextStateList[emStIDLE                   ][emEvtHaltTrigger          ] = emStHALT;
    
    mNextStateList[emStHALT                   ][emEvtWOE                  ] = emStIDLE;
    
    mNextStateList[emStTH_CONV                ][emEvtResetAssert          ] = emStRESET;
    mNextStateList[emStTH_CONV                ][emEvtStartSG4Trigger      ] = emStNA + 5;
    mNextStateList[emStTH_CONV                ][emEvtStartSG3Trigger      ] = emStNA + 6;
    mNextStateList[emStTH_CONV                ][emEvtStartSG2Trigger      ] = emStNA + 7;
    mNextStateList[emStTH_CONV                ][emEvtStartSG1Trigger      ] = emStNA + 8;
    mNextStateList[emStTH_CONV                ][emEvtFinishTHConversion   ] = emStIDLE;
    mNextStateList[emStTH_CONV                ][emEvtHaltTrigger          ] = emStHALT;
    
    mNextStateList[emStTH_SUSPEND             ][emEvtWOE                  ] = emStIDLE;
    
    mNextStateList[emStNORMAL_SG_SCANNING     ][emEvtWOE                  ] = emStNA + 9;
    
    mNextStateList[emStNORMAL_SG_SCANNING_END ][emEvtWOE                  ] = emStIDLE;
    
    mNextStateList[emStNORMAL_VC_CONV         ][emEvtResetAssert          ] = emStRESET;
    mNextStateList[emStNORMAL_VC_CONV         ][emEvtStartSG4Trigger      ] = emStNA + 10;
    mNextStateList[emStNORMAL_VC_CONV         ][emEvtStartSG3Trigger      ] = emStNA + 11;
    mNextStateList[emStNORMAL_VC_CONV         ][emEvtStartSG2Trigger      ] = emStNA + 12;
    mNextStateList[emStNORMAL_VC_CONV         ][emEvtStartSG1Trigger      ] = emStNA + 13;
    mNextStateList[emStNORMAL_VC_CONV         ][emEvtFinishVCConversion   ] = emStNORMAL_VC_CONV_END;
    mNextStateList[emStNORMAL_VC_CONV         ][emEvtHaltTrigger          ] = emStHALT;
    
    mNextStateList[emStNORMAL_VC_CONV_END     ][emEvtWOE                  ] = emStNA + 14;
    
    mNextStateList[emStNORMAL_SUSPEND         ][emEvtWOE                  ] = emStIDLE;
    
    // Event function pointer table construction
    SEventFunctionCallInfo event_table_tmp[emTotalNumOfEvent] = {
        { this , emEvtResetAssert},
        { this , emEvtResetDeassert},
        { this , emEvtStartSG4Trigger},
        { this , emEvtStartSG3Trigger},
        { this , emEvtStartSG2Trigger},
        { this , emEvtStartSG1Trigger},
        { this , emEvtStartSG0Trigger},
        { this , emEvtTHStartSampling},
        { this , emEvtFinishVCConversion},
        { this , emEvtFinishTHConversion},
        { this , emEvtHaltTrigger},
        { this , emEvtWOE},
        // Csarad113x_tha_conv_fsm
        {pCsarad113x_tha_conv_fsm, (unsigned int) Csarad113x_tha_conv_fsm::emEvtTHAHWTrigger},
        {pCsarad113x_tha_conv_fsm, (unsigned int) Csarad113x_tha_conv_fsm::emEvtTHASWTrigger},
        {pCsarad113x_tha_conv_fsm, (unsigned int) Csarad113x_tha_conv_fsm::emEvtTHAStartSampling},
        {pCsarad113x_tha_conv_fsm, (unsigned int) Csarad113x_tha_conv_fsm::emEvtTHAHoldStart},
        {pCsarad113x_tha_conv_fsm, (unsigned int) Csarad113x_tha_conv_fsm::emEvtTHAHoldComplete},
        {pCsarad113x_tha_conv_fsm, (unsigned int) Csarad113x_tha_conv_fsm::emEvtTHAEndHolding},
        {pCsarad113x_tha_conv_fsm, (unsigned int) Csarad113x_tha_conv_fsm::emEvtTHAFinishVCConversion},
        {pCsarad113x_tha_conv_fsm, (unsigned int) Csarad113x_tha_conv_fsm::emEvtTHASuspend},
        {pCsarad113x_tha_conv_fsm, (unsigned int) Csarad113x_tha_conv_fsm::emEvtTHAResume},
        // Csarad113x_thb_conv_fsm
        {pCsarad113x_thb_conv_fsm, (unsigned int) Csarad113x_thb_conv_fsm::emEvtTHBHWTrigger},
        {pCsarad113x_thb_conv_fsm, (unsigned int) Csarad113x_thb_conv_fsm::emEvtTHBSWTrigger},
        {pCsarad113x_thb_conv_fsm, (unsigned int) Csarad113x_thb_conv_fsm::emEvtTHBStartSampling},
        {pCsarad113x_thb_conv_fsm, (unsigned int) Csarad113x_thb_conv_fsm::emEvtTHBHoldStart},
        {pCsarad113x_thb_conv_fsm, (unsigned int) Csarad113x_thb_conv_fsm::emEvtTHBHoldComplete},
        {pCsarad113x_thb_conv_fsm, (unsigned int) Csarad113x_thb_conv_fsm::emEvtTHBEndHolding},
        {pCsarad113x_thb_conv_fsm, (unsigned int) Csarad113x_thb_conv_fsm::emEvtTHBFinishVCConversion},
        {pCsarad113x_thb_conv_fsm, (unsigned int) Csarad113x_thb_conv_fsm::emEvtTHBSuspend},
        {pCsarad113x_thb_conv_fsm, (unsigned int) Csarad113x_thb_conv_fsm::emEvtTHBResume}
    };
    for (unsigned int i=0; i<emTotalNumOfEvent; i++) {
        mEventFuncTable[i] = event_table_tmp[i];
    }
}

Csarad113x_fsm::~Csarad113x_fsm(void)
{
    delete pCsarad113x_tha_conv_fsm;
    delete pCsarad113x_thb_conv_fsm;
}


void Csarad113x_fsm::Event(unsigned int event)
{
    sc_assert(event != emEvtWOE);

    if (event == emEvtResetDeassert) {
        sc_assert(mCurrentState != emStIDLE);
        sc_assert(mCurrentState != emStTH_CONV);
        sc_assert(mCurrentState != emStNORMAL_VC_CONV);
    }

    if (mEventFuncTable[event].pFSMObject == this) {
        bool state_next = StateTransition(event);
        while (state_next) state_next = StateTransition(emEvtWOE);
    } else {
        // call Event() of sub-FSM
        ((mEventFuncTable[event].pFSMObject)->*pEventFunc)(mEventFuncTable[event].event_index);
    }
}

void Csarad113x_fsm::CheckCondition(const unsigned int condition_id)
{
    sc_assert(condition_id < 14);
    switch (condition_id) {
        case 0:
            if (mParent->CheckTH(3)) {
                mNextState = emStTH_CONV;
            }
            else {
                mNextState = emStNORMAL_SG_SCANNING;
            }
            break;
        case 1:
            if (mParent->CheckTH(2)) {
                mNextState = emStTH_CONV;
            }
            else {
                mNextState = emStNORMAL_SG_SCANNING;
            }
            break;
        case 2:
            if (mParent->CheckTH(1)) {
                mNextState = emStTH_CONV;
            }
            else {
                mNextState = emStNORMAL_SG_SCANNING;
            }
            break;
        case 3:
            if (mParent->CheckEnableTH(Csarad113x::emTHGroupA)||mParent->CheckEnableTH(Csarad113x::emTHGroupB)) {
                mNextState = emStTH_CONV;
            }
            break;
        case 4:
            if (mParent->CheckSuspend(4,mParent->mCurrentSG)) {
                mNextState = emStTH_SUSPEND;
            }
            break;
        case 5:
            if (mParent->CheckSuspend(3,mParent->mCurrentSG)) {
                mNextState = emStTH_SUSPEND;
            }
            break;
        case 6:
            if (mParent->CheckSuspend(2,mParent->mCurrentSG)) {
                mNextState = emStTH_SUSPEND;
            }
            break;
        case 7:
            if (mParent->CheckSuspend(1,mParent->mCurrentSG)) {
                mNextState = emStTH_SUSPEND;
            }
            break;
        case 8:
            if (mParent->CheckEnableStart(mParent->mCurrentSG)) {
                mNextState = emStNORMAL_VC_CONV;
            }
            else {
                mNextState = emStIDLE;
            }
            break;
        case 9:
            if (mParent->CheckSuspend(4,mParent->mCurrentSG)) {
                mNextState = emStNORMAL_SUSPEND;
            }
            break;
        case 10:
            if (mParent->CheckSuspend(3,mParent->mCurrentSG)) {
                mNextState = emStNORMAL_SUSPEND;
            }
            break;
        case 11:
            if (mParent->CheckSuspend(2,mParent->mCurrentSG)) {
                mNextState = emStNORMAL_SUSPEND;
            }
            break;
        case 12:
            if (mParent->CheckSuspend(1,mParent->mCurrentSG)) {
                mNextState = emStNORMAL_SUSPEND;
            }
            break;
        case 13:
            if (mParent->IsLastVC(mParent->mCurrentSG) == Csarad113x::emSuspend) {
                mNextState = emStNORMAL_SUSPEND;
            }
            else if (mParent->IsLastVC(mParent->mCurrentSG) == Csarad113x::emLastVC) {
                mNextState = emStNORMAL_SG_SCANNING_END;
            }
            else {
                mNextState = emStNORMAL_VC_CONV;
            }
            break;
        default:
            break;
    }
}

void Csarad113x_fsm::fnEntry(void)
{
    mCurrentState = mNextState;
    switch (mCurrentState) {
        case emStRESET:
            pCsarad113x_tha_conv_fsm->End();
            pCsarad113x_thb_conv_fsm->End();
            break;
        case emStIDLE:
            mParent->CheckTrigger();
            break;
        case emStHALT:
            pCsarad113x_tha_conv_fsm->End();
            pCsarad113x_thb_conv_fsm->End();
            break;
        case emStTH_SUSPEND:
            mParent->SuspendScanning(mParent->mCurrentSG,true);
            break;
        case emStNORMAL_SG_SCANNING:
            mParent->SetCurrentSG(0,false);
            mParent->StartScanning(mParent->mCurrentSG,false);
            break;
        case emStNORMAL_SG_SCANNING_END:
            mParent->FinishScanning(mParent->mCurrentSG);
            break;
        case emStNORMAL_VC_CONV:
            mParent->StartVCConv(mParent->mCurrentSG);
            break;
        case emStNORMAL_VC_CONV_END:
            mParent->FinishVCConv(mParent->mCurrentSG);
            break;
        case emStNORMAL_SUSPEND:
            mParent->SuspendScanning(mParent->mCurrentSG,false);
            break;
        default:
            break;
    }
    mNextState = emStNA;
}

void Csarad113x_fsm::fnExit(void)
{
    mPreState = mCurrentState;
    switch (mCurrentState) {
        case emStNORMAL_VC_CONV_END:
            mParent->DumpActivity(mParent->mCurrentSG,mParent->mCurrentStartVC[mParent->mCurrentSG],mParent->mStartTimeVC);
            mParent->UpdateInternalCount(mParent->mCurrentSG);
            break;
        default:
            break;
    }
    mCurrentState = emStNA;
}

void Csarad113x_fsm::fnDo(void)
{
}

void Csarad113x_fsm::DumpStateTransInfo(void)
{
    if (mDumpStateTransInfo) {
        mParent->_re_printf("info", "State changes from %s to %s\n", mStateNameStr[mCurrentState].c_str(), mStateNameStr[mNextState].c_str());
    }
}

void Csarad113x_fsm::EnableDumpStateTrans(bool enable)
{
    mDumpStateTransInfo = enable;
    pCsarad113x_tha_conv_fsm->EnableDumpStateTrans(enable);
    pCsarad113x_thb_conv_fsm->EnableDumpStateTrans(enable);
}

