// $Id$
// -----------------------------------------------------------------------------
// Copyright(c) 2014 Renesas Design Vietnam Co., Ltd.
// Copyright(c) 2014 Renesas Electronics Corporation
// RENESAS ELECTRONICS CONFIDENTIAL AND PROPRIETARY.
// This program must be used solely for the purpose for which
// it was furnished by Renesas Electronics Corporation. No part of this
// program may be reproduced or disclosed to others, in any
// form, without the prior written permission of Renesas Electronics
// Corporation.
// -----------------------------------------------------------------------------
// This file is generated by FSM generator version 1.0
// Input file : sarad113x_fsm.csv
//              sarad113x_tha_fsm.csv
//              sarad113x_thb_fsm.csv
////////////////////////////////////////////////////////////////////////////////

#ifndef __SARAD113x_FSM_H__
#define __SARAD113x_FSM_H__
#include "systemc.h"
#include <string>

class Csarad113x;
class Csarad113x_tha_conv_fsm;
class Csarad113x_thb_conv_fsm;

/// FSM base class
class Cfsm_base
{
public:
    Cfsm_base(Csarad113x *_parent, std::string upper_state, unsigned int num_of_state, unsigned int num_of_event)
    {
        mNumOfEvent = num_of_event;
        mNumOfState = num_of_state;

        mStateNamePrefix = "";
        if (upper_state != "") {
            mStateNamePrefix = upper_state + ".";
        }
        mStateNameStr = new std::string[mNumOfState];

        sc_assert (_parent != NULL);
        this->mParent = _parent;
        mPreState  = mNumOfState; 
        mNextState = mNumOfState; 
        mDumpStateTransInfo = false;
        pEventFunc = &Cfsm_base::Event;

        // State transition table construction
        mNextStateList = new unsigned int* [mNumOfState];
        for (unsigned int i = 0; i < mNumOfState; i++) {
            mNextStateList[i] = new unsigned int [mNumOfEvent];
            for (unsigned int j = 0; j < mNumOfEvent; j++) {
                mNextStateList[i][j] = mNumOfState;
            }
        }

    }

    virtual ~Cfsm_base(void)
    {
        for (unsigned int i = 0; i < mNumOfState; i++) {
            delete [] mNextStateList[i];
        }
        delete [] mNextStateList;
        delete [] mStateNameStr;
    }

    virtual void Event(unsigned int) = 0;
    unsigned int GetCurrentState(void)
    {
        return mCurrentState;
    }
    virtual void EnableDumpStateTrans(bool enable) = 0;

protected:
    Csarad113x *mParent; 
    unsigned int mNumOfEvent;
    unsigned int mNumOfState;
    unsigned int mCurrentState;
    unsigned int mPreState;
    unsigned int mNextState;
    std::string  mStateNamePrefix;
    std::string  *mStateNameStr;
    unsigned int **mNextStateList;
    bool mDumpStateTransInfo;
    void (Cfsm_base::*pEventFunc) (unsigned int);

    virtual void CheckCondition(const unsigned int condition_id) = 0;
    virtual void fnEntry(void) = 0;
    virtual void fnDo(void) = 0;
    virtual void fnExit(void) = 0;
    virtual void DumpStateTransInfo(void) = 0;
    bool StateTransition(unsigned int event)
    {
        bool trans_next = false;
        unsigned int next_state = mNextStateList[mCurrentState][event];
        if (next_state > mNumOfState) { // next state depends on condition
            CheckCondition(next_state - mNumOfState - 1);
        } else {
            mNextState = next_state;
        }
        if ((mNextState != mNumOfState) && (mNextState != mCurrentState)) {
            DumpStateTransInfo();
            fnExit();
            fnEntry();
            fnDo();
            if (mNextStateList[mCurrentState][mNumOfEvent-1] != mNumOfState) { // if WOE is defined, next state is a non-triggered state
                trans_next = true;
            }
        }

        return trans_next;
    }
};

// Csarad113x_fsm class
class Csarad113x_fsm: public Cfsm_base
{
friend class Csarad113x;
public:
    enum eState {
        emStRESET
       ,emStIDLE
       ,emStHALT
       ,emStTH_CONV
       ,emStTH_SUSPEND
       ,emStNORMAL_SG_SCANNING
       ,emStNORMAL_SG_SCANNING_END
       ,emStNORMAL_VC_CONV
       ,emStNORMAL_VC_CONV_END
       ,emStNORMAL_SUSPEND
       ,emStNA
    };

    enum eEvent {
        emEvtResetAssert
       ,emEvtResetDeassert
       ,emEvtStartSG4Trigger
       ,emEvtStartSG3Trigger
       ,emEvtStartSG2Trigger
       ,emEvtStartSG1Trigger
       ,emEvtStartSG0Trigger
       ,emEvtTHStartSampling
       ,emEvtFinishVCConversion
       ,emEvtFinishTHConversion
       ,emEvtHaltTrigger
       ,emEvtWOE
       // Csarad113x_tha_conv_fsm
       ,emEvtTHAHWTrigger
       ,emEvtTHASWTrigger
       ,emEvtTHAStartSampling
       ,emEvtTHAHoldStart
       ,emEvtTHAHoldComplete
       ,emEvtTHAEndHolding
       ,emEvtTHAFinishVCConversion
       ,emEvtTHASuspend
       ,emEvtTHAResume
       // Csarad113x_thb_conv_fsm
       ,emEvtTHBHWTrigger
       ,emEvtTHBSWTrigger
       ,emEvtTHBStartSampling
       ,emEvtTHBHoldStart
       ,emEvtTHBHoldComplete
       ,emEvtTHBEndHolding
       ,emEvtTHBFinishVCConversion
       ,emEvtTHBSuspend
       ,emEvtTHBResume
       // End of event list
       ,emTotalNumOfEvent
    };

    struct SEventFunctionCallInfo {
        Cfsm_base *pFSMObject;    // Sub-FSM pointer
        unsigned int event_index; // Event index in the Sub-FSM
    };

    Csarad113x_fsm(Csarad113x *_parent, std::string upper_state = "");
    ~Csarad113x_fsm(void);

    void Event(unsigned int event);
    void EnableDumpStateTrans(bool enable);

private:
    Csarad113x_tha_conv_fsm* pCsarad113x_tha_conv_fsm;
    Csarad113x_thb_conv_fsm* pCsarad113x_thb_conv_fsm;
    SEventFunctionCallInfo mEventFuncTable[emTotalNumOfEvent];
    void CheckCondition(const unsigned int condition_id);
    void fnEntry(void);
    void fnDo(void);
    void fnExit(void);
    void DumpStateTransInfo(void);
};

// Csarad113x_tha_conv_fsm class
class Csarad113x_tha_conv_fsm: public Cfsm_base
{
friend class Csarad113x;
friend class Csarad113x_fsm;
public:
    enum eState {
        emStTHA_IDLE
       ,emStTHA_SAMPLING
       ,emStTHA_HOLDING
       ,emStTHA_DELAY_HOLDING
       ,emStTHA_SCANNING
       ,emStTHA_SCANNING_END
       ,emStTHA_VC_CONV
       ,emStTHA_VC_CONV_END
       ,emStTHA_SUSPEND
       ,emStTHA_WAIT_SCANNING_START
       ,emStNA
    };

    enum eEvent {
        emEvtTHAHWTrigger
       ,emEvtTHASWTrigger
       ,emEvtTHAStartSampling
       ,emEvtTHAHoldStart
       ,emEvtTHAHoldComplete
       ,emEvtTHAEndHolding
       ,emEvtTHAFinishVCConversion
       ,emEvtTHASuspend
       ,emEvtTHAResume
       ,emEvtEnd
       ,emEvtWOE
    };

    Csarad113x_tha_conv_fsm(Csarad113x *_parent, std::string upper_state = "");
    ~Csarad113x_tha_conv_fsm(void);

    void Event(unsigned int event);
    void End(void);
    void EnableDumpStateTrans(bool enable);

private:
    void CheckCondition(const unsigned int condition_id);
    void fnEntry(void);
    void fnDo(void);
    void fnExit(void);
    void DumpStateTransInfo(void);
};

// Csarad113x_thb_conv_fsm class
class Csarad113x_thb_conv_fsm: public Cfsm_base
{
friend class Csarad113x;
friend class Csarad113x_fsm;
public:
    enum eState {
        emStTHB_IDLE
       ,emStTHB_SAMPLING
       ,emStTHB_HOLDING
       ,emStTHB_DELAY_HOLDING
       ,emStTHB_SCANNING
       ,emStTHB_SCANNING_END
       ,emStTHB_VC_CONV
       ,emStTHB_VC_CONV_END
       ,emStTHB_SUSPEND
       ,emStTHB_WAIT_SCANNING_START
       ,emStNA
    };

    enum eEvent {
        emEvtTHBHWTrigger
       ,emEvtTHBSWTrigger
       ,emEvtTHBStartSampling
       ,emEvtTHBHoldStart
       ,emEvtTHBHoldComplete
       ,emEvtTHBEndHolding
       ,emEvtTHBFinishVCConversion
       ,emEvtTHBSuspend
       ,emEvtTHBResume
       ,emEvtEnd
       ,emEvtWOE
    };

    Csarad113x_thb_conv_fsm(Csarad113x *_parent, std::string upper_state = "");
    ~Csarad113x_thb_conv_fsm(void);

    void Event(unsigned int event);
    void End(void);
    void EnableDumpStateTrans(bool enable);

private:
    void CheckCondition(const unsigned int condition_id);
    void fnEntry(void);
    void fnDo(void);
    void fnExit(void);
    void DumpStateTransInfo(void);
};
#endif // __SARAD113x_FSM_H__
